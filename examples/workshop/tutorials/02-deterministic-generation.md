# Tutorial 02: Deterministic Generation

## Overview

Deterministic generation is KGEN's core superpower - the ability to produce **identical outputs from identical inputs**, every time. This tutorial explores advanced techniques for ensuring reproducible builds, managing state, and implementing enterprise-grade determinism.

**Duration**: 60 minutes  
**Prerequisites**: Tutorial 01 completed
**Level**: Intermediate

## Why Deterministic Generation Matters

### Problems with Non-Deterministic Generation

```bash
# Traditional generators often produce different outputs:

# Run 1
yeoman generate component Button
# Generates: src/Button.js with timestamp: 2025-09-12T10:30:15Z

# Run 2  
yeoman generate component Button
# Generates: src/Button.js with timestamp: 2025-09-12T10:31:22Z

# Different files! Different git hashes! Drift detected!
```

### KGEN's Solution

```bash
# KGEN produces identical outputs:

# Run 1
kgen generate component --componentName="Button"
# SHA256: e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855

# Run 2
kgen generate component --componentName="Button"  
# SHA256: e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855

# Identical! No drift! Reproducible!
```

## Step 1: Understanding Determinism Sources

### Common Non-Deterministic Sources

1. **Timestamps**: `new Date()`, `Date.now()`
2. **Random Values**: `Math.random()`, UUIDs
3. **File System**: Directory listing order
4. **Environment**: Process PIDs, hostnames
5. **Concurrency**: Race conditions, async operations

### Create a Non-Deterministic Template

Let's create a template that demonstrates the problem:

```bash
mkdir -p _templates/bad-example
```

Create `_templates/bad-example/component.js.njk`:

```njk
---
to: src/components/{{componentName}}.js
variables:
  componentName: string
---
/**
 * {{componentName}} Component
 * Generated at: {{new Date().toISOString()}} ‚ùå NON-DETERMINISTIC!
 * Build ID: {{Math.random().toString(36)}} ‚ùå NON-DETERMINISTIC!
 */

import React from 'react';

const {{componentName}} = () => {
  const buildInfo = {
    timestamp: {{Date.now()}}, ‚ùå NON-DETERMINISTIC!
    random: {{Math.random()}}, ‚ùå NON-DETERMINISTIC!
    hostname: '{{process.env.HOSTNAME}}' ‚ùå ENVIRONMENT DEPENDENT!
  };
  
  return (
    <div>
      <h1>{{componentName}}</h1>
      <pre>{JSON.stringify(buildInfo, null, 2)}</pre>
    </div>
  );
};

export default {{componentName}};
```

### Test Non-Determinism

```bash
# Generate twice and compare
kgen generate bad-example/component --componentName="TestA" > output1.js
kgen generate bad-example/component --componentName="TestA" > output2.js

# Files will be different!
diff output1.js output2.js
```

## Step 2: Achieving Determinism

### Deterministic Template Pattern

Create `_templates/good-example/component.js.njk`:

```njk
---
to: src/components/{{componentName}}.js
variables:
  componentName: string
  generatedAt?: date  # Optional, defaults to git commit time
  buildId?: string    # Optional, defaults to template hash
---
/**
 * {{componentName}} Component
 * Generated at: {{generatedAt | date('iso') | default(kgen.commitTime)}} ‚úÖ DETERMINISTIC!
 * Build ID: {{buildId | default(kgen.templateHash)}} ‚úÖ DETERMINISTIC!
 */

import React from 'react';

const {{componentName}} = () => {
  const buildInfo = {
    timestamp: '{{generatedAt | date('iso') | default(kgen.commitTime)}}', ‚úÖ DETERMINISTIC!
    buildId: '{{buildId | default(kgen.templateHash)}}', ‚úÖ DETERMINISTIC!
    version: '{{kgen.version}}' ‚úÖ DETERMINISTIC!
  };
  
  return (
    <div data-component="{{componentName | kebabCase}}">
      <h1>{{componentName}}</h1>
      {process.env.NODE_ENV === 'development' && (
        <details>
          <summary>Build Info</summary>
          <pre>{JSON.stringify(buildInfo, null, 2)}</pre>
        </details>
      )}
    </div>
  );
};

export default {{componentName}};

// Template: {{kgen.templatePath}}
// Hash: {{kgen.templateHash}}
// Generated by KGEN v{{kgen.version}}
```

### KGEN Built-in Variables

KGEN provides deterministic built-ins:

- `{{kgen.version}}` - KGEN version
- `{{kgen.templatePath}}` - Template file path
- `{{kgen.templateHash}}` - SHA256 of template content
- `{{kgen.commitHash}}` - Current git commit hash
- `{{kgen.commitTime}}` - Git commit timestamp
- `{{kgen.branchName}}` - Current git branch
- `{{kgen.repoUrl}}` - Git remote URL

### Test Determinism

```bash
# Generate twice with identical inputs
kgen generate good-example/component --componentName="TestB" > output1.js
kgen generate good-example/component --componentName="TestB" > output2.js

# Files should be identical!
diff output1.js output2.js
# No output = identical files ‚úÖ
```

## Step 3: Deterministic Data Sources

### Using Semantic Knowledge

Instead of random data, use deterministic semantic knowledge:

```njk
---
to: src/data/{{entityName}}.js
variables:
  entityName: string
knowledge:
  query: |
    SELECT ?property ?type WHERE {
      ?entity rdfs:label "{{entityName}}" .
      ?entity ?property ?value .
      ?property rdfs:range ?type .
    }
---
/**
 * {{entityName}} Data Model
 * Generated from semantic knowledge base
 */

export const {{entityName | camelCase}}Schema = {
{% for result in knowledge.results %}
  {{result.property | camelCase}}: {
    type: '{{result.type}}',
    required: {{result.required | default(false)}}
  },{% endfor %}
};

// Knowledge hash: {{knowledge.hash}}
// Query hash: {{knowledge.queryHash}}
```

### Deterministic IDs and Keys

Use content-based deterministic IDs:

```njk
---
to: src/entities/{{entityName}}.js
variables:
  entityName: string
  properties: array
---
/**
 * {{entityName}} Entity
 */

import { createHash } from 'crypto';

// Deterministic ID generation based on entity properties
const generateEntityId = (data) => {
  const content = JSON.stringify(data, Object.keys(data).sort());
  return createHash('sha256').update(content).digest('hex').substring(0, 16);
};

export class {{entityName}} {
  constructor(data) {
    this.id = generateEntityId({
      entityName: '{{entityName}}',
      templateHash: '{{kgen.templateHash}}',
      ...data
    });
    
    // Properties with deterministic defaults
{% for prop in properties %}
    this.{{prop.name}} = data.{{prop.name}} || {{prop.default | default('null')}};
{% endfor %}
  }
  
  static schema = {
{% for prop in properties %}
    {{prop.name}}: {
      type: '{{prop.type}}',
      required: {{prop.required | default(false)}},
      deterministic: true
    },{% endfor %}
  };
}

// Template signature: {{kgen.templateHash}}
```

## Step 4: Configuration-Based Determinism

### KGEN Configuration

Create `kgen.config.js` with deterministic settings:

```javascript
// kgen.config.js
export default {
  // Deterministic generation settings
  deterministic: {
    // Use git commit time as default timestamp
    defaultTimestamp: 'git-commit',
    
    // Seed for any pseudo-random operations
    seed: 'kgen-v1-workshop',
    
    // Sort arrays and objects for consistent output
    sortKeys: true,
    sortArrays: true,
    
    // Normalize whitespace and line endings
    normalizeWhitespace: true,
    lineEnding: 'lf',
    
    // Hash functions for deterministic IDs
    hashAlgorithm: 'sha256',
    hashLength: 16
  },
  
  // Template resolution
  templates: {
    directory: '_templates',
    extension: '.njk',
    
    // Cache templates for consistency
    cache: {
      enabled: true,
      ttl: 3600, // 1 hour
      hashInputs: true
    }
  },
  
  // Output settings
  output: {
    // Ensure consistent file timestamps
    preserveTimestamps: false,
    
    // Set deterministic file permissions
    fileMode: 0o644,
    dirMode: 0o755
  },
  
  // Validation
  validation: {
    // Verify determinism by default
    ensureDeterministic: true,
    
    // Check for drift on each generation
    driftDetection: true
  }
};
```

### Environment Isolation

Create `.env.kgen` for deterministic environment:

```bash
# .env.kgen - Deterministic environment variables

# Fixed versions for consistency
NODE_ENV=production
KGEN_VERSION=1.0.0

# Deterministic settings
TZ=UTC
LANG=en_US.UTF-8
LC_ALL=en_US.UTF-8

# Disable non-deterministic features
NO_UPDATE_NOTIFIER=1
CI=true

# Template-specific settings
TEMPLATE_TIMESTAMP_MODE=git-commit
TEMPLATE_ID_MODE=content-hash
```

## Step 5: Testing Determinism

### Automated Determinism Testing

Create `test/determinism.test.js`:

```javascript
// test/determinism.test.js
import { execSync } from 'child_process';
import { readFileSync, mkdtempSync, rmSync } from 'fs';
import { createHash } from 'crypto';
import { join } from 'path';
import { tmpdir } from 'os';

describe('Deterministic Generation', () => {
  const templates = [
    { name: 'component', args: '--componentName=TestComp' },
    { name: 'api-route', args: '--resourceName=users' },
    { name: 'office-report', args: '--reportType=audit --author=Test' }
  ];
  
  templates.forEach(template => {
    test(`${template.name} generates deterministically`, async () => {
      const runs = 5; // Test multiple runs
      const hashes = [];
      
      for (let i = 0; i < runs; i++) {
        // Create isolated temp directory
        const tempDir = mkdtempSync(join(tmpdir(), 'kgen-test-'));
        
        try {
          // Generate in isolated environment
          const command = `cd ${tempDir} && kgen generate ${template.name} ${template.args}`;
          execSync(command, { env: { ...process.env, KGEN_DETERMINISTIC: '1' } });
          
          // Read all generated files
          const files = execSync(`find ${tempDir} -type f -name "*.js" -o -name "*.ts" -o -name "*.jsx" -o -name "*.tsx"`, 
            { encoding: 'utf8' }).trim().split('\n').filter(Boolean);
          
          // Hash all file contents together
          const combinedContent = files
            .sort() // Consistent order
            .map(file => readFileSync(file, 'utf8'))
            .join('\n---\n');
            
          const hash = createHash('sha256').update(combinedContent).digest('hex');
          hashes.push(hash);
          
        } finally {
          // Cleanup
          rmSync(tempDir, { recursive: true, force: true });
        }
      }
      
      // All hashes should be identical
      const uniqueHashes = [...new Set(hashes)];
      expect(uniqueHashes).toHaveLength(1);
      
      console.log(`‚úÖ ${template.name}: ${runs} runs, hash: ${uniqueHashes[0].substring(0, 12)}...`);
    });
  });
});
```

### Run Determinism Tests

```bash
# Install test dependencies
npm install --save-dev jest

# Run determinism test suite
npm test -- test/determinism.test.js

# Expected output:
# ‚úÖ component: 5 runs, hash: e3b0c44298fc...
# ‚úÖ api-route: 5 runs, hash: f7c3bc1d808e...
# ‚úÖ office-report: 5 runs, hash: 2c26b46b68ff...
```

## Step 6: Drift Detection

### What is Drift?

Drift occurs when generated files are modified outside of KGEN:

```bash
# Generate a component
kgen generate component --componentName="Button"

# Manually modify the generated file
echo "// Manual change" >> src/components/Button/index.js

# Detect drift
kgen detect-drift
# Output: Drift detected in src/components/Button/index.js
#         Expected hash: e3b0c44298fc...
#         Actual hash:   f7c3bc1d808e...
```

### Implement Drift Detection

Create `.kgen/hooks/post-generate.js`:

```javascript
// .kgen/hooks/post-generate.js
import { createHash } from 'crypto';
import { writeFileSync, readFileSync } from 'fs';
import { join } from 'path';

export default function postGenerate({ filePath, content, metadata }) {
  // Calculate content hash
  const contentHash = createHash('sha256').update(content).digest('hex');
  
  // Store hash for drift detection
  const hashFile = join('.kgen', 'hashes', `${filePath.replace(/[\/\\]/g, '_')}.hash`);
  const hashData = {
    filePath,
    contentHash,
    generatedAt: metadata.generatedAt,
    templateHash: metadata.templateHash,
    inputHash: metadata.inputHash
  };
  
  writeFileSync(hashFile, JSON.stringify(hashData, null, 2));
  
  console.log(`üìù Stored hash for ${filePath}: ${contentHash.substring(0, 12)}...`);
}
```

### Drift Detection Command

Create `scripts/detect-drift.js`:

```javascript
#!/usr/bin/env node
// scripts/detect-drift.js

import { readdirSync, readFileSync, existsSync } from 'fs';
import { createHash } from 'crypto';
import { join } from 'path';

const hashDir = '.kgen/hashes';

if (!existsSync(hashDir)) {
  console.log('No hash files found. Generate some files first.');
  process.exit(0);
}

const hashFiles = readdirSync(hashDir).filter(f => f.endsWith('.hash'));
let driftCount = 0;

for (const hashFile of hashFiles) {
  const hashData = JSON.parse(readFileSync(join(hashDir, hashFile), 'utf8'));
  const { filePath, contentHash } = hashData;
  
  if (!existsSync(filePath)) {
    console.log(`‚ö†Ô∏è  File deleted: ${filePath}`);
    driftCount++;
    continue;
  }
  
  const currentContent = readFileSync(filePath, 'utf8');
  const currentHash = createHash('sha256').update(currentContent).digest('hex');
  
  if (currentHash !== contentHash) {
    console.log(`üö® Drift detected: ${filePath}`);
    console.log(`   Expected: ${contentHash.substring(0, 12)}...`);
    console.log(`   Actual:   ${currentHash.substring(0, 12)}...`);
    driftCount++;
  } else {
    console.log(`‚úÖ No drift: ${filePath}`);
  }
}

if (driftCount === 0) {
  console.log('\nüéâ No drift detected! All files match their generated state.');
} else {
  console.log(`\n‚ö†Ô∏è  ${driftCount} file(s) have drifted from their generated state.`);
  process.exit(1);
}
```

Make it executable and add to package.json:

```bash
chmod +x scripts/detect-drift.js
```

```json
// package.json
{
  "scripts": {
    "drift:detect": "node scripts/detect-drift.js",
    "drift:fix": "kgen regenerate --drift-only"
  }
}
```

## Step 7: CI/CD Integration

### GitHub Actions Workflow

Create `.github/workflows/deterministic-validation.yml`:

```yaml
name: Deterministic Generation Validation

on:
  push:
    branches: [ main, develop ]
  pull_request:
    branches: [ main ]

jobs:
  determinism:
    runs-on: ubuntu-latest
    strategy:
      matrix:
        node-version: [18, 20]
        
    steps:
    - uses: actions/checkout@v4
      with:
        fetch-depth: 0  # Need full history for git-based determinism
        
    - name: Setup Node.js ${{ matrix.node-version }}
      uses: actions/setup-node@v4
      with:
        node-version: ${{ matrix.node-version }}
        cache: 'npm'
        
    - name: Install dependencies
      run: npm ci
      
    - name: Install KGEN CLI
      run: npm install -g @kgen/cli
      
    - name: Test Deterministic Generation
      env:
        KGEN_DETERMINISTIC: "1"
        NODE_ENV: production
        TZ: UTC
      run: |
        # Run determinism tests
        npm run test:determinism
        
        # Generate all templates multiple times
        for i in {1..3}; do
          echo "Generation run $i"
          kgen generate --all --force
          
          # Store checksums
          find src -type f \( -name "*.js" -o -name "*.ts" \) -exec sha256sum {} \; > checksums-$i.txt
        done
        
        # Compare checksums
        if ! diff checksums-1.txt checksums-2.txt; then
          echo "‚ùå Non-deterministic generation detected between runs 1 and 2"
          exit 1
        fi
        
        if ! diff checksums-2.txt checksums-3.txt; then
          echo "‚ùå Non-deterministic generation detected between runs 2 and 3"
          exit 1
        fi
        
        echo "‚úÖ All generation runs produced identical outputs"
        
    - name: Drift Detection
      run: npm run drift:detect
      
    - name: Upload Generation Artifacts
      uses: actions/upload-artifact@v4
      if: failure()
      with:
        name: generation-debug-${{ matrix.node-version }}
        path: |
          checksums-*.txt
          .kgen/logs/
          src/
```

### Pre-commit Hook

Create `.githooks/pre-commit`:

```bash
#!/bin/sh
# .githooks/pre-commit

echo "üîç Checking for drift in generated files..."

# Run drift detection
if ! npm run drift:detect --silent; then
  echo "‚ùå Drift detected in generated files!"
  echo "   Either regenerate the files or commit your manual changes separately."
  echo "   To regenerate: npm run drift:fix"
  echo "   To commit anyway: git commit --no-verify"
  exit 1
fi

echo "‚úÖ No drift detected."
exit 0
```

Install the hook:

```bash
chmod +x .githooks/pre-commit
git config core.hooksPath .githooks
```

## Step 8: Advanced Determinism Techniques

### Content-Addressable Templates

Templates can reference each other deterministically:

```njk
---
to: src/{{moduleName}}/index.js
variables:
  moduleName: string
  dependencies: array
---
/**
 * {{moduleName}} Module
 * Dependencies: {{dependencies | length}} modules
 */

{% for dep in dependencies %}
// Dependency: {{dep.name}} (hash: {{dep.hash}})
import {{dep.importName}} from './{{dep.name}}';
{% endfor %}

export class {{moduleName | pascalCase}} {
  constructor() {
    this.dependencies = {
{% for dep in dependencies %}
      {{dep.name | camelCase}}: new {{dep.importName}}(),
{% endfor %}
    };
    
    // Module signature includes all dependency hashes
    this.signature = '{{kgen.templateHash}}-{% for dep in dependencies %}{{dep.hash}}{% endfor %}';
  }
}

// Module hash: {{moduleName | hash}}
// Dependency tree hash: {{dependencies | map('hash') | join('-') | hash}}
```

### Reproducible Randomness

When you need "random" values that are actually deterministic:

```njk
---
to: src/test-data/{{dataSetName}}.js
variables:
  dataSetName: string
  seed?: string
  count: number
---
/**
 * {{dataSetName}} Test Data
 * Generated with deterministic pseudo-randomness
 */

import { createHash } from 'crypto';

// Deterministic pseudo-random generator
class DeterministicRandom {
  constructor(seed) {
    this.seed = seed;
    this.state = this.hashSeed(seed);
  }
  
  hashSeed(seed) {
    return parseInt(createHash('md5').update(seed).digest('hex').substring(0, 8), 16);
  }
  
  next() {
    this.state = (this.state * 1664525 + 1013904223) % 4294967296;
    return this.state / 4294967296;
  }
  
  integer(min, max) {
    return Math.floor(this.next() * (max - min + 1)) + min;
  }
  
  choice(array) {
    return array[this.integer(0, array.length - 1)];
  }
}

const rng = new DeterministicRandom('{{seed | default(kgen.templateHash)}}-{{dataSetName}}');

export const {{dataSetName | camelCase}} = [
{% for i in range(count) %}
  {
    id: {{i + 1}},
    name: '{{['Alice', 'Bob', 'Charlie', 'Diana', 'Eve', 'Frank'] | random(seed=loop.index)}}',
    score: {{range(1, 100) | random(seed=loop.index)}},
    active: {{[true, false] | random(seed=loop.index)}}
  },{% endfor %}
];

// Data set hash: {{dataSetName | hash}}
// Seed: {{seed | default(kgen.templateHash)}}
// Generated {{count}} deterministic records
```

## Step 9: Debugging Determinism Issues

### Enable Debug Mode

```bash
# Run with detailed debugging
KGEN_DEBUG=determinism kgen generate component --componentName="Debug"

# Output:
# üîç Determinism Debug Mode
# ‚îú‚îÄ Template hash: e3b0c44298fc1c149afbf4c8996fb924
# ‚îú‚îÄ Input variables hash: 27ae41e4649b934ca495991b7852b855  
# ‚îú‚îÄ Environment hash: 649b934ca495991b7852b855e3b0c442
# ‚îú‚îÄ Git context hash: 991b7852b855e3b0c44298fc1c149afb
# ‚îú‚îÄ Combined hash: f4c8996fb92427ae41e4649b934ca495
# ‚îî‚îÄ Output hash: 8996fb92427ae41e4649b934ca495991b
```

### Determinism Report

Create `scripts/determinism-report.js`:

```javascript
#!/usr/bin/env node
// scripts/determinism-report.js

import { execSync } from 'child_process';
import { writeFileSync } from 'fs';

const templates = ['component', 'api-route', 'office-report'];
const report = {
  timestamp: new Date().toISOString(),
  environment: {
    node: process.version,
    platform: process.platform,
    arch: process.arch,
    kgen: execSync('kgen version', { encoding: 'utf8' }).trim()
  },
  results: []
};

for (const template of templates) {
  console.log(`Testing ${template}...`);
  
  const runs = 10;
  const hashes = [];
  
  for (let i = 0; i < runs; i++) {
    try {
      const output = execSync(`kgen generate ${template} --dry-run --hash-only`, {
        encoding: 'utf8',
        env: { ...process.env, KGEN_DETERMINISTIC: '1' }
      });
      
      const hash = output.trim();
      hashes.push(hash);
    } catch (error) {
      console.error(`Error in run ${i + 1}: ${error.message}`);
    }
  }
  
  const uniqueHashes = [...new Set(hashes)];
  const isDeterministic = uniqueHashes.length === 1;
  
  report.results.push({
    template,
    runs,
    uniqueHashes: uniqueHashes.length,
    isDeterministic,
    hash: uniqueHashes[0] || null,
    confidence: isDeterministic ? 1.0 : 0.0
  });
  
  console.log(`  ${isDeterministic ? '‚úÖ' : '‚ùå'} ${template}: ${uniqueHashes.length} unique hashes`);
}

// Generate report
const reportFile = 'determinism-report.json';
writeFileSync(reportFile, JSON.stringify(report, null, 2));
console.log(`\nüìä Report saved to ${reportFile}`);

// Summary
const passing = report.results.filter(r => r.isDeterministic).length;
const total = report.results.length;
console.log(`\nüéØ Summary: ${passing}/${total} templates are deterministic`);

if (passing < total) {
  process.exit(1);
}
```

## Step 10: Best Practices Summary

### ‚úÖ DO

1. **Use KGEN built-in variables**: `{{kgen.templateHash}}`, `{{kgen.commitTime}}`
2. **Content-based IDs**: Hash input data for deterministic IDs
3. **Sort collections**: Always sort arrays and object keys
4. **Fixed seeds**: Use deterministic seeds for pseudo-randomness
5. **Environment isolation**: Control environment variables
6. **Test regularly**: Automated determinism testing in CI/CD
7. **Git integration**: Leverage git context for timestamps

### ‚ùå DON'T

1. **System timestamps**: `new Date()`, `Date.now()`
2. **Random values**: `Math.random()`, `crypto.randomUUID()`
3. **Environment dependencies**: `process.env.HOSTNAME`
4. **Unsorted collections**: Rely on iteration order
5. **External API calls**: Network requests during generation
6. **Process IDs**: `process.pid`
7. **File system race conditions**: Async file operations

### Configuration Checklist

- [ ] `kgen.config.js` with deterministic settings
- [ ] `.env.kgen` with fixed environment
- [ ] Git hooks for drift detection
- [ ] CI/CD determinism validation
- [ ] Automated testing suite
- [ ] Debug logging enabled
- [ ] Hash storage for drift detection

## Conclusion

You now understand advanced deterministic generation techniques:

‚úÖ **Sources of Non-Determinism**: Timestamps, randomness, environment
‚úÖ **KGEN Built-ins**: Template hashes, git context, version info
‚úÖ **Content-Based IDs**: Deterministic identifier generation
‚úÖ **Drift Detection**: Automated detection of unauthorized changes
‚úÖ **CI/CD Integration**: Automated validation in pipelines
‚úÖ **Debugging Tools**: Debug modes and reporting

Next, learn about **drift detection in production** in Tutorial 03.

---

**Next**: [Tutorial 03: Drift Detection](03-drift-detection.md)  
**Previous**: [Tutorial 01: Getting Started](01-getting-started.md)  
**Back to**: [Workshop README](../README.md)
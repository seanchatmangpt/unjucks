# Tutorial 03: Drift Detection

## Overview

Drift detection is the process of identifying when generated files have been modified outside of KGEN's control. This tutorial covers enterprise-grade drift detection strategies, automated monitoring, and remediation workflows for production environments.

**Duration**: 60 minutes  
**Prerequisites**: Tutorials 01 and 02 completed  
**Level**: Advanced

## Understanding Drift

### What is Drift?

Drift occurs when generated artifacts are modified after generation, breaking the deterministic chain:

```bash
# 1. Generate file deterministically
kgen generate component --componentName="Button"
# Creates: src/components/Button/index.js
# Hash: e3b0c44298fc1c149afbf4c8996fb924

# 2. Manual modification (drift introduced)
echo "// Quick fix" >> src/components/Button/index.js
# Hash: f7c3bc1d808e8c7b7a2a6c5b4d9e2f8a

# 3. Drift detected
kgen detect-drift
# ⚠️ Drift detected: Button component modified outside KGEN
```

### Types of Drift

1. **Content Drift**: File contents changed
2. **Metadata Drift**: Timestamps, permissions modified
3. **Structure Drift**: Files moved, renamed, deleted
4. **Template Drift**: Template changed but files not regenerated
5. **Configuration Drift**: KGEN config changed affecting output

### Drift Impact

- **🚫 Breaks Reproducibility**: Can't regenerate identical files
- **🐛 Introduces Bugs**: Manual changes may conflict with future generations
- **🔄 Complicates Updates**: Merging template updates becomes difficult
- **📊 Reduces Confidence**: Can't trust generated artifacts

## Step 1: Setting Up Drift Detection Infrastructure

### Create Drift Detection System

Create `.kgen/drift/detector.js`:

```javascript
// .kgen/drift/detector.js
import { readFileSync, writeFileSync, existsSync, readdirSync, statSync } from 'fs';
import { createHash } from 'crypto';
import { join, dirname } from 'path';
import { mkdirSync } from 'fs';

class DriftDetector {
  constructor(options = {}) {
    this.hashDir = options.hashDir || '.kgen/hashes';
    this.metadataDir = options.metadataDir || '.kgen/metadata';
    this.configFile = options.configFile || 'kgen.config.js';
    
    // Ensure directories exist
    [this.hashDir, this.metadataDir].forEach(dir => {
      mkdirSync(dir, { recursive: true });
    });
  }
  
  /**
   * Store file signature after generation
   */
  storeSignature(filePath, content, metadata = {}) {
    const signature = this.calculateSignature(filePath, content, metadata);
    const signatureFile = this.getSignatureFile(filePath);
    
    mkdirSync(dirname(signatureFile), { recursive: true });
    writeFileSync(signatureFile, JSON.stringify(signature, null, 2));
    
    return signature;
  }
  
  /**
   * Calculate comprehensive file signature
   */
  calculateSignature(filePath, content, metadata = {}) {
    const contentHash = createHash('sha256').update(content).digest('hex');
    const stats = existsSync(filePath) ? statSync(filePath) : null;
    
    return {
      filePath,
      contentHash,
      size: content.length,
      lineCount: content.split('\n').length,
      
      // File system metadata
      fs: stats ? {
        size: stats.size,
        mtime: stats.mtime.toISOString(),
        mode: stats.mode,
        uid: stats.uid,
        gid: stats.gid
      } : null,
      
      // Generation metadata
      generation: {
        timestamp: metadata.generatedAt || new Date().toISOString(),
        templatePath: metadata.templatePath,
        templateHash: metadata.templateHash,
        inputHash: metadata.inputHash,
        kgenVersion: metadata.kgenVersion || '1.0.0'
      },
      
      // Git context
      git: {
        commit: metadata.gitCommit,
        branch: metadata.gitBranch,
        timestamp: metadata.gitTimestamp
      },
      
      // Content analysis
      analysis: {
        imports: this.extractImports(content),
        exports: this.extractExports(content),
        functions: this.extractFunctions(content),
        comments: this.extractComments(content)
      }
    };
  }
  
  /**
   * Detect drift for a specific file
   */
  detectFileDrift(filePath) {
    const signatureFile = this.getSignatureFile(filePath);
    
    if (!existsSync(signatureFile)) {
      return {
        status: 'unknown',
        message: 'No signature found - file may not be generated by KGEN'
      };
    }
    
    if (!existsSync(filePath)) {
      return {
        status: 'deleted',
        message: 'Generated file has been deleted',
        originalSignature: JSON.parse(readFileSync(signatureFile, 'utf8'))
      };
    }
    
    const originalSignature = JSON.parse(readFileSync(signatureFile, 'utf8'));
    const currentContent = readFileSync(filePath, 'utf8');
    const currentSignature = this.calculateSignature(filePath, currentContent);
    
    const drift = this.comparSignatures(originalSignature, currentSignature);
    
    return {
      status: drift.hasDrift ? 'drifted' : 'clean',
      filePath,
      drift,
      originalSignature,
      currentSignature
    };
  }
  
  /**
   * Detect drift across all tracked files
   */
  detectAllDrift() {
    if (!existsSync(this.hashDir)) {
      return { status: 'no-tracking', files: [] };
    }
    
    const signatureFiles = this.getAllSignatureFiles();
    const results = signatureFiles.map(signatureFile => {
      const signature = JSON.parse(readFileSync(signatureFile, 'utf8'));
      return this.detectFileDrift(signature.filePath);
    });
    
    const drifted = results.filter(r => r.status === 'drifted');
    const deleted = results.filter(r => r.status === 'deleted');
    const clean = results.filter(r => r.status === 'clean');
    
    return {
      status: drifted.length > 0 || deleted.length > 0 ? 'drift-detected' : 'clean',
      summary: {
        total: results.length,
        clean: clean.length,
        drifted: drifted.length,
        deleted: deleted.length
      },
      files: results
    };
  }
  
  /**
   * Compare two signatures to detect differences
   */
  comparSignatures(original, current) {
    const differences = [];
    let hasDrift = false;
    
    // Content hash comparison (most important)
    if (original.contentHash !== current.contentHash) {
      differences.push({
        type: 'content',
        severity: 'high',
        message: 'File content has changed',
        original: original.contentHash.substring(0, 12),
        current: current.contentHash.substring(0, 12)
      });
      hasDrift = true;
    }
    
    // Size comparison
    if (original.size !== current.size) {
      differences.push({
        type: 'size',
        severity: 'medium',
        message: `File size changed from ${original.size} to ${current.size} bytes`,
        original: original.size,
        current: current.size
      });
    }
    
    // Line count comparison
    if (original.lineCount !== current.lineCount) {
      differences.push({
        type: 'lines',
        severity: 'medium', 
        message: `Line count changed from ${original.lineCount} to ${current.lineCount}`,
        original: original.lineCount,
        current: current.lineCount
      });
    }
    
    // Structural analysis
    const structuralDifferences = this.compareStructure(
      original.analysis,
      current.analysis
    );
    
    differences.push(...structuralDifferences);
    
    return {
      hasDrift,
      differences,
      severity: this.calculateSeverity(differences)
    };
  }
  
  /**
   * Compare code structure (imports, exports, functions)
   */
  compareStructure(original, current) {
    const differences = [];
    
    // Compare imports
    const importDiff = this.compareArrays(
      original.imports,
      current.imports,
      'imports'
    );
    if (importDiff.length > 0) differences.push(...importDiff);
    
    // Compare exports
    const exportDiff = this.compareArrays(
      original.exports,
      current.exports, 
      'exports'
    );
    if (exportDiff.length > 0) differences.push(...exportDiff);
    
    // Compare functions
    const functionDiff = this.compareArrays(
      original.functions,
      current.functions,
      'functions'
    );
    if (functionDiff.length > 0) differences.push(...functionDiff);
    
    return differences;
  }
  
  /**
   * Helper methods for code analysis
   */
  extractImports(content) {
    const importRegex = /^\s*import\s+.*?from\s+['"]([^'"]+)['"];?/gm;
    const imports = [];
    let match;
    
    while ((match = importRegex.exec(content)) !== null) {
      imports.push(match[1]);
    }
    
    return imports.sort();
  }
  
  extractExports(content) {
    const exportRegex = /^\s*export\s+(?:default\s+)?(\w+|\{[^}]+\})/gm;
    const exports = [];
    let match;
    
    while ((match = exportRegex.exec(content)) !== null) {
      exports.push(match[1]);
    }
    
    return exports.sort();
  }
  
  extractFunctions(content) {
    const functionRegex = /(?:function\s+(\w+)|const\s+(\w+)\s*=\s*(?:\([^)]*\)\s*=>|function))/g;
    const functions = [];
    let match;
    
    while ((match = functionRegex.exec(content)) !== null) {
      functions.push(match[1] || match[2]);
    }
    
    return functions.sort();
  }
  
  extractComments(content) {
    const comments = {
      single: (content.match(/\/\/.*$/gm) || []).length,
      multi: (content.match(/\/\*[\s\S]*?\*\//g) || []).length
    };
    
    return comments;
  }
  
  /**
   * Utility methods
   */
  getSignatureFile(filePath) {
    const safeFileName = filePath.replace(/[\/\\]/g, '_').replace(/[^a-zA-Z0-9._-]/g, '_');
    return join(this.hashDir, `${safeFileName}.json`);
  }
  
  getAllSignatureFiles() {
    return readdirSync(this.hashDir)
      .filter(f => f.endsWith('.json'))
      .map(f => join(this.hashDir, f));
  }
  
  compareArrays(original, current, type) {
    const differences = [];
    const added = current.filter(item => !original.includes(item));
    const removed = original.filter(item => !current.includes(item));
    
    if (added.length > 0) {
      differences.push({
        type,
        severity: 'medium',
        message: `Added ${type}: ${added.join(', ')}`,
        added
      });
    }
    
    if (removed.length > 0) {
      differences.push({
        type,
        severity: 'medium',
        message: `Removed ${type}: ${removed.join(', ')}`,
        removed
      });
    }
    
    return differences;
  }
  
  calculateSeverity(differences) {
    const severities = differences.map(d => d.severity);
    
    if (severities.includes('high')) return 'high';
    if (severities.includes('medium')) return 'medium';
    return 'low';
  }
}

export default DriftDetector;
```

### Create CLI Interface

Create `scripts/drift-cli.js`:

```javascript
#!/usr/bin/env node
// scripts/drift-cli.js

import DriftDetector from '../.kgen/drift/detector.js';
import { program } from 'commander';
import { readFileSync, writeFileSync } from 'fs';
import chalk from 'chalk';

const detector = new DriftDetector();

program
  .name('kgen-drift')
  .description('KGEN Drift Detection CLI')
  .version('1.0.0');

// Detect drift command
program
  .command('detect')
  .description('Detect drift in generated files')
  .option('-f, --file <path>', 'Check specific file')
  .option('-j, --json', 'Output JSON format')
  .option('-v, --verbose', 'Verbose output')
  .option('--fix', 'Automatically fix drift by regenerating')
  .action(async (options) => {
    try {
      let result;
      
      if (options.file) {
        result = detector.detectFileDrift(options.file);
        result = { files: [result] }; // Normalize format
      } else {
        result = detector.detectAllDrift();
      }
      
      if (options.json) {
        console.log(JSON.stringify(result, null, 2));
        return;
      }
      
      displayDriftResults(result, options.verbose);
      
      if (options.fix && result.status === 'drift-detected') {
        await fixDrift(result);
      }
      
      // Exit with error code if drift detected
      if (result.status === 'drift-detected') {
        process.exit(1);
      }
      
    } catch (error) {
      console.error(chalk.red('❌ Error detecting drift:'), error.message);
      process.exit(1);
    }
  });

// Monitor command
program
  .command('monitor')
  .description('Continuously monitor for drift')
  .option('-i, --interval <seconds>', 'Check interval in seconds', '60')
  .option('--webhook <url>', 'Webhook URL for notifications')
  .action((options) => {
    const interval = parseInt(options.interval) * 1000;
    
    console.log(chalk.blue(`🔍 Starting drift monitoring (checking every ${options.interval}s)...`));
    
    const check = async () => {
      try {
        const result = detector.detectAllDrift();
        
        if (result.status === 'drift-detected') {
          console.log(chalk.red(`\n⚠️  Drift detected at ${new Date().toISOString()}`));
          displayDriftResults(result, false);
          
          if (options.webhook) {
            await sendWebhookNotification(options.webhook, result);
          }
        } else {
          console.log(chalk.green(`✅ ${new Date().toISOString()}: No drift detected`));
        }
      } catch (error) {
        console.error(chalk.red(`Error during monitoring: ${error.message}`));
      }
    };
    
    // Initial check
    check();
    
    // Schedule recurring checks
    setInterval(check, interval);
  });

// Report command
program
  .command('report')
  .description('Generate comprehensive drift report')
  .option('-o, --output <path>', 'Output file path', 'drift-report.json')
  .option('--html', 'Generate HTML report')
  .action((options) => {
    try {
      const result = detector.detectAllDrift();
      const report = {
        timestamp: new Date().toISOString(),
        summary: result.summary,
        status: result.status,
        files: result.files,
        metadata: {
          kgenVersion: '1.0.0',
          detector: 'KGEN Drift Detector v1.0.0',
          environment: {
            node: process.version,
            platform: process.platform
          }
        }
      };
      
      writeFileSync(options.output, JSON.stringify(report, null, 2));
      console.log(chalk.green(`📊 Report generated: ${options.output}`));
      
      if (options.html) {
        const htmlFile = options.output.replace(/\.json$/, '.html');
        generateHtmlReport(report, htmlFile);
        console.log(chalk.green(`🌐 HTML report generated: ${htmlFile}`));
      }
      
    } catch (error) {
      console.error(chalk.red('Error generating report:'), error.message);
      process.exit(1);
    }
  });

// Helper functions
function displayDriftResults(result, verbose = false) {
  console.log(chalk.bold('\n🔍 KGEN Drift Detection Results\n'));
  
  if (result.status === 'no-tracking') {
    console.log(chalk.yellow('⚠️  No tracked files found. Generate some files first.'));
    return;
  }
  
  if (result.summary) {
    console.log(`Total files: ${result.summary.total}`);
    console.log(`Clean: ${chalk.green(result.summary.clean)}`);
    console.log(`Drifted: ${chalk.red(result.summary.drifted)}`);
    console.log(`Deleted: ${chalk.red(result.summary.deleted)}`);
    console.log('');
  }
  
  result.files.forEach(file => {
    const status = file.status;
    const icon = {
      clean: chalk.green('✅'),
      drifted: chalk.red('⚠️ '),
      deleted: chalk.red('❌'),
      unknown: chalk.yellow('❓')
    }[status] || '?';
    
    console.log(`${icon} ${file.filePath}`);
    
    if (status === 'drifted' && file.drift) {
      file.drift.differences.forEach(diff => {
        const color = diff.severity === 'high' ? chalk.red : 
                     diff.severity === 'medium' ? chalk.yellow : chalk.gray;
        console.log(`    ${color('• ' + diff.message)}`);
      });
      
      if (verbose) {
        console.log(`    Severity: ${file.drift.severity}`);
        console.log(`    Original hash: ${file.originalSignature.contentHash.substring(0, 12)}...`);
        console.log(`    Current hash:  ${file.currentSignature.contentHash.substring(0, 12)}...`);
      }
    }
    
    if (status === 'deleted') {
      console.log(chalk.red('    File has been deleted'));
    }
    
    console.log('');
  });
}

async function fixDrift(result) {
  console.log(chalk.blue('\n🔧 Attempting to fix drift...'));
  
  const driftedFiles = result.files.filter(f => f.status === 'drifted');
  
  for (const file of driftedFiles) {
    try {
      const signature = file.originalSignature;
      const templatePath = signature.generation.templatePath;
      
      if (!templatePath) {
        console.log(chalk.yellow(`⚠️  Cannot fix ${file.filePath}: No template information`));
        continue;
      }
      
      console.log(`Regenerating ${file.filePath}...`);
      
      // This would integrate with KGEN's regeneration system
      // For now, we just log what would happen
      console.log(chalk.green(`✅ Would regenerate from template: ${templatePath}`));
      
    } catch (error) {
      console.log(chalk.red(`❌ Failed to fix ${file.filePath}: ${error.message}`));
    }
  }
}

async function sendWebhookNotification(webhookUrl, result) {
  // Implement webhook notification
  console.log(`📡 Sending notification to ${webhookUrl}`);
}

function generateHtmlReport(report, outputPath) {
  const html = `
    <!DOCTYPE html>
    <html>
    <head>
        <title>KGEN Drift Detection Report</title>
        <style>
            body { font-family: Arial, sans-serif; margin: 40px; }
            .status-clean { color: green; }
            .status-drifted { color: red; }
            .status-deleted { color: red; }
            .diff-high { color: red; font-weight: bold; }
            .diff-medium { color: orange; }
            .diff-low { color: gray; }
        </style>
    </head>
    <body>
        <h1>KGEN Drift Detection Report</h1>
        <p>Generated: ${report.timestamp}</p>
        
        <h2>Summary</h2>
        <ul>
            <li>Total files: ${report.summary?.total || 0}</li>
            <li class="status-clean">Clean: ${report.summary?.clean || 0}</li>
            <li class="status-drifted">Drifted: ${report.summary?.drifted || 0}</li>
            <li class="status-deleted">Deleted: ${report.summary?.deleted || 0}</li>
        </ul>
        
        <h2>Files</h2>
        ${report.files.map(file => `
            <div style="margin-bottom: 20px; padding: 10px; border: 1px solid #ccc;">
                <h3 class="status-${file.status}">${file.filePath}</h3>
                <p>Status: ${file.status}</p>
                ${file.drift ? `
                    <h4>Differences:</h4>
                    <ul>
                        ${file.drift.differences.map(diff => 
                            `<li class="diff-${diff.severity}">${diff.message}</li>`
                        ).join('')}
                    </ul>
                ` : ''}
            </div>
        `).join('')}
        
        <footer>
            <p>Generated by ${report.metadata.detector}</p>
        </footer>
    </body>
    </html>
  `;
  
  writeFileSync(outputPath, html);
}

program.parse();
```

## Step 2: Integration with KGEN Generation

### Post-Generation Hook

Create `.kgen/hooks/post-generate.js`:

```javascript
// .kgen/hooks/post-generate.js
import DriftDetector from '../drift/detector.js';
import { execSync } from 'child_process';

const detector = new DriftDetector();

export default async function postGenerate(context) {
  const { filePath, content, templatePath, variables, kgenVersion } = context;
  
  try {
    // Get git context
    const gitCommit = execSync('git rev-parse HEAD', { encoding: 'utf8' }).trim();
    const gitBranch = execSync('git branch --show-current', { encoding: 'utf8' }).trim();
    const gitTimestamp = execSync('git show -s --format=%ci HEAD', { encoding: 'utf8' }).trim();
    
    // Calculate template and input hashes
    const templateHash = context.templateHash;
    const inputHash = context.inputHash;
    
    // Store signature for drift detection
    const signature = detector.storeSignature(filePath, content, {
      generatedAt: new Date().toISOString(),
      templatePath,
      templateHash,
      inputHash,
      kgenVersion,
      gitCommit,
      gitBranch,
      gitTimestamp,
      variables
    });
    
    console.log(`📝 Tracking generated file: ${filePath}`);
    console.log(`    Hash: ${signature.contentHash.substring(0, 12)}...`);
    
  } catch (error) {
    console.warn(`⚠️  Warning: Could not store drift signature for ${filePath}:`, error.message);
  }
}
```

## Step 3: CI/CD Integration

### GitHub Actions Drift Detection

Create `.github/workflows/drift-detection.yml`:

```yaml
name: Drift Detection

on:
  push:
    branches: [ main, develop ]
  pull_request:
    branches: [ main ]
  schedule:
    # Run drift detection daily at 2 AM UTC
    - cron: '0 2 * * *'

jobs:
  drift-detection:
    runs-on: ubuntu-latest
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      with:
        fetch-depth: 0  # Need full git history
        
    - name: Setup Node.js
      uses: actions/setup-node@v4
      with:
        node-version: '18'
        cache: 'npm'
        
    - name: Install dependencies
      run: |
        npm ci
        npm install -g @kgen/cli commander chalk
        
    - name: Restore drift signatures
      uses: actions/cache@v4
      with:
        path: .kgen/hashes
        key: kgen-signatures-${{ github.sha }}
        restore-keys: |
          kgen-signatures-${{ github.ref }}
          kgen-signatures-
          
    - name: Generate fresh copies (dry run)
      env:
        KGEN_DETERMINISTIC: "1"
      run: |
        # Generate all templates without writing files
        kgen generate --all --dry-run --store-signatures
        
    - name: Detect drift
      id: drift
      run: |
        # Run drift detection
        node scripts/drift-cli.js detect --json > drift-results.json
        
        # Check results
        if jq -e '.status == "drift-detected"' drift-results.json > /dev/null; then
          echo "drift_detected=true" >> $GITHUB_OUTPUT
          echo "⚠️ Drift detected!"
          
          # Display summary
          node scripts/drift-cli.js detect --verbose
        else
          echo "drift_detected=false" >> $GITHUB_OUTPUT
          echo "✅ No drift detected"
        fi
        
    - name: Generate drift report
      if: always()
      run: |
        node scripts/drift-cli.js report --output drift-report.json --html
        
    - name: Upload drift report
      uses: actions/upload-artifact@v4
      if: always()
      with:
        name: drift-report
        path: |
          drift-report.json
          drift-report.html
          drift-results.json
          
    - name: Comment on PR with drift results
      if: github.event_name == 'pull_request' && steps.drift.outputs.drift_detected == 'true'
      uses: actions/github-script@v7
      with:
        script: |
          const fs = require('fs');
          const driftResults = JSON.parse(fs.readFileSync('drift-results.json', 'utf8'));
          
          const driftedFiles = driftResults.files.filter(f => f.status === 'drifted');
          const deletedFiles = driftResults.files.filter(f => f.status === 'deleted');
          
          let comment = '## ⚠️ Drift Detection Results\n\n';
          comment += `**Summary**: ${driftResults.summary.drifted} drifted, ${driftResults.summary.deleted} deleted\n\n`;
          
          if (driftedFiles.length > 0) {
            comment += '### Drifted Files\n';
            driftedFiles.forEach(file => {
              comment += `- ⚠️ \`${file.filePath}\`\n`;
              if (file.drift) {
                file.drift.differences.forEach(diff => {
                  comment += `  - ${diff.message}\n`;
                });
              }
            });
            comment += '\n';
          }
          
          if (deletedFiles.length > 0) {
            comment += '### Deleted Files\n';
            deletedFiles.forEach(file => {
              comment += `- ❌ \`${file.filePath}\` (was generated)\n`;
            });
            comment += '\n';
          }
          
          comment += '**Recommendation**: Regenerate drifted files or commit manual changes explicitly.\n';
          comment += '\n[View detailed report](../actions/runs/${{ github.run_id }})';
          
          github.rest.issues.createComment({
            issue_number: context.issue.number,
            owner: context.repo.owner,
            repo: context.repo.repo,
            body: comment
          });
          
    - name: Fail on drift (configurable)
      if: steps.drift.outputs.drift_detected == 'true' && github.ref == 'refs/heads/main'
      run: |
        echo "::error::Drift detected in main branch!"
        exit 1
```

### Pre-commit Hook Enhancement

Update `.githooks/pre-commit`:

```bash
#!/bin/sh
# .githooks/pre-commit - Enhanced with drift detection

echo "🔍 Running pre-commit drift detection..."

# Check for drift in staged files
STAGED_FILES=$(git diff --cached --name-only)

if [ -n "$STAGED_FILES" ]; then
  # Check if any staged files are KGEN-generated
  for file in $STAGED_FILES; do
    if [ -f ".kgen/hashes/${file//[\/\\]/_}.json" ]; then
      echo "  Checking KGEN-generated file: $file"
      
      # Run drift detection on specific file
      if ! node scripts/drift-cli.js detect --file "$file" --json > /dev/null; then
        echo "❌ Drift detected in staged file: $file"
        echo "   This file was generated by KGEN but has manual modifications."
        echo "   Options:"
        echo "   1. Regenerate: kgen regenerate --file $file"
        echo "   2. Accept changes: kgen accept-drift --file $file"
        echo "   3. Commit anyway: git commit --no-verify"
        exit 1
      fi
    fi
  done
fi

# Run full drift detection
if ! node scripts/drift-cli.js detect --json > /dev/null; then
  echo "❌ Drift detected in working directory!"
  echo "   Run 'node scripts/drift-cli.js detect' for details"
  exit 1
fi

echo "✅ No drift detected - commit allowed"
exit 0
```

## Step 4: Advanced Drift Detection Strategies

### Semantic Drift Detection

Detect drift at the semantic level, not just content:

```javascript
// .kgen/drift/semantic-detector.js
import { parse as parseJs } from '@babel/parser';
import { parse as parseTs } from '@typescript-eslint/typescript-estree';

class SemanticDriftDetector {
  /**
   * Detect semantic changes in JavaScript/TypeScript files
   */
  detectSemanticDrift(originalContent, currentContent, filePath) {
    try {
      const ext = filePath.split('.').pop();
      
      if (['js', 'jsx', 'ts', 'tsx'].includes(ext)) {
        return this.detectJavaScriptDrift(originalContent, currentContent, ext);
      }
      
      // For other file types, fall back to content comparison
      return { hasDrift: originalContent !== currentContent };
      
    } catch (error) {
      console.warn(`Warning: Could not parse ${filePath} for semantic analysis:`, error.message);
      return { hasDrift: originalContent !== currentContent, parseError: true };
    }
  }
  
  detectJavaScriptDrift(originalContent, currentContent, fileType) {
    const originalAst = this.parseCode(originalContent, fileType);
    const currentAst = this.parseCode(currentContent, fileType);
    
    const originalSignature = this.extractSemanticSignature(originalAst);
    const currentSignature = this.extractSemanticSignature(currentAst);
    
    return this.compareSemanticSignatures(originalSignature, currentSignature);
  }
  
  parseCode(content, fileType) {
    const isTypeScript = ['ts', 'tsx'].includes(fileType);
    const isJSX = ['jsx', 'tsx'].includes(fileType);
    
    if (isTypeScript) {
      return parseTs(content, {
        loc: true,
        jsx: isJSX
      });
    } else {
      return parseJs(content, {
        sourceType: 'module',
        allowImportExportEverywhere: true,
        allowReturnOutsideFunction: true,
        plugins: isJSX ? ['jsx'] : []
      });
    }
  }
  
  extractSemanticSignature(ast) {
    const signature = {
      imports: [],
      exports: [],
      functions: [],
      classes: [],
      variables: [],
      types: [] // TypeScript types
    };
    
    // Walk AST and extract semantic elements
    this.walkAST(ast, (node) => {
      switch (node.type) {
        case 'ImportDeclaration':
          signature.imports.push({
            source: node.source.value,
            specifiers: node.specifiers.map(s => s.local.name)
          });
          break;
          
        case 'ExportNamedDeclaration':
        case 'ExportDefaultDeclaration':
          signature.exports.push({
            type: node.type,
            name: this.getExportName(node)
          });
          break;
          
        case 'FunctionDeclaration':
        case 'ArrowFunctionExpression':
          signature.functions.push({
            name: node.id?.name || 'anonymous',
            params: node.params.length,
            async: node.async || false
          });
          break;
          
        case 'ClassDeclaration':
          signature.classes.push({
            name: node.id.name,
            superClass: node.superClass?.name,
            methods: this.extractClassMethods(node)
          });
          break;
          
        case 'VariableDeclaration':
          signature.variables.push({
            kind: node.kind,
            names: node.declarations.map(d => d.id.name)
          });
          break;
          
        case 'TSTypeAliasDeclaration':
        case 'TSInterfaceDeclaration':
          signature.types.push({
            name: node.id.name,
            type: node.type
          });
          break;
      }
    });
    
    return signature;
  }
  
  compareSemanticSignatures(original, current) {
    const differences = [];
    let hasDrift = false;
    
    // Compare each semantic element
    const sections = ['imports', 'exports', 'functions', 'classes', 'variables', 'types'];
    
    for (const section of sections) {
      const diff = this.compareSection(original[section], current[section], section);
      if (diff.length > 0) {
        differences.push(...diff);
        hasDrift = true;
      }
    }
    
    return {
      hasDrift,
      differences,
      semanticAnalysis: true
    };
  }
  
  // Helper methods...
  walkAST(node, callback) {
    callback(node);
    
    for (const key in node) {
      if (node[key] && typeof node[key] === 'object') {
        if (Array.isArray(node[key])) {
          node[key].forEach(child => {
            if (child && typeof child === 'object' && child.type) {
              this.walkAST(child, callback);
            }
          });
        } else if (node[key].type) {
          this.walkAST(node[key], callback);
        }
      }
    }
  }
}
```

## Step 5: Drift Remediation Strategies

### Automatic Remediation

Create `scripts/drift-remediation.js`:

```javascript
// scripts/drift-remediation.js
import DriftDetector from '../.kgen/drift/detector.js';
import { readFileSync, writeFileSync, copyFileSync, existsSync } from 'fs';
import { execSync } from 'child_process';
import { createInterface } from 'readline';

class DriftRemediation {
  constructor() {
    this.detector = new DriftDetector();
  }
  
  async remediateDrift(options = {}) {
    const driftResult = this.detector.detectAllDrift();
    
    if (driftResult.status !== 'drift-detected') {
      console.log('✅ No drift detected - no remediation needed');
      return;
    }
    
    const driftedFiles = driftResult.files.filter(f => f.status === 'drifted');
    const deletedFiles = driftResult.files.filter(f => f.status === 'deleted');
    
    console.log(`🔧 Remediating ${driftedFiles.length} drifted files...`);
    
    for (const file of driftedFiles) {
      await this.remediateFile(file, options);
    }
    
    for (const file of deletedFiles) {
      await this.restoreFile(file, options);
    }
  }
  
  async remediateFile(file, options) {
    const { filePath, originalSignature, currentSignature } = file;
    
    console.log(`\n📝 Processing: ${filePath}`);
    
    if (!originalSignature.generation.templatePath) {
      console.log('⚠️  Cannot remediate: No template information available');
      return;
    }
    
    // Show differences
    console.log('Differences detected:');
    file.drift.differences.forEach(diff => {
      console.log(`  • ${diff.message}`);
    });
    
    const strategy = await this.chooseRemediationStrategy(file, options);
    
    switch (strategy) {
      case 'regenerate':
        await this.regenerateFile(file);
        break;
        
      case 'merge':
        await this.mergeChanges(file);
        break;
        
      case 'accept':
        await this.acceptChanges(file);
        break;
        
      case 'backup-regenerate':
        await this.backupAndRegenerate(file);
        break;
        
      case 'skip':
        console.log('🙅 Skipping file');
        break;
    }
  }
  
  async chooseRemediationStrategy(file, options) {
    if (options.auto) {
      // Automatic remediation based on drift severity
      const severity = file.drift.severity;
      
      if (severity === 'low') {
        return 'accept'; // Accept minor changes
      } else if (severity === 'medium') {
        return 'merge'; // Try to merge changes
      } else {
        return 'backup-regenerate'; // Backup and regenerate for high severity
      }
    }
    
    // Interactive mode
    const rl = createInterface({
      input: process.stdin,
      output: process.stdout
    });
    
    const question = `
Choose remediation strategy for ${file.filePath}:
` +
      '1. Regenerate (overwrite with template output)\n' +
      '2. Merge changes (attempt smart merge)\n' +
      '3. Accept changes (update signature)\n' +
      '4. Backup and regenerate (save current version)\n' +
      '5. Skip this file\n' +
      'Choice (1-5): ';
    
    return new Promise((resolve) => {
      rl.question(question, (answer) => {
        rl.close();
        
        const strategies = {
          '1': 'regenerate',
          '2': 'merge', 
          '3': 'accept',
          '4': 'backup-regenerate',
          '5': 'skip'
        };
        
        resolve(strategies[answer] || 'skip');
      });
    });
  }
  
  async regenerateFile(file) {
    try {
      const signature = file.originalSignature;
      const templatePath = signature.generation.templatePath;
      
      console.log(`🔄 Regenerating from template: ${templatePath}`);
      
      // Extract original variables from signature
      const variables = signature.variables || {};
      const variableArgs = Object.entries(variables)
        .map(([key, value]) => `--${key}="${value}"`)
        .join(' ');
      
      // Regenerate file
      const command = `kgen generate ${templatePath} ${variableArgs} --force`;
      execSync(command, { stdio: 'inherit' });
      
      console.log('✅ File regenerated successfully');
      
    } catch (error) {
      console.error(`❌ Failed to regenerate: ${error.message}`);
    }
  }
  
  async mergeChanges(file) {
    console.log('🔀 Attempting to merge changes...');
    
    // This is a simplified merge strategy
    // A real implementation would use AST-based merging
    
    const originalContent = this.reconstructOriginalContent(file.originalSignature);
    const currentContent = readFileSync(file.filePath, 'utf8');
    const templateContent = await this.getTemplateOutput(file.originalSignature);
    
    // Use git merge for content merging
    const tempDir = '/tmp/kgen-merge';
    const originalFile = `${tempDir}/original`;
    const currentFile = `${tempDir}/current`;
    const templateFile = `${tempDir}/template`;
    
    try {
      execSync(`mkdir -p ${tempDir}`);
      writeFileSync(originalFile, originalContent);
      writeFileSync(currentFile, currentContent);
      writeFileSync(templateFile, templateContent);
      
      // Attempt 3-way merge
      const mergeCommand = `git merge-file ${currentFile} ${originalFile} ${templateFile}`;
      execSync(mergeCommand);
      
      // Read merged result
      const mergedContent = readFileSync(currentFile, 'utf8');
      writeFileSync(file.filePath, mergedContent);
      
      console.log('✅ Changes merged successfully');
      
      // Update signature
      this.detector.storeSignature(file.filePath, mergedContent, {
        ...file.originalSignature.generation,
        mergedAt: new Date().toISOString()
      });
      
    } catch (error) {
      console.log('⚠️  Automatic merge failed, falling back to backup-regenerate');
      await this.backupAndRegenerate(file);
    } finally {
      execSync(`rm -rf ${tempDir}`);
    }
  }
  
  async acceptChanges(file) {
    console.log('✅ Accepting manual changes...');
    
    // Update the signature to match current content
    const currentContent = readFileSync(file.filePath, 'utf8');
    
    const newSignature = {
      ...file.originalSignature.generation,
      acceptedAt: new Date().toISOString(),
      acceptedChanges: true,
      driftReason: 'Manual changes accepted by user'
    };
    
    this.detector.storeSignature(file.filePath, currentContent, newSignature);
    console.log('✅ Signature updated to accept current state');
  }
  
  async backupAndRegenerate(file) {
    const backupPath = `${file.filePath}.drift-backup-${Date.now()}`;
    
    console.log(`💾 Creating backup: ${backupPath}`);
    copyFileSync(file.filePath, backupPath);
    
    await this.regenerateFile(file);
    
    console.log(`ℹ️  Original changes saved to: ${backupPath}`);
  }
}

// CLI interface
if (import.meta.url === `file://${process.argv[1]}`) {
  const remediation = new DriftRemediation();
  const auto = process.argv.includes('--auto');
  
  remediation.remediateDrift({ auto })
    .then(() => console.log('\n✅ Drift remediation completed'))
    .catch(error => {
      console.error('\n❌ Drift remediation failed:', error.message);
      process.exit(1);
    });
}

export default DriftRemediation;
```

## Step 6: Production Monitoring

### Docker Container for Drift Monitoring

Create `docker/drift-monitor/Dockerfile`:

```dockerfile
# docker/drift-monitor/Dockerfile
FROM node:18-alpine

WORKLABEL maintainer="KGEN Workshop"
LABEL description="KGEN Drift Monitoring Service"

# Install git (needed for KGEN)
RUN apk add --no-cache git

# Create app directory
WORKDIR /app

# Copy package files
COPY package*.json ./

# Install dependencies
RUN npm ci --only=production

# Install KGEN CLI
RUN npm install -g @kgen/cli

# Copy application code
COPY . .

# Create monitoring script
RUN cat > monitor.js << 'EOF'
import DriftDetector from './.kgen/drift/detector.js';
import { writeFileSync } from 'fs';
import express from 'express';

const app = express();
const detector = new DriftDetector();
const port = process.env.PORT || 3000;

// Health check endpoint
app.get('/health', (req, res) => {
  res.json({ status: 'healthy', timestamp: new Date().toISOString() });
});

// Drift status endpoint
app.get('/drift/status', async (req, res) => {
  try {
    const result = detector.detectAllDrift();
    res.json(result);
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

// Start monitoring
const monitor = () => {
  console.log('Running drift check...');
  
  try {
    const result = detector.detectAllDrift();
    
    if (result.status === 'drift-detected') {
      console.error('DRIFT DETECTED:', result.summary);
      
      // Send alert (webhook, email, etc.)
      if (process.env.WEBHOOK_URL) {
        // Send webhook notification
      }
    } else {
      console.log('No drift detected');
    }
    
    // Log results
    writeFileSync('/app/logs/drift-check.log', 
      JSON.stringify({ timestamp: new Date().toISOString(), result }, null, 2) + '\n',
      { flag: 'a' }
    );
    
  } catch (error) {
    console.error('Drift check failed:', error.message);
  }
};

// Start web server
app.listen(port, () => {
  console.log(`Drift monitor listening on port ${port}`);
});

// Schedule drift checks
const interval = parseInt(process.env.CHECK_INTERVAL_MINUTES || '60') * 60 * 1000;
setInterval(monitor, interval);

// Initial check
monitor();
EOF

# Expose port
EXPOSE 3000

# Create logs directory
RUN mkdir -p logs

# Health check
HEALTHCHECK --interval=30s --timeout=3s --start-period=5s --retries=3 \
  CMD curl -f http://localhost:3000/health || exit 1

# Run monitoring service
CMD ["node", "monitor.js"]
```

### Kubernetes Deployment

Create `k8s/drift-monitor.yaml`:

```yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: kgen-drift-monitor
  namespace: kgen-system
spec:
  replicas: 1
  selector:
    matchLabels:
      app: kgen-drift-monitor
  template:
    metadata:
      labels:
        app: kgen-drift-monitor
    spec:
      containers:
      - name: drift-monitor
        image: kgen/drift-monitor:v1.0.0
        ports:
        - containerPort: 3000
        env:
        - name: CHECK_INTERVAL_MINUTES
          value: "30"
        - name: WEBHOOK_URL
          valueFrom:
            secretKeyRef:
              name: drift-monitor-secrets
              key: webhook-url
        volumeMounts:
        - name: git-repo
          mountPath: /app/repo
        - name: drift-logs
          mountPath: /app/logs
        resources:
          requests:
            memory: "128Mi"
            cpu: "100m"
          limits:
            memory: "256Mi"
            cpu: "200m"
      volumes:
      - name: git-repo
        gitRepo:
          repository: "https://github.com/your-org/your-kgen-project.git"
          revision: "main"
      - name: drift-logs
        persistentVolumeClaim:
          claimName: drift-logs-pvc
---
apiVersion: v1
kind: Service
metadata:
  name: kgen-drift-monitor-service
  namespace: kgen-system
spec:
  selector:
    app: kgen-drift-monitor
  ports:
  - port: 80
    targetPort: 3000
  type: ClusterIP
---
apiVersion: networking.k8s.io/v1
kind: Ingress
metadata:
  name: kgen-drift-monitor-ingress
  namespace: kgen-system
spec:
  rules:
  - host: drift-monitor.kgen.internal
    http:
      paths:
      - path: /
        pathType: Prefix
        backend:
          service:
            name: kgen-drift-monitor-service
            port:
              number: 80
```

## Step 7: Workshop Exercises

### Exercise 1: Basic Drift Detection

```bash
# 1. Generate a component
cd examples/workshop
kgen generate nextjs-app/page --pageName="Dashboard" --title="My Dashboard"

# 2. Introduce drift
echo "// Manual modification" >> app/dashboard/page.tsx

# 3. Detect drift
node ../../scripts/drift-cli.js detect --verbose

# Expected: Drift detected with content hash mismatch
```

### Exercise 2: Remediation Strategies

```bash
# 1. Run remediation in interactive mode
node ../../scripts/drift-remediation.js

# 2. Try different strategies:
#    - Accept changes
#    - Regenerate file
#    - Backup and regenerate

# 3. Verify results
node ../../scripts/drift-cli.js detect
```

### Exercise 3: CI/CD Integration

```bash
# 1. Commit changes with drift
git add .
git commit -m "Test drift detection"
# Should trigger pre-commit hook and fail

# 2. Fix drift and retry
node scripts/drift-cli.js detect --fix
git add .
git commit -m "Fixed drift"
# Should succeed
```

## Conclusion

You've learned advanced drift detection techniques:

✅ **Drift Types**: Content, metadata, structural, template, and configuration drift  
✅ **Detection System**: Comprehensive signature-based detection  
✅ **CI/CD Integration**: Automated drift detection in pipelines  
✅ **Remediation**: Multiple strategies for fixing drift  
✅ **Production Monitoring**: Container-based monitoring service  
✅ **Semantic Analysis**: AST-based drift detection for code files  

You now have the tools to maintain the integrity of generated code in production environments.

---

**Previous**: [Tutorial 02: Deterministic Generation](02-deterministic-generation.md)  
**Back to**: [Workshop README](../README.md)
const path = require('path');\nconst os = require('os');\n\nclass MonitoringConfig {\n  constructor(environment = process.env.NODE_ENV || 'development') {\n    this.environment = environment;\n    this.loadConfiguration();\n  }\n\n  loadConfiguration() {\n    this.config = {\n      // Global monitoring settings\n      global: {\n        serviceName: process.env.SERVICE_NAME || 'unjucks-service',\n        serviceVersion: process.env.SERVICE_VERSION || '1.0.0',\n        environment: this.environment,\n        enabledFeatures: {\n          logging: true,\n          tracing: true,\n          metrics: true,\n          alerting: true,\n          sliSlo: true,\n          healthChecks: true\n        },\n        retentionPeriods: {\n          logs: '30d',\n          traces: '7d',\n          metrics: '90d',\n          alerts: '180d',\n          healthChecks: '30d'\n        }\n      },\n\n      // Structured logging configuration\n      logging: {\n        level: this.getLogLevel(),\n        format: 'json',\n        outputs: {\n          console: {\n            enabled: true,\n            colorize: this.environment === 'development',\n            level: 'info'\n          },\n          file: {\n            enabled: true,\n            directory: './logs',\n            filename: 'application.log',\n            maxSize: '10MB',\n            maxFiles: 5,\n            level: 'info'\n          },\n          errorFile: {\n            enabled: true,\n            directory: './logs',\n            filename: 'error.log',\n            maxSize: '10MB',\n            maxFiles: 3,\n            level: 'error'\n          },\n          syslog: {\n            enabled: this.environment === 'production',\n            host: process.env.SYSLOG_HOST || 'localhost',\n            port: process.env.SYSLOG_PORT || 514,\n            protocol: 'udp4',\n            facility: 'local0'\n          },\n          elasticsearch: {\n            enabled: false,\n            host: process.env.ELASTICSEARCH_HOST || 'localhost:9200',\n            index: 'application-logs',\n            level: 'info'\n          }\n        },\n        correlation: {\n          enabled: true,\n          headerName: 'x-correlation-id',\n          generateIfMissing: true\n        },\n        sanitization: {\n          enabled: true,\n          sensitiveFields: ['password', 'token', 'key', 'secret', 'authorization'],\n          maskCharacter: '*'\n        }\n      },\n\n      // Distributed tracing configuration\n      tracing: {\n        enabled: true,\n        samplingRate: this.getSamplingRate(),\n        exporters: {\n          jaeger: {\n            enabled: true,\n            endpoint: process.env.JAEGER_ENDPOINT || 'http://localhost:14268/api/traces',\n            serviceName: process.env.SERVICE_NAME || 'unjucks-service'\n          },\n          zipkin: {\n            enabled: false,\n            endpoint: process.env.ZIPKIN_ENDPOINT || 'http://localhost:9411/api/v2/spans'\n          },\n          otlp: {\n            enabled: false,\n            endpoint: process.env.OTLP_ENDPOINT || 'http://localhost:4318/v1/traces',\n            headers: {}\n          }\n        },\n        instrumentation: {\n          http: {\n            enabled: true,\n            requestHook: true,\n            responseHook: true,\n            sensitiveHeaders: ['authorization', 'cookie', 'x-api-key']\n          },\n          express: {\n            enabled: true,\n            ignoreRoutes: ['/health', '/metrics', '/favicon.ico']\n          },\n          database: {\n            enabled: true,\n            captureQueries: this.environment !== 'production'\n          },\n          redis: {\n            enabled: true,\n            captureCommands: this.environment !== 'production'\n          },\n          fs: {\n            enabled: false\n          }\n        },\n        customAttributes: {\n          environment: this.environment,\n          version: process.env.SERVICE_VERSION || '1.0.0',\n          hostname: os.hostname()\n        }\n      },\n\n      // Metrics configuration\n      metrics: {\n        enabled: true,\n        prefix: 'unjucks_',\n        collectInterval: 15000, // 15 seconds\n        exporters: {\n          prometheus: {\n            enabled: true,\n            port: 9090,\n            endpoint: '/metrics',\n            collectDefaultMetrics: true,\n            gcMetrics: true\n          },\n          statsd: {\n            enabled: false,\n            host: process.env.STATSD_HOST || 'localhost',\n            port: process.env.STATSD_PORT || 8125,\n            prefix: 'unjucks.'\n          }\n        },\n        customMetrics: {\n          business: {\n            enabled: true,\n            metrics: [\n              'user_registrations_total',\n              'file_generations_total',\n              'template_renders_total',\n              'api_calls_total'\n            ]\n          },\n          performance: {\n            enabled: true,\n            percentiles: [0.5, 0.9, 0.95, 0.99]\n          },\n          errors: {\n            enabled: true,\n            groupByType: true\n          }\n        },\n        histogramBuckets: {\n          httpDuration: [0.1, 0.3, 0.5, 0.7, 1, 3, 5, 7, 10],\n          dbDuration: [0.001, 0.01, 0.1, 0.5, 1, 2, 5],\n          operationDuration: [0.01, 0.1, 0.5, 1, 2, 5, 10, 30]\n        }\n      },\n\n      // Alerting configuration\n      alerting: {\n        enabled: true,\n        channels: {\n          console: {\n            enabled: true\n          },\n          email: {\n            enabled: this.environment === 'production',\n            smtp: {\n              host: process.env.SMTP_HOST,\n              port: process.env.SMTP_PORT || 587,\n              secure: false,\n              auth: {\n                user: process.env.SMTP_USER,\n                pass: process.env.SMTP_PASS\n              }\n            },\n            from: process.env.ALERT_FROM_EMAIL,\n            to: process.env.ALERT_TO_EMAIL?.split(',') || []\n          },\n          slack: {\n            enabled: this.environment === 'production',\n            webhookUrl: process.env.SLACK_WEBHOOK_URL,\n            channel: process.env.SLACK_CHANNEL || '#alerts',\n            username: 'Monitoring Bot'\n          },\n          pagerduty: {\n            enabled: this.environment === 'production',\n            integrationKey: process.env.PAGERDUTY_INTEGRATION_KEY,\n            severity: 'critical'\n          },\n          webhook: {\n            enabled: false,\n            url: process.env.WEBHOOK_URL,\n            headers: {\n              'Authorization': process.env.WEBHOOK_AUTH_HEADER\n            }\n          }\n        },\n        rules: {\n          errorRate: {\n            enabled: true,\n            threshold: 0.05, // 5%\n            timeWindow: '5m',\n            severity: 'high',\n            description: 'Error rate exceeds 5% over 5 minutes'\n          },\n          responseTime: {\n            enabled: true,\n            threshold: 2.0, // 2 seconds\n            percentile: 95,\n            timeWindow: '5m',\n            severity: 'medium',\n            description: '95th percentile response time exceeds 2 seconds'\n          },\n          memoryUsage: {\n            enabled: true,\n            threshold: 0.85, // 85%\n            timeWindow: '5m',\n            severity: 'high',\n            description: 'Memory usage exceeds 85%'\n          },\n          cpuUsage: {\n            enabled: true,\n            threshold: 0.80, // 80%\n            timeWindow: '10m',\n            severity: 'medium',\n            description: 'CPU usage exceeds 80% for 10 minutes'\n          },\n          diskUsage: {\n            enabled: true,\n            threshold: 0.90, // 90%\n            timeWindow: '1m',\n            severity: 'critical',\n            description: 'Disk usage exceeds 90%'\n          },\n          healthCheck: {\n            enabled: true,\n            consecutiveFailures: 3,\n            severity: 'critical',\n            description: 'Health check failed 3 consecutive times'\n          }\n        },\n        escalation: {\n          enabled: true,\n          levels: [\n            {\n              severity: 'low',\n              channels: ['email'],\n              escalateAfter: '1h',\n              maxEscalations: 1\n            },\n            {\n              severity: 'medium',\n              channels: ['slack', 'email'],\n              escalateAfter: '30m',\n              maxEscalations: 2\n            },\n            {\n              severity: 'high',\n              channels: ['slack', 'email'],\n              escalateAfter: '15m',\n              maxEscalations: 3\n            },\n            {\n              severity: 'critical',\n              channels: ['pagerduty', 'slack', 'email'],\n              escalateAfter: '5m',\n              maxEscalations: 5\n            }\n          ]\n        },\n        suppression: {\n          enabled: true,\n          maxFrequency: {\n            window: '1h',\n            count: 5\n          },\n          maintenanceMode: false\n        }\n      },\n\n      // SLI/SLO configuration\n      sliSlo: {\n        enabled: true,\n        evaluationInterval: 60000, // 1 minute\n        retentionPeriod: 90 * 24 * 60 * 60 * 1000, // 90 days\n        alertThreshold: 0.1, // Alert when error budget < 10%\n        slis: {\n          availability: {\n            target: 0.999, // 99.9%\n            timeWindow: '30d'\n          },\n          latency: {\n            target: 0.95, // 95% under 500ms\n            threshold: 500,\n            timeWindow: '7d'\n          },\n          errorRate: {\n            target: 0.001, // <0.1%\n            timeWindow: '24h'\n          },\n          throughput: {\n            target: 100, // 100 RPS minimum\n            timeWindow: '1h'\n          }\n        },\n        errorBudget: {\n          burnRateAlerts: {\n            enabled: true,\n            thresholds: [\n              { timeWindow: '1h', burnRate: 14.4, severity: 'critical' }, // 2% budget in 1 hour\n              { timeWindow: '6h', burnRate: 6, severity: 'high' },       // 5% budget in 6 hours\n              { timeWindow: '1d', burnRate: 3, severity: 'medium' },     // 10% budget in 1 day\n              { timeWindow: '3d', burnRate: 1, severity: 'low' }         // 30% budget in 3 days\n            ]\n          }\n        }\n      },\n\n      // Health checks configuration\n      healthChecks: {\n        enabled: true,\n        globalInterval: 30000, // 30 seconds\n        timeout: 5000, // 5 seconds\n        retryAttempts: 3,\n        retryDelay: 1000,\n        autoRecovery: {\n          enabled: this.environment === 'production',\n          maxAttempts: 3,\n          backoffMultiplier: 2\n        },\n        checks: {\n          http: {\n            enabled: true,\n            endpoints: [\n              {\n                name: 'api_health',\n                url: 'http://localhost:3000/health',\n                timeout: 5000,\n                critical: true\n              }\n            ]\n          },\n          database: {\n            enabled: true,\n            connectionString: process.env.DATABASE_URL,\n            timeout: 10000,\n            critical: true\n          },\n          redis: {\n            enabled: true,\n            host: process.env.REDIS_HOST || 'localhost',\n            port: process.env.REDIS_PORT || 6379,\n            timeout: 5000,\n            critical: false\n          },\n          filesystem: {\n            enabled: true,\n            paths: ['./logs', './uploads', '/tmp'],\n            checkWrite: true,\n            checkRead: true,\n            critical: true\n          },\n          external: {\n            enabled: this.environment === 'production',\n            services: [\n              {\n                name: 'external_api',\n                url: process.env.EXTERNAL_API_URL,\n                timeout: 10000,\n                critical: false\n              }\n            ]\n          }\n        },\n        thresholds: {\n          memory: {\n            maxUsagePercent: 85,\n            maxHeapUsage: 1024 * 1024 * 1024 // 1GB\n          },\n          cpu: {\n            maxUsagePercent: 80,\n            samplingDuration: 5000\n          },\n          disk: {\n            maxUsagePercent: 85,\n            paths: ['/']  \n          }\n        }\n      },\n\n      // Dashboard configuration\n      dashboards: {\n        enabled: true,\n        grafana: {\n          enabled: this.environment === 'production',\n          url: process.env.GRAFANA_URL || 'http://localhost:3000',\n          apiKey: process.env.GRAFANA_API_KEY,\n          datasources: {\n            prometheus: 'prometheus',\n            elasticsearch: 'elasticsearch'\n          }\n        },\n        custom: {\n          enabled: true,\n          port: 3001,\n          refreshInterval: 30000,\n          panels: [\n            'system_overview',\n            'application_metrics',\n            'error_tracking',\n            'slo_status',\n            'alert_summary'\n          ]\n        }\n      },\n\n      // Security configuration\n      security: {\n        encryption: {\n          enabled: this.environment === 'production',\n          algorithm: 'aes-256-gcm',\n          keyFile: process.env.ENCRYPTION_KEY_FILE\n        },\n        authentication: {\n          enabled: this.environment === 'production',\n          apiKeys: process.env.MONITORING_API_KEYS?.split(',') || [],\n          tokenExpiry: '24h'\n        },\n        rateLimiting: {\n          enabled: true,\n          windowMs: 15 * 60 * 1000, // 15 minutes\n          maxRequests: 1000\n        }\n      }\n    };\n  }\n\n  getLogLevel() {\n    const envLevel = process.env.LOG_LEVEL;\n    if (envLevel) return envLevel;\n    \n    switch (this.environment) {\n      case 'production':\n        return 'info';\n      case 'staging':\n        return 'debug';\n      case 'development':\n      default:\n        return 'debug';\n    }\n  }\n\n  getSamplingRate() {\n    const envRate = parseFloat(process.env.TRACING_SAMPLING_RATE);\n    if (!isNaN(envRate)) return envRate;\n    \n    switch (this.environment) {\n      case 'production':\n        return 0.1; // 10%\n      case 'staging':\n        return 0.5; // 50%\n      case 'development':\n      default:\n        return 1.0; // 100%\n    }\n  }\n\n  // Get configuration for a specific component\n  getComponentConfig(component) {\n    return this.config[component] || {};\n  }\n\n  // Get global configuration\n  getGlobalConfig() {\n    return this.config.global;\n  }\n\n  // Validate configuration\n  validate() {\n    const errors = [];\n    const warnings = [];\n\n    // Check required environment variables for production\n    if (this.environment === 'production') {\n      const requiredEnvVars = [\n        'SERVICE_NAME',\n        'SERVICE_VERSION'\n      ];\n\n      for (const envVar of requiredEnvVars) {\n        if (!process.env[envVar]) {\n          errors.push(`Missing required environment variable: ${envVar}`);\n        }\n      }\n\n      // Check alerting configuration\n      if (this.config.alerting.enabled) {\n        const alertingChannels = this.config.alerting.channels;\n        \n        if (alertingChannels.email.enabled && !alertingChannels.email.to.length) {\n          warnings.push('Email alerting is enabled but no recipients configured');\n        }\n        \n        if (alertingChannels.slack.enabled && !alertingChannels.slack.webhookUrl) {\n          warnings.push('Slack alerting is enabled but no webhook URL configured');\n        }\n      }\n    }\n\n    // Check for conflicting configurations\n    if (this.config.tracing.samplingRate > 1 || this.config.tracing.samplingRate < 0) {\n      errors.push('Tracing sampling rate must be between 0 and 1');\n    }\n\n    return { errors, warnings, isValid: errors.length === 0 };\n  }\n\n  // Override configuration values\n  override(overrides) {\n    this.config = this.mergeDeep(this.config, overrides);\n  }\n\n  // Deep merge utility\n  mergeDeep(target, source) {\n    const result = { ...target };\n    \n    for (const key in source) {\n      if (source[key] && typeof source[key] === 'object' && !Array.isArray(source[key])) {\n        result[key] = this.mergeDeep(target[key] || {}, source[key]);\n      } else {\n        result[key] = source[key];\n      }\n    }\n    \n    return result;\n  }\n\n  // Export configuration as JSON\n  export() {\n    return JSON.stringify(this.config, null, 2);\n  }\n\n  // Load configuration from file\n  static fromFile(filePath) {\n    try {\n      const configData = require(path.resolve(filePath));\n      const config = new MonitoringConfig();\n      config.override(configData);\n      return config;\n    } catch (error) {\n      throw new Error(`Failed to load configuration from ${filePath}: ${error.message}`);\n    }\n  }\n\n  // Create configuration for specific environment\n  static forEnvironment(environment) {\n    return new MonitoringConfig(environment);\n  }\n}\n\nmodule.exports = MonitoringConfig;
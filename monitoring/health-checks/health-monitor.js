const EventEmitter = require('events');\nconst axios = require('axios');\nconst fs = require('fs').promises;\nconst path = require('path');\n\nclass HealthMonitor extends EventEmitter {\n  constructor(options = {}) {\n    super();\n    \n    this.config = {\n      checkInterval: options.checkInterval || 30000, // 30 seconds\n      timeout: options.timeout || 5000, // 5 seconds\n      retryAttempts: options.retryAttempts || 3,\n      retryDelay: options.retryDelay || 1000,\n      enableAutoRecovery: options.enableAutoRecovery || false,\n      alertOnFailure: options.alertOnFailure || true\n    };\n    \n    this.checks = new Map();\n    this.checkResults = new Map();\n    this.checkTimers = new Map();\n    this.isRunning = false;\n    \n    this.setupDefaultChecks();\n  }\n\n  setupDefaultChecks() {\n    // HTTP endpoint check\n    this.addCheck('http_endpoint', {\n      name: 'HTTP Endpoint Health',\n      type: 'http',\n      config: {\n        url: 'http://localhost:3000/health',\n        method: 'GET',\n        expectedStatus: 200,\n        timeout: 5000\n      },\n      interval: 30000,\n      critical: true\n    });\n\n    // Database connection check\n    this.addCheck('database', {\n      name: 'Database Connection',\n      type: 'database',\n      config: {\n        connectionString: process.env.DATABASE_URL,\n        query: 'SELECT 1 as health'\n      },\n      interval: 60000,\n      critical: true\n    });\n\n    // Redis connection check\n    this.addCheck('redis', {\n      name: 'Redis Connection',\n      type: 'redis',\n      config: {\n        host: process.env.REDIS_HOST || 'localhost',\n        port: process.env.REDIS_PORT || 6379,\n        password: process.env.REDIS_PASSWORD\n      },\n      interval: 30000,\n      critical: false\n    });\n\n    // File system check\n    this.addCheck('filesystem', {\n      name: 'File System Access',\n      type: 'filesystem',\n      config: {\n        paths: ['/tmp', './logs', './uploads'],\n        checkWrite: true,\n        checkRead: true\n      },\n      interval: 60000,\n      critical: true\n    });\n\n    // Memory usage check\n    this.addCheck('memory', {\n      name: 'Memory Usage',\n      type: 'memory',\n      config: {\n        maxUsagePercent: 85,\n        maxHeapUsage: 1024 * 1024 * 1024 // 1GB\n      },\n      interval: 30000,\n      critical: false\n    });\n\n    // CPU usage check\n    this.addCheck('cpu', {\n      name: 'CPU Usage',\n      type: 'cpu',\n      config: {\n        maxUsagePercent: 80,\n        samplingDuration: 5000\n      },\n      interval: 30000,\n      critical: false\n    });\n\n    // Disk usage check\n    this.addCheck('disk', {\n      name: 'Disk Usage',\n      type: 'disk',\n      config: {\n        paths: ['/'],\n        maxUsagePercent: 85\n      },\n      interval: 300000, // 5 minutes\n      critical: false\n    });\n\n    // External service dependency check\n    this.addCheck('external_api', {\n      name: 'External API Dependencies',\n      type: 'external',\n      config: {\n        endpoints: [\n          {\n            name: 'payment_gateway',\n            url: 'https://api.stripe.com/v1/charges',\n            headers: { 'Authorization': 'Bearer sk_test_...' },\n            timeout: 10000\n          }\n        ]\n      },\n      interval: 120000, // 2 minutes\n      critical: false\n    });\n  }\n\n  // Add a health check\n  addCheck(name, definition) {\n    const check = {\n      ...definition,\n      name: name,\n      id: name,\n      addedAt: new Date(),\n      enabled: definition.enabled !== false\n    };\n    \n    this.checks.set(name, check);\n    \n    // Initialize results\n    this.checkResults.set(name, {\n      status: 'unknown',\n      lastCheck: null,\n      lastSuccess: null,\n      lastFailure: null,\n      consecutiveFailures: 0,\n      totalChecks: 0,\n      totalFailures: 0,\n      averageResponseTime: 0,\n      history: []\n    });\n    \n    this.emit('checkAdded', { name, check });\n    \n    // Start monitoring if already running\n    if (this.isRunning && check.enabled) {\n      this.startCheckTimer(name);\n    }\n  }\n\n  // Remove a health check\n  removeCheck(name) {\n    if (this.checks.has(name)) {\n      this.stopCheckTimer(name);\n      this.checks.delete(name);\n      this.checkResults.delete(name);\n      this.emit('checkRemoved', { name });\n    }\n  }\n\n  // Enable/disable a check\n  toggleCheck(name, enabled) {\n    const check = this.checks.get(name);\n    if (check) {\n      check.enabled = enabled;\n      \n      if (enabled && this.isRunning) {\n        this.startCheckTimer(name);\n      } else {\n        this.stopCheckTimer(name);\n      }\n      \n      this.emit('checkToggled', { name, enabled });\n    }\n  }\n\n  // Start monitoring all checks\n  start() {\n    if (this.isRunning) return;\n    \n    this.isRunning = true;\n    \n    for (const [name, check] of this.checks) {\n      if (check.enabled) {\n        this.startCheckTimer(name);\n      }\n    }\n    \n    this.emit('monitoringStarted');\n    console.log('Health monitoring started');\n  }\n\n  // Stop monitoring all checks\n  stop() {\n    if (!this.isRunning) return;\n    \n    this.isRunning = false;\n    \n    for (const name of this.checks.keys()) {\n      this.stopCheckTimer(name);\n    }\n    \n    this.emit('monitoringStopped');\n    console.log('Health monitoring stopped');\n  }\n\n  // Start timer for a specific check\n  startCheckTimer(name) {\n    const check = this.checks.get(name);\n    if (!check) return;\n    \n    // Clear existing timer\n    this.stopCheckTimer(name);\n    \n    // Run initial check\n    this.runCheck(name);\n    \n    // Set up interval\n    const timer = setInterval(() => {\n      this.runCheck(name);\n    }, check.interval);\n    \n    this.checkTimers.set(name, timer);\n  }\n\n  // Stop timer for a specific check\n  stopCheckTimer(name) {\n    const timer = this.checkTimers.get(name);\n    if (timer) {\n      clearInterval(timer);\n      this.checkTimers.delete(name);\n    }\n  }\n\n  // Run a specific health check\n  async runCheck(name) {\n    const check = this.checks.get(name);\n    const results = this.checkResults.get(name);\n    \n    if (!check || !results) return;\n    \n    const startTime = Date.now();\n    let attempt = 0;\n    let lastError;\n    \n    while (attempt < this.config.retryAttempts) {\n      try {\n        const result = await this.executeCheck(check);\n        \n        // Success\n        const responseTime = Date.now() - startTime;\n        this.updateCheckResults(name, true, responseTime, result);\n        return result;\n        \n      } catch (error) {\n        lastError = error;\n        attempt++;\n        \n        if (attempt < this.config.retryAttempts) {\n          await this.delay(this.config.retryDelay);\n        }\n      }\n    }\n    \n    // All attempts failed\n    const responseTime = Date.now() - startTime;\n    this.updateCheckResults(name, false, responseTime, null, lastError);\n    return null;\n  }\n\n  // Execute a specific type of check\n  async executeCheck(check) {\n    switch (check.type) {\n      case 'http':\n        return this.executeHttpCheck(check.config);\n      case 'database':\n        return this.executeDatabaseCheck(check.config);\n      case 'redis':\n        return this.executeRedisCheck(check.config);\n      case 'filesystem':\n        return this.executeFilesystemCheck(check.config);\n      case 'memory':\n        return this.executeMemoryCheck(check.config);\n      case 'cpu':\n        return this.executeCpuCheck(check.config);\n      case 'disk':\n        return this.executeDiskCheck(check.config);\n      case 'external':\n        return this.executeExternalCheck(check.config);\n      case 'custom':\n        return this.executeCustomCheck(check.config);\n      default:\n        throw new Error(`Unknown check type: ${check.type}`);\n    }\n  }\n\n  // HTTP check implementation\n  async executeHttpCheck(config) {\n    const response = await axios({\n      method: config.method || 'GET',\n      url: config.url,\n      headers: config.headers || {},\n      timeout: config.timeout || this.config.timeout,\n      validateStatus: (status) => {\n        if (config.expectedStatus) {\n          return status === config.expectedStatus;\n        }\n        return status >= 200 && status < 300;\n      }\n    });\n    \n    return {\n      status: response.status,\n      statusText: response.statusText,\n      responseTime: response.config.metadata?.endTime - response.config.metadata?.startTime,\n      headers: response.headers\n    };\n  }\n\n  // Database check implementation\n  async executeDatabaseCheck(config) {\n    // This is a placeholder - implement based on your database driver\n    // Example for PostgreSQL with pg library:\n    /*\n    const { Client } = require('pg');\n    const client = new Client(config.connectionString);\n    await client.connect();\n    const result = await client.query(config.query || 'SELECT 1');\n    await client.end();\n    return { rows: result.rows.length };\n    */\n    \n    return { status: 'connected', query: config.query };\n  }\n\n  // Redis check implementation\n  async executeRedisCheck(config) {\n    // This is a placeholder - implement based on your Redis client\n    // Example with ioredis:\n    /*\n    const Redis = require('ioredis');\n    const redis = new Redis(config);\n    await redis.ping();\n    redis.disconnect();\n    return { status: 'connected' };\n    */\n    \n    return { status: 'connected' };\n  }\n\n  // Filesystem check implementation\n  async executeFilesystemCheck(config) {\n    const results = {};\n    \n    for (const testPath of config.paths) {\n      try {\n        // Check if path exists and is accessible\n        await fs.access(testPath);\n        results[testPath] = { accessible: true };\n        \n        if (config.checkRead) {\n          await fs.readdir(testPath);\n          results[testPath].readable = true;\n        }\n        \n        if (config.checkWrite) {\n          const testFile = path.join(testPath, '.health-check-' + Date.now());\n          await fs.writeFile(testFile, 'health check');\n          await fs.unlink(testFile);\n          results[testPath].writable = true;\n        }\n        \n      } catch (error) {\n        results[testPath] = { \n          accessible: false, \n          error: error.message \n        };\n      }\n    }\n    \n    return results;\n  }\n\n  // Memory check implementation\n  executeMemoryCheck(config) {\n    const usage = process.memoryUsage();\n    const totalMemory = require('os').totalmem();\n    const freeMemory = require('os').freemem();\n    const usedMemory = totalMemory - freeMemory;\n    const usagePercent = (usedMemory / totalMemory) * 100;\n    \n    const result = {\n      system: {\n        total: totalMemory,\n        used: usedMemory,\n        free: freeMemory,\n        usagePercent\n      },\n      process: {\n        rss: usage.rss,\n        heapTotal: usage.heapTotal,\n        heapUsed: usage.heapUsed,\n        external: usage.external\n      }\n    };\n    \n    // Check thresholds\n    if (config.maxUsagePercent && usagePercent > config.maxUsagePercent) {\n      throw new Error(`Memory usage ${usagePercent.toFixed(1)}% exceeds threshold ${config.maxUsagePercent}%`);\n    }\n    \n    if (config.maxHeapUsage && usage.heapUsed > config.maxHeapUsage) {\n      throw new Error(`Heap usage ${usage.heapUsed} exceeds threshold ${config.maxHeapUsage}`);\n    }\n    \n    return result;\n  }\n\n  // CPU check implementation\n  async executeCpuCheck(config) {\n    const startUsage = process.cpuUsage();\n    const startTime = Date.now();\n    \n    await this.delay(config.samplingDuration || 1000);\n    \n    const endUsage = process.cpuUsage(startUsage);\n    const endTime = Date.now();\n    \n    const cpuPercent = ((endUsage.user + endUsage.system) / 1000) / (endTime - startTime) * 100;\n    \n    const result = {\n      usage: endUsage,\n      percent: cpuPercent,\n      samplingDuration: endTime - startTime\n    };\n    \n    if (config.maxUsagePercent && cpuPercent > config.maxUsagePercent) {\n      throw new Error(`CPU usage ${cpuPercent.toFixed(1)}% exceeds threshold ${config.maxUsagePercent}%`);\n    }\n    \n    return result;\n  }\n\n  // Disk check implementation\n  async executeDiskCheck(config) {\n    const results = {};\n    \n    for (const diskPath of config.paths) {\n      try {\n        const stats = await fs.statvfs ? fs.statvfs(diskPath) : null;\n        \n        if (stats) {\n          const total = stats.blocks * stats.frsize;\n          const free = stats.bavail * stats.frsize;\n          const used = total - free;\n          const usagePercent = (used / total) * 100;\n          \n          results[diskPath] = {\n            total,\n            used,\n            free,\n            usagePercent\n          };\n          \n          if (config.maxUsagePercent && usagePercent > config.maxUsagePercent) {\n            throw new Error(`Disk usage ${usagePercent.toFixed(1)}% exceeds threshold ${config.maxUsagePercent}%`);\n          }\n        } else {\n          // Fallback for systems without statvfs\n          results[diskPath] = { status: 'check_not_supported' };\n        }\n        \n      } catch (error) {\n        results[diskPath] = { error: error.message };\n      }\n    }\n    \n    return results;\n  }\n\n  // External service check implementation\n  async executeExternalCheck(config) {\n    const results = {};\n    \n    for (const endpoint of config.endpoints) {\n      try {\n        const response = await axios({\n          method: endpoint.method || 'GET',\n          url: endpoint.url,\n          headers: endpoint.headers || {},\n          timeout: endpoint.timeout || this.config.timeout\n        });\n        \n        results[endpoint.name] = {\n          status: response.status,\n          responseTime: response.config.metadata?.endTime - response.config.metadata?.startTime\n        };\n        \n      } catch (error) {\n        results[endpoint.name] = {\n          error: error.message,\n          status: error.response?.status\n        };\n      }\n    }\n    \n    return results;\n  }\n\n  // Custom check implementation\n  async executeCustomCheck(config) {\n    if (typeof config.checkFunction === 'function') {\n      return await config.checkFunction();\n    }\n    throw new Error('Custom check function not provided');\n  }\n\n  // Update check results\n  updateCheckResults(name, success, responseTime, result, error) {\n    const results = this.checkResults.get(name);\n    const check = this.checks.get(name);\n    \n    if (!results || !check) return;\n    \n    const now = new Date();\n    \n    results.lastCheck = now;\n    results.totalChecks++;\n    \n    if (success) {\n      results.status = 'healthy';\n      results.lastSuccess = now;\n      results.consecutiveFailures = 0;\n      results.lastResult = result;\n      results.lastError = null;\n    } else {\n      results.status = 'unhealthy';\n      results.lastFailure = now;\n      results.consecutiveFailures++;\n      results.totalFailures++;\n      results.lastError = error?.message || 'Unknown error';\n      results.lastResult = null;\n    }\n    \n    // Update average response time\n    results.averageResponseTime = (\n      (results.averageResponseTime * (results.totalChecks - 1) + responseTime) / \n      results.totalChecks\n    );\n    \n    // Add to history (keep last 100 results)\n    results.history.push({\n      timestamp: now,\n      success,\n      responseTime,\n      error: error?.message\n    });\n    \n    if (results.history.length > 100) {\n      results.history = results.history.slice(-100);\n    }\n    \n    // Emit events\n    this.emit('checkCompleted', { name, check, results, success, result, error });\n    \n    if (!success) {\n      this.emit('checkFailed', { name, check, results, error });\n      \n      if (check.critical && this.config.alertOnFailure) {\n        this.emit('criticalCheckFailed', { name, check, results, error });\n      }\n      \n      // Auto-recovery attempt\n      if (this.config.enableAutoRecovery && check.recovery) {\n        this.attemptRecovery(name, check);\n      }\n    } else if (results.consecutiveFailures === 0 && results.totalFailures > 0) {\n      this.emit('checkRecovered', { name, check, results });\n    }\n  }\n\n  // Attempt automatic recovery\n  async attemptRecovery(name, check) {\n    if (!check.recovery || typeof check.recovery.action !== 'function') return;\n    \n    try {\n      console.log(`Attempting auto-recovery for check: ${name}`);\n      await check.recovery.action();\n      this.emit('recoveryAttempted', { name, check, success: true });\n    } catch (error) {\n      console.error(`Auto-recovery failed for check ${name}:`, error);\n      this.emit('recoveryAttempted', { name, check, success: false, error });\n    }\n  }\n\n  // Get overall health status\n  getOverallHealth() {\n    const checks = Array.from(this.checkResults.values());\n    const criticalChecks = Array.from(this.checks.values()).filter(c => c.critical);\n    \n    const totalChecks = checks.length;\n    const healthyChecks = checks.filter(r => r.status === 'healthy').length;\n    const unhealthyChecks = checks.filter(r => r.status === 'unhealthy').length;\n    const unknownChecks = checks.filter(r => r.status === 'unknown').length;\n    \n    const criticalUnhealthy = criticalChecks.some(check => {\n      const result = this.checkResults.get(check.id);\n      return result && result.status === 'unhealthy';\n    });\n    \n    let status;\n    if (criticalUnhealthy) {\n      status = 'critical';\n    } else if (unhealthyChecks > 0) {\n      status = 'degraded';\n    } else if (unknownChecks > 0) {\n      status = 'unknown';\n    } else {\n      status = 'healthy';\n    }\n    \n    return {\n      status,\n      timestamp: new Date(),\n      checks: {\n        total: totalChecks,\n        healthy: healthyChecks,\n        unhealthy: unhealthyChecks,\n        unknown: unknownChecks\n      },\n      uptime: process.uptime()\n    };\n  }\n\n  // Get detailed health report\n  getDetailedHealthReport() {\n    const overall = this.getOverallHealth();\n    const checkDetails = {};\n    \n    for (const [name, check] of this.checks) {\n      const results = this.checkResults.get(name);\n      checkDetails[name] = {\n        check: {\n          name: check.name,\n          type: check.type,\n          critical: check.critical,\n          enabled: check.enabled,\n          interval: check.interval\n        },\n        results: results ? {\n          status: results.status,\n          lastCheck: results.lastCheck,\n          lastSuccess: results.lastSuccess,\n          lastFailure: results.lastFailure,\n          consecutiveFailures: results.consecutiveFailures,\n          totalChecks: results.totalChecks,\n          totalFailures: results.totalFailures,\n          averageResponseTime: results.averageResponseTime,\n          lastError: results.lastError,\n          successRate: results.totalChecks > 0 ? \n            ((results.totalChecks - results.totalFailures) / results.totalChecks * 100).toFixed(2) + '%' : '0%'\n        } : null\n      };\n    }\n    \n    return {\n      overall,\n      checks: checkDetails,\n      monitoring: {\n        isRunning: this.isRunning,\n        config: this.config\n      }\n    };\n  }\n\n  // Express middleware for health endpoint\n  middleware() {\n    return (req, res) => {\n      const detailed = req.query.detailed === 'true';\n      const healthData = detailed ? this.getDetailedHealthReport() : this.getOverallHealth();\n      \n      const statusCode = healthData.status === 'healthy' || healthData.overall?.status === 'healthy' ? 200 : 503;\n      \n      res.status(statusCode).json(healthData);\n    };\n  }\n\n  // Utility method\n  delay(ms) {\n    return new Promise(resolve => setTimeout(resolve, ms));\n  }\n\n  // Cleanup\n  cleanup() {\n    this.stop();\n    this.removeAllListeners();\n  }\n}\n\nmodule.exports = HealthMonitor;
const EventEmitter = require('events');\n\nclass SLISLOTracker extends EventEmitter {\n  constructor(options = {}) {\n    super();\n    \n    this.config = {\n      evaluationInterval: options.evaluationInterval || 60000, // 1 minute\n      retentionPeriod: options.retentionPeriod || 30 * 24 * 60 * 60 * 1000, // 30 days\n      alertThreshold: options.alertThreshold || 0.1 // Alert when error budget < 10%\n    };\n    \n    this.slis = new Map();\n    this.slos = new Map();\n    this.measurements = new Map();\n    this.errorBudgets = new Map();\n    \n    this.setupDefaultSLIs();\n    this.setupDefaultSLOs();\n    this.startEvaluationTimer();\n  }\n\n  setupDefaultSLIs() {\n    // Availability SLI\n    this.defineSLI('availability', {\n      name: 'Service Availability',\n      description: 'Percentage of successful requests',\n      type: 'availability',\n      measurement: (data) => {\n        const total = data.successfulRequests + data.failedRequests;\n        return total > 0 ? data.successfulRequests / total : 1;\n      },\n      unit: 'percentage'\n    });\n\n    // Latency SLI\n    this.defineSLI('latency', {\n      name: 'Request Latency',\n      description: 'Percentage of requests served within threshold',\n      type: 'latency',\n      measurement: (data) => {\n        return data.requestsWithinThreshold / data.totalRequests;\n      },\n      unit: 'percentage',\n      threshold: 500 // 500ms\n    });\n\n    // Throughput SLI\n    this.defineSLI('throughput', {\n      name: 'Request Throughput',\n      description: 'Requests per second',\n      type: 'throughput',\n      measurement: (data) => {\n        return data.totalRequests / data.timeWindowSeconds;\n      },\n      unit: 'requests_per_second'\n    });\n\n    // Error Rate SLI\n    this.defineSLI('error_rate', {\n      name: 'Error Rate',\n      description: 'Percentage of requests that result in errors',\n      type: 'error_rate',\n      measurement: (data) => {\n        const total = data.successfulRequests + data.failedRequests;\n        return total > 0 ? data.failedRequests / total : 0;\n      },\n      unit: 'percentage'\n    });\n\n    // Custom business SLIs\n    this.defineSLI('user_satisfaction', {\n      name: 'User Satisfaction',\n      description: 'Percentage of user actions completed successfully',\n      type: 'business',\n      measurement: (data) => {\n        return data.successfulUserActions / data.totalUserActions;\n      },\n      unit: 'percentage'\n    });\n\n    this.defineSLI('data_freshness', {\n      name: 'Data Freshness',\n      description: 'Percentage of data queries returning fresh data',\n      type: 'business',\n      measurement: (data) => {\n        return data.freshDataQueries / data.totalDataQueries;\n      },\n      unit: 'percentage'\n    });\n  }\n\n  setupDefaultSLOs() {\n    // Availability SLO - 99.9% uptime\n    this.defineSLO('availability_slo', {\n      name: 'Service Availability SLO',\n      sliName: 'availability',\n      target: 0.999, // 99.9%\n      timeWindow: '30d',\n      description: '99.9% of requests should be successful over 30 days'\n    });\n\n    // Latency SLO - 95% of requests under 500ms\n    this.defineSLO('latency_slo', {\n      name: 'Response Time SLO',\n      sliName: 'latency',\n      target: 0.95, // 95%\n      timeWindow: '7d',\n      description: '95% of requests should complete within 500ms over 7 days'\n    });\n\n    // Error Rate SLO - Less than 0.1% error rate\n    this.defineSLO('error_rate_slo', {\n      name: 'Error Rate SLO',\n      sliName: 'error_rate',\n      target: 0.001, // 0.1%\n      timeWindow: '24h',\n      description: 'Error rate should be below 0.1% over 24 hours',\n      comparison: 'less_than'\n    });\n\n    // Throughput SLO - Minimum 100 RPS\n    this.defineSLO('throughput_slo', {\n      name: 'Throughput SLO',\n      sliName: 'throughput',\n      target: 100, // 100 RPS\n      timeWindow: '1h',\n      description: 'Service should handle at least 100 requests per second',\n      comparison: 'greater_than'\n    });\n\n    // User Satisfaction SLO\n    this.defineSLO('user_satisfaction_slo', {\n      name: 'User Satisfaction SLO',\n      sliName: 'user_satisfaction',\n      target: 0.98, // 98%\n      timeWindow: '7d',\n      description: '98% of user actions should complete successfully'\n    });\n  }\n\n  defineSLI(name, definition) {\n    this.slis.set(name, {\n      ...definition,\n      name: name,\n      createdAt: new Date(),\n      lastUpdated: new Date()\n    });\n    \n    // Initialize measurements storage\n    this.measurements.set(name, []);\n    \n    this.emit('sliDefined', { name, definition });\n  }\n\n  defineSLO(name, definition) {\n    const slo = {\n      ...definition,\n      name: name,\n      createdAt: new Date(),\n      lastUpdated: new Date(),\n      comparison: definition.comparison || 'greater_than_or_equal'\n    };\n    \n    this.slos.set(name, slo);\n    \n    // Calculate initial error budget\n    this.calculateErrorBudget(name);\n    \n    this.emit('sloDefined', { name, definition: slo });\n  }\n\n  // Record SLI measurement\n  recordSLI(sliName, data, timestamp = new Date()) {\n    const sli = this.slis.get(sliName);\n    if (!sli) {\n      throw new Error(`SLI '${sliName}' not found`);\n    }\n\n    const value = sli.measurement(data);\n    const measurement = {\n      timestamp,\n      value,\n      rawData: data\n    };\n\n    const measurements = this.measurements.get(sliName);\n    measurements.push(measurement);\n\n    // Clean old measurements\n    this.cleanOldMeasurements(sliName);\n\n    // Update SLI\n    sli.lastUpdated = timestamp;\n    sli.lastValue = value;\n\n    this.emit('sliMeasured', { sliName, measurement });\n\n    // Evaluate related SLOs\n    this.evaluateRelatedSLOs(sliName);\n\n    return measurement;\n  }\n\n  // Get SLI current value\n  getSLIValue(sliName, timeWindow = '1h') {\n    const measurements = this.getMeasurements(sliName, timeWindow);\n    if (measurements.length === 0) return null;\n\n    const sli = this.slis.get(sliName);\n    if (sli.type === 'latency' || sli.type === 'availability') {\n      // Average for percentage-based SLIs\n      return measurements.reduce((sum, m) => sum + m.value, 0) / measurements.length;\n    } else {\n      // Latest value for absolute SLIs\n      return measurements[measurements.length - 1].value;\n    }\n  }\n\n  // Get measurements within time window\n  getMeasurements(sliName, timeWindow) {\n    const measurements = this.measurements.get(sliName) || [];\n    const cutoff = this.getTimeWindowCutoff(timeWindow);\n    \n    return measurements.filter(m => m.timestamp >= cutoff);\n  }\n\n  // Evaluate SLO compliance\n  evaluateSLO(sloName) {\n    const slo = this.slos.get(sloName);\n    if (!slo) {\n      throw new Error(`SLO '${sloName}' not found`);\n    }\n\n    const sliValue = this.getSLIValue(slo.sliName, slo.timeWindow);\n    if (sliValue === null) {\n      return {\n        status: 'insufficient_data',\n        compliance: null,\n        errorBudgetRemaining: null\n      };\n    }\n\n    let compliance;\n    switch (slo.comparison) {\n      case 'greater_than_or_equal':\n        compliance = sliValue >= slo.target;\n        break;\n      case 'less_than_or_equal':\n      case 'less_than':\n        compliance = sliValue <= slo.target;\n        break;\n      case 'greater_than':\n        compliance = sliValue > slo.target;\n        break;\n      default:\n        compliance = sliValue >= slo.target;\n    }\n\n    // Calculate error budget\n    const errorBudget = this.calculateErrorBudget(sloName);\n\n    const evaluation = {\n      status: compliance ? 'compliant' : 'violated',\n      compliance,\n      currentValue: sliValue,\n      target: slo.target,\n      errorBudget,\n      evaluatedAt: new Date()\n    };\n\n    // Check for alerts\n    if (errorBudget && errorBudget.remaining < this.config.alertThreshold) {\n      this.emit('errorBudgetAlert', {\n        sloName,\n        errorBudget,\n        evaluation\n      });\n    }\n\n    if (!compliance) {\n      this.emit('sloViolation', {\n        sloName,\n        slo,\n        evaluation\n      });\n    }\n\n    return evaluation;\n  }\n\n  // Calculate error budget\n  calculateErrorBudget(sloName) {\n    const slo = this.slos.get(sloName);\n    if (!slo) return null;\n\n    const timeWindowMs = this.parseTimeWindow(slo.timeWindow);\n    const measurements = this.getMeasurements(slo.sliName, slo.timeWindow);\n    \n    if (measurements.length === 0) {\n      return {\n        total: 1,\n        consumed: 0,\n        remaining: 1,\n        remainingPercentage: 100\n      };\n    }\n\n    let errorBudgetConsumed;\n    \n    if (slo.comparison === 'less_than' || slo.comparison === 'less_than_or_equal') {\n      // For error rate SLOs\n      const avgValue = measurements.reduce((sum, m) => sum + m.value, 0) / measurements.length;\n      errorBudgetConsumed = Math.max(0, avgValue / slo.target);\n    } else {\n      // For availability/latency SLOs\n      const avgValue = measurements.reduce((sum, m) => sum + m.value, 0) / measurements.length;\n      const allowedFailureRate = 1 - slo.target;\n      const actualFailureRate = 1 - avgValue;\n      errorBudgetConsumed = actualFailureRate / allowedFailureRate;\n    }\n\n    const errorBudget = {\n      total: 1,\n      consumed: Math.min(1, errorBudgetConsumed),\n      remaining: Math.max(0, 1 - errorBudgetConsumed),\n      remainingPercentage: Math.max(0, (1 - errorBudgetConsumed) * 100),\n      timeWindow: slo.timeWindow,\n      calculatedAt: new Date()\n    };\n\n    this.errorBudgets.set(sloName, errorBudget);\n    return errorBudget;\n  }\n\n  // Evaluate all SLOs related to an SLI\n  evaluateRelatedSLOs(sliName) {\n    for (const [sloName, slo] of this.slos) {\n      if (slo.sliName === sliName) {\n        this.evaluateSLO(sloName);\n      }\n    }\n  }\n\n  // Start automatic evaluation timer\n  startEvaluationTimer() {\n    this.evaluationTimer = setInterval(() => {\n      this.evaluateAllSLOs();\n    }, this.config.evaluationInterval);\n  }\n\n  // Stop evaluation timer\n  stopEvaluationTimer() {\n    if (this.evaluationTimer) {\n      clearInterval(this.evaluationTimer);\n      this.evaluationTimer = null;\n    }\n  }\n\n  // Evaluate all SLOs\n  evaluateAllSLOs() {\n    const results = {};\n    for (const sloName of this.slos.keys()) {\n      results[sloName] = this.evaluateSLO(sloName);\n    }\n    \n    this.emit('allSLOsEvaluated', results);\n    return results;\n  }\n\n  // Get SLO status\n  getSLOStatus(sloName) {\n    const slo = this.slos.get(sloName);\n    if (!slo) return null;\n\n    const evaluation = this.evaluateSLO(sloName);\n    const errorBudget = this.errorBudgets.get(sloName);\n\n    return {\n      slo,\n      evaluation,\n      errorBudget,\n      lastEvaluated: new Date()\n    };\n  }\n\n  // Get all SLO statuses\n  getAllSLOStatuses() {\n    const statuses = {};\n    for (const sloName of this.slos.keys()) {\n      statuses[sloName] = this.getSLOStatus(sloName);\n    }\n    return statuses;\n  }\n\n  // Get SLI history\n  getSLIHistory(sliName, timeWindow = '24h') {\n    return this.getMeasurements(sliName, timeWindow);\n  }\n\n  // Get SLO compliance history\n  getSLOComplianceHistory(sloName, timeWindow = '7d') {\n    const slo = this.slos.get(sloName);\n    if (!slo) return [];\n\n    const measurements = this.getMeasurements(slo.sliName, timeWindow);\n    \n    return measurements.map(measurement => {\n      let compliance;\n      switch (slo.comparison) {\n        case 'greater_than_or_equal':\n          compliance = measurement.value >= slo.target;\n          break;\n        case 'less_than_or_equal':\n        case 'less_than':\n          compliance = measurement.value <= slo.target;\n          break;\n        case 'greater_than':\n          compliance = measurement.value > slo.target;\n          break;\n        default:\n          compliance = measurement.value >= slo.target;\n      }\n      \n      return {\n        timestamp: measurement.timestamp,\n        value: measurement.value,\n        target: slo.target,\n        compliance\n      };\n    });\n  }\n\n  // Utility methods\n  parseTimeWindow(timeWindow) {\n    const match = timeWindow.match(/(\\d+)([dhms])/i);\n    if (!match) throw new Error(`Invalid time window: ${timeWindow}`);\n    \n    const value = parseInt(match[1]);\n    const unit = match[2].toLowerCase();\n    \n    const multipliers = {\n      's': 1000,\n      'm': 60 * 1000,\n      'h': 60 * 60 * 1000,\n      'd': 24 * 60 * 60 * 1000\n    };\n    \n    return value * multipliers[unit];\n  }\n\n  getTimeWindowCutoff(timeWindow) {\n    const windowMs = this.parseTimeWindow(timeWindow);\n    return new Date(Date.now() - windowMs);\n  }\n\n  cleanOldMeasurements(sliName) {\n    const measurements = this.measurements.get(sliName);\n    const cutoff = new Date(Date.now() - this.config.retentionPeriod);\n    \n    const filtered = measurements.filter(m => m.timestamp >= cutoff);\n    this.measurements.set(sliName, filtered);\n  }\n\n  // Export/Import configuration\n  exportConfiguration() {\n    return {\n      slis: Object.fromEntries(this.slis),\n      slos: Object.fromEntries(this.slos),\n      config: this.config\n    };\n  }\n\n  importConfiguration(config) {\n    if (config.slis) {\n      for (const [name, sli] of Object.entries(config.slis)) {\n        this.defineSLI(name, sli);\n      }\n    }\n    \n    if (config.slos) {\n      for (const [name, slo] of Object.entries(config.slos)) {\n        this.defineSLO(name, slo);\n      }\n    }\n    \n    if (config.config) {\n      this.config = { ...this.config, ...config.config };\n    }\n  }\n\n  // Generate SLO report\n  generateSLOReport(timeWindow = '30d') {\n    const report = {\n      generatedAt: new Date(),\n      timeWindow,\n      summary: {\n        totalSLOs: this.slos.size,\n        compliant: 0,\n        violated: 0,\n        insufficientData: 0\n      },\n      slos: {}\n    };\n\n    for (const [sloName, slo] of this.slos) {\n      const evaluation = this.evaluateSLO(sloName);\n      const errorBudget = this.errorBudgets.get(sloName);\n      const history = this.getSLOComplianceHistory(sloName, timeWindow);\n      \n      report.slos[sloName] = {\n        slo,\n        evaluation,\n        errorBudget,\n        complianceRate: history.length > 0 ? \n          history.filter(h => h.compliance).length / history.length : null,\n        violationCount: history.filter(h => !h.compliance).length,\n        measurementCount: history.length\n      };\n      \n      // Update summary\n      switch (evaluation.status) {\n        case 'compliant':\n          report.summary.compliant++;\n          break;\n        case 'violated':\n          report.summary.violated++;\n          break;\n        case 'insufficient_data':\n          report.summary.insufficientData++;\n          break;\n      }\n    }\n    \n    return report;\n  }\n\n  // Cleanup resources\n  cleanup() {\n    this.stopEvaluationTimer();\n    this.removeAllListeners();\n  }\n}\n\nmodule.exports = SLISLOTracker;
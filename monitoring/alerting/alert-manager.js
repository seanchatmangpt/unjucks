const EventEmitter = require('events');\nconst nodemailer = require('nodemailer');\nconst axios = require('axios');\n\nclass AlertManager extends EventEmitter {\n  constructor(options = {}) {\n    super();\n    \n    this.config = {\n      email: options.email || {},\n      slack: options.slack || {},\n      webhook: options.webhook || {},\n      pagerduty: options.pagerduty || {},\n      escalationRules: options.escalationRules || this.getDefaultEscalationRules(),\n      suppressionRules: options.suppressionRules || [],\n      enabledChannels: options.enabledChannels || ['console']\n    };\n    \n    this.activeAlerts = new Map();\n    this.suppressedAlerts = new Set();\n    this.alertHistory = [];\n    \n    this.setupEmailTransporter();\n    this.setupEventHandlers();\n  }\n\n  getDefaultEscalationRules() {\n    return [\n      {\n        severity: 'critical',\n        channels: ['pagerduty', 'slack', 'email'],\n        escalateAfter: 5 * 60 * 1000, // 5 minutes\n        maxEscalations: 3\n      },\n      {\n        severity: 'high',\n        channels: ['slack', 'email'],\n        escalateAfter: 15 * 60 * 1000, // 15 minutes\n        maxEscalations: 2\n      },\n      {\n        severity: 'medium',\n        channels: ['slack'],\n        escalateAfter: 30 * 60 * 1000, // 30 minutes\n        maxEscalations: 1\n      },\n      {\n        severity: 'low',\n        channels: ['email'],\n        escalateAfter: 60 * 60 * 1000, // 1 hour\n        maxEscalations: 1\n      }\n    ];\n  }\n\n  setupEmailTransporter() {\n    if (this.config.email.smtp) {\n      this.emailTransporter = nodemailer.createTransporter(this.config.email.smtp);\n    }\n  }\n\n  setupEventHandlers() {\n    this.on('alert', this.handleAlert.bind(this));\n    this.on('alertResolved', this.handleAlertResolved.bind(this));\n  }\n\n  // Main alert handling method\n  async handleAlert(alert) {\n    try {\n      // Check if alert should be suppressed\n      if (this.shouldSuppressAlert(alert)) {\n        this.suppressedAlerts.add(alert.id);\n        return;\n      }\n\n      // Check if this is a new alert or an update\n      const existingAlert = this.activeAlerts.get(alert.id);\n      \n      if (existingAlert) {\n        // Update existing alert\n        this.updateAlert(alert);\n      } else {\n        // New alert\n        this.createAlert(alert);\n      }\n\n      // Send notifications based on severity and escalation rules\n      await this.sendNotifications(alert);\n\n      // Schedule escalation if needed\n      this.scheduleEscalation(alert);\n\n      // Add to history\n      this.alertHistory.push({\n        ...alert,\n        timestamp: this.getDeterministicDate(),\n        action: 'created'\n      });\n\n    } catch (error) {\n      console.error('Error handling alert:', error);\n      this.emit('alertError', { alert, error });\n    }\n  }\n\n  // Create a new alert\n  createAlert(alert) {\n    const alertData = {\n      ...alert,\n      id: alert.id || this.generateAlertId(),\n      createdAt: this.getDeterministicDate(),\n      updatedAt: this.getDeterministicDate(),\n      status: 'active',\n      escalationLevel: 0,\n      notificationsSent: [],\n      escalationTimer: null\n    };\n\n    this.activeAlerts.set(alertData.id, alertData);\n    return alertData;\n  }\n\n  // Update an existing alert\n  updateAlert(alert) {\n    const existing = this.activeAlerts.get(alert.id);\n    if (existing) {\n      const updated = {\n        ...existing,\n        ...alert,\n        updatedAt: this.getDeterministicDate()\n      };\n      this.activeAlerts.set(alert.id, updated);\n      return updated;\n    }\n    return null;\n  }\n\n  // Resolve an alert\n  resolveAlert(alertId, resolvedBy = 'system') {\n    const alert = this.activeAlerts.get(alertId);\n    if (alert) {\n      alert.status = 'resolved';\n      alert.resolvedAt = this.getDeterministicDate();\n      alert.resolvedBy = resolvedBy;\n      \n      // Clear escalation timer\n      if (alert.escalationTimer) {\n        clearTimeout(alert.escalationTimer);\n      }\n      \n      this.activeAlerts.delete(alertId);\n      this.emit('alertResolved', alert);\n      \n      // Add to history\n      this.alertHistory.push({\n        ...alert,\n        timestamp: this.getDeterministicDate(),\n        action: 'resolved'\n      });\n      \n      return alert;\n    }\n    return null;\n  }\n\n  // Handle alert resolution\n  async handleAlertResolved(alert) {\n    await this.sendResolutionNotifications(alert);\n  }\n\n  // Check if alert should be suppressed\n  shouldSuppressAlert(alert) {\n    return this.config.suppressionRules.some(rule => {\n      if (rule.alertName && rule.alertName !== alert.name) return false;\n      if (rule.severity && rule.severity !== alert.severity) return false;\n      if (rule.source && rule.source !== alert.source) return false;\n      if (rule.tags && !rule.tags.every(tag => alert.tags?.includes(tag))) return false;\n      \n      // Check time-based suppression\n      if (rule.suppressUntil && this.getDeterministicDate() < new Date(rule.suppressUntil)) return true;\n      \n      // Check frequency-based suppression\n      if (rule.maxFrequency) {\n        const recentAlerts = this.alertHistory.filter(h => \n          h.name === alert.name && \n          this.getDeterministicDate() - h.timestamp < rule.maxFrequency.window\n        );\n        return recentAlerts.length >= rule.maxFrequency.count;\n      }\n      \n      return false;\n    });\n  }\n\n  // Send notifications based on escalation rules\n  async sendNotifications(alert) {\n    const rule = this.config.escalationRules.find(r => r.severity === alert.severity);\n    if (!rule) return;\n\n    const notifications = [];\n    \n    for (const channel of rule.channels) {\n      if (this.config.enabledChannels.includes(channel)) {\n        try {\n          await this.sendNotification(channel, alert);\n          notifications.push({ channel, status: 'sent', timestamp: this.getDeterministicDate() });\n        } catch (error) {\n          notifications.push({ channel, status: 'failed', error: error.message, timestamp: this.getDeterministicDate() });\n        }\n      }\n    }\n    \n    // Update alert with notification status\n    const existingAlert = this.activeAlerts.get(alert.id);\n    if (existingAlert) {\n      existingAlert.notificationsSent.push(...notifications);\n    }\n  }\n\n  // Send notification to specific channel\n  async sendNotification(channel, alert) {\n    switch (channel) {\n      case 'console':\n        return this.sendConsoleNotification(alert);\n      case 'email':\n        return this.sendEmailNotification(alert);\n      case 'slack':\n        return this.sendSlackNotification(alert);\n      case 'webhook':\n        return this.sendWebhookNotification(alert);\n      case 'pagerduty':\n        return this.sendPagerDutyNotification(alert);\n      default:\n        throw new Error(`Unknown notification channel: ${channel}`);\n    }\n  }\n\n  // Console notification\n  sendConsoleNotification(alert) {\n    const colors = {\n      critical: '\\x1b[41m', // Red background\n      high: '\\x1b[31m',     // Red text\n      medium: '\\x1b[33m',   // Yellow text\n      low: '\\x1b[36m'       // Cyan text\n    };\n    \n    const reset = '\\x1b[0m';\n    const color = colors[alert.severity] || colors.medium;\n    \n    console.log(`${color}[ALERT ${alert.severity.toUpperCase()}]${reset} ${alert.name}`);\n    console.log(`Description: ${alert.description}`);\n    console.log(`Source: ${alert.source}`);\n    console.log(`Time: ${this.getDeterministicDate().toISOString()}`);\n    if (alert.tags) console.log(`Tags: ${alert.tags.join(', ')}`);\n    if (alert.metadata) console.log(`Metadata:`, alert.metadata);\n    console.log('---');\n  }\n\n  // Email notification\n  async sendEmailNotification(alert) {\n    if (!this.emailTransporter || !this.config.email.to) {\n      throw new Error('Email configuration not set up');\n    }\n\n    const subject = `[${alert.severity.toUpperCase()}] ${alert.name}`;\n    const html = this.generateEmailTemplate(alert);\n\n    await this.emailTransporter.sendMail({\n      from: this.config.email.from,\n      to: this.config.email.to,\n      subject,\n      html\n    });\n  }\n\n  // Slack notification\n  async sendSlackNotification(alert) {\n    if (!this.config.slack.webhookUrl) {\n      throw new Error('Slack webhook URL not configured');\n    }\n\n    const colors = {\n      critical: 'danger',\n      high: 'warning',\n      medium: 'warning',\n      low: 'good'\n    };\n\n    const payload = {\n      text: `Alert: ${alert.name}`,\n      attachments: [{\n        color: colors[alert.severity] || 'warning',\n        fields: [\n          { title: 'Severity', value: alert.severity.toUpperCase(), short: true },\n          { title: 'Source', value: alert.source, short: true },\n          { title: 'Description', value: alert.description, short: false },\n          { title: 'Time', value: this.getDeterministicDate().toISOString(), short: true }\n        ]\n      }]\n    };\n\n    await axios.post(this.config.slack.webhookUrl, payload);\n  }\n\n  // Webhook notification\n  async sendWebhookNotification(alert) {\n    if (!this.config.webhook.url) {\n      throw new Error('Webhook URL not configured');\n    }\n\n    const payload = {\n      alert,\n      timestamp: this.getDeterministicDate().toISOString(),\n      action: 'alert_created'\n    };\n\n    await axios.post(this.config.webhook.url, payload, {\n      headers: this.config.webhook.headers || {}\n    });\n  }\n\n  // PagerDuty notification\n  async sendPagerDutyNotification(alert) {\n    if (!this.config.pagerduty.integrationKey) {\n      throw new Error('PagerDuty integration key not configured');\n    }\n\n    const payload = {\n      routing_key: this.config.pagerduty.integrationKey,\n      event_action: 'trigger',\n      dedup_key: alert.id,\n      payload: {\n        summary: alert.name,\n        severity: alert.severity,\n        source: alert.source,\n        custom_details: {\n          description: alert.description,\n          metadata: alert.metadata,\n          tags: alert.tags\n        }\n      }\n    };\n\n    await axios.post('https://events.pagerduty.com/v2/enqueue', payload);\n  }\n\n  // Schedule escalation\n  scheduleEscalation(alert) {\n    const rule = this.config.escalationRules.find(r => r.severity === alert.severity);\n    if (!rule || !rule.escalateAfter) return;\n\n    const alertData = this.activeAlerts.get(alert.id);\n    if (!alertData || alertData.escalationLevel >= rule.maxEscalations) return;\n\n    alertData.escalationTimer = setTimeout(async () => {\n      if (this.activeAlerts.has(alert.id)) {\n        alertData.escalationLevel++;\n        await this.escalateAlert(alertData, rule);\n        \n        // Schedule next escalation if needed\n        if (alertData.escalationLevel < rule.maxEscalations) {\n          this.scheduleEscalation(alertData);\n        }\n      }\n    }, rule.escalateAfter);\n  }\n\n  // Escalate alert\n  async escalateAlert(alert, rule) {\n    console.log(`Escalating alert ${alert.id} (level ${alert.escalationLevel})`);\n    \n    // Send escalation notifications\n    await this.sendNotifications({\n      ...alert,\n      name: `[ESCALATED] ${alert.name}`,\n      description: `${alert.description} (Escalation level: ${alert.escalationLevel})`\n    });\n    \n    this.emit('alertEscalated', alert);\n  }\n\n  // Generate email template\n  generateEmailTemplate(alert) {\n    return `\n      <html>\n        <body>\n          <h2 style=\"color: ${this.getSeverityColor(alert.severity)}\">\n            [${alert.severity.toUpperCase()}] ${alert.name}\n          </h2>\n          <p><strong>Description:</strong> ${alert.description}</p>\n          <p><strong>Source:</strong> ${alert.source}</p>\n          <p><strong>Time:</strong> ${this.getDeterministicDate().toISOString()}</p>\n          ${alert.tags ? `<p><strong>Tags:</strong> ${alert.tags.join(', ')}</p>` : ''}\n          ${alert.metadata ? `<p><strong>Metadata:</strong> <pre>${JSON.stringify(alert.metadata, null, 2)}</pre></p>` : ''}\n        </body>\n      </html>\n    `;\n  }\n\n  getSeverityColor(severity) {\n    const colors = {\n      critical: '#ff0000',\n      high: '#ff6600',\n      medium: '#ffcc00',\n      low: '#00ccff'\n    };\n    return colors[severity] || colors.medium;\n  }\n\n  // Send resolution notifications\n  async sendResolutionNotifications(alert) {\n    const resolutionAlert = {\n      ...alert,\n      name: `[RESOLVED] ${alert.name}`,\n      description: `Alert resolved: ${alert.description}`,\n      severity: 'low'\n    };\n\n    await this.sendNotifications(resolutionAlert);\n  }\n\n  // Utility methods\n  generateAlertId() {\n    return `alert_${this.getDeterministicTimestamp()}_${Math.random().toString(36).substr(2, 9)}`;\n  }\n\n  // Get active alerts\n  getActiveAlerts() {\n    return Array.from(this.activeAlerts.values());\n  }\n\n  // Get alert history\n  getAlertHistory(limit = 100) {\n    return this.alertHistory.slice(-limit);\n  }\n\n  // Get alert statistics\n  getAlertStats() {\n    const active = this.activeAlerts.size;\n    const history = this.alertHistory.length;\n    const bySeverity = {};\n    \n    this.activeAlerts.forEach(alert => {\n      bySeverity[alert.severity] = (bySeverity[alert.severity] || 0) + 1;\n    });\n\n    return {\n      active,\n      history,\n      bySeverity,\n      suppressed: this.suppressedAlerts.size\n    };\n  }\n\n  // Add suppression rule\n  addSuppressionRule(rule) {\n    this.config.suppressionRules.push(rule);\n  }\n\n  // Remove suppression rule\n  removeSuppressionRule(index) {\n    this.config.suppressionRules.splice(index, 1);\n  }\n\n  // Test alert (for testing purposes)\n  testAlert(severity = 'medium') {\n    const testAlert = {\n      name: 'Test Alert',\n      description: 'This is a test alert to verify the alerting system',\n      severity,\n      source: 'alert-manager-test',\n      tags: ['test'],\n      metadata: {\n        testTimestamp: this.getDeterministicDate().toISOString(),\n        environment: process.env.NODE_ENV || 'development'\n      }\n    };\n\n    this.emit('alert', testAlert);\n    return testAlert;\n  }\n}\n\nmodule.exports = AlertManager;
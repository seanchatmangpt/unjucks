/**
 * Natural Language to SPARQL Translator - Advanced NLP-based Query Generation
 * 
 * Translates natural language descriptions into executable SPARQL queries using
 * transformer models, semantic parsing, and ontology-aware generation.
 */

import consola from 'consola';

export class NLToSPARQLTranslator {
  constructor(options = {}) {
    this.options = {
      model: options.model || 'facebook/bart-large',
      ontologyPath: options.ontologyPath,
      maxInputLength: options.maxInputLength || 512,
      maxOutputLength: options.maxOutputLength || 1024,
      beamSize: options.beamSize || 5,
      temperature: options.temperature || 0.7,
      confidenceThreshold: options.confidenceThreshold || 0.6,
      ...options
    };
    
    this.logger = consola.withTag('nl-to-sparql');
    
    // Model components
    this.translationModel = null;
    this.semanticParser = null;
    this.ontologyMap = new Map();
    
    // Knowledge base
    this.vocabulary = new Map();
    this.entityMappings = new Map();
    this.relationMappings = new Map();
    this.templatePatterns = new Map();
    
    // Translation history and learning
    this.translationHistory = [];
    this.feedbackData = [];
    this.patternLearning = new Map();
    
    // Performance metrics
    this.metrics = {
      translations: 0,
      successful: 0,
      validated: 0,
      avgConfidence: 0,
      patternMatches: 0
    };
    
    this.initializeComponents();
  }

  async initialize() {
    try {
      this.logger.info('Initializing NL to SPARQL translator...');
      
      // Initialize transformer model
      await this.initializeTranslationModel();
      
      // Load ontology mappings
      await this.loadOntologyMappings();
      
      // Initialize semantic parser
      await this.initializeSemanticParser();
      
      // Load pre-defined patterns
      await this.loadTranslationPatterns();
      
      this.logger.success('NL to SPARQL translator initialized');
      
    } catch (error) {
      this.logger.error('Failed to initialize NL translator:', error);
      throw error;
    }
  }

  initializeComponents() {
    // Common SPARQL query patterns
    this.queryPatterns = {
      selection: ['find', 'get', 'show', 'list', 'retrieve', 'what', 'which'],
      counting: ['count', 'how many', 'number of', 'total'],
      existence: ['is there', 'exists', 'any', 'does'],
      comparison: ['greater than', 'less than', 'more than', 'fewer than', 'before', 'after'],
      aggregation: ['average', 'sum', 'maximum', 'minimum', 'total'],
      temporal: ['when', 'date', 'time', 'recent', 'latest', 'oldest', 'during'],
      lineage: ['derived from', 'came from', 'source', 'origin', 'generated by', 'created by'],
      relationship: ['related to', 'connected to', 'associated with', 'linked to']
    };
    
    // Entity type mappings
    this.entityTypes = {
      person: ['person', 'user', 'agent', 'individual', 'someone'],
      organization: ['organization', 'company', 'institution', 'group'],
      activity: ['activity', 'process', 'action', 'operation', 'task'],
      entity: ['entity', 'thing', 'object', 'item', 'resource'],
      document: ['document', 'file', 'report', 'record']
    };
    
    // Predicate mappings
    this.predicateMap = new Map([
      ['name', 'foaf:name'],
      ['label', 'rdfs:label'],
      ['type', 'rdf:type'],
      ['created', 'dcterms:created'],
      ['modified', 'dcterms:modified'],
      ['derived from', 'prov:wasDerivedFrom'],
      ['generated by', 'prov:wasGeneratedBy'],
      ['associated with', 'prov:wasAssociatedWith'],
      ['attributed to', 'prov:wasAttributedTo'],
      ['used', 'prov:used'],
      ['informed by', 'prov:wasInformedBy']
    ]);
  }

  async initializeTranslationModel() {
    // Mock transformer model initialization
    // In production, this would load actual models like BART, T5, or specialized models
    this.translationModel = {
      name: this.options.model,
      maxInputLength: this.options.maxInputLength,
      maxOutputLength: this.options.maxOutputLength,
      translate: this.mockTranslate.bind(this),
      generateCandidates: this.mockGenerateCandidates.bind(this)
    };
    
    this.logger.debug(`Initialized translation model: ${this.options.model}`);
  }

  async loadOntologyMappings() {
    // Load ontology mappings for entity and relation resolution
    // In production, this would load from OWL files or knowledge graphs
    
    // Provenance ontology mappings
    this.ontologyMap.set('prov', {
      classes: ['Activity', 'Entity', 'Agent', 'Bundle'],
      properties: [
        'wasDerivedFrom', 'wasGeneratedBy', 'wasAssociatedWith',
        'used', 'wasAttributedTo', 'wasInformedBy', 'startedAtTime', 'endedAtTime'
      ]
    });
    
    // FOAF ontology mappings
    this.ontologyMap.set('foaf', {
      classes: ['Person', 'Organization', 'Document'],
      properties: ['name', 'mbox', 'homepage', 'knows']
    });
    
    // Dublin Core mappings
    this.ontologyMap.set('dcterms', {
      properties: ['created', 'modified', 'creator', 'title', 'description', 'subject']
    });
    
    this.logger.debug('Loaded ontology mappings');
  }

  async initializeSemanticParser() {
    // Initialize semantic parsing components
    this.semanticParser = {
      parseEntities: this.parseEntities.bind(this),
      parseRelations: this.parseRelations.bind(this),
      parseIntents: this.parseIntents.bind(this),
      parseConstraints: this.parseConstraints.bind(this)
    };
    
    this.logger.debug('Initialized semantic parser');
  }

  async loadTranslationPatterns() {
    // Load pre-defined translation patterns
    this.templatePatterns.set('lineage_query', {
      patterns: [
        'what was {entity} derived from',
        'show the lineage of {entity}',
        'where did {entity} come from',
        'what is the source of {entity}'
      ],
      template: `
        SELECT ?source ?activity ?agent ?time WHERE {
          <{entity}> prov:wasDerivedFrom ?source .
          ?source prov:wasGeneratedBy ?activity .
          OPTIONAL { ?activity prov:wasAssociatedWith ?agent }
          OPTIONAL { ?activity prov:startedAtTime ?time }
        }
      `
    });
    
    this.templatePatterns.set('count_query', {
      patterns: [
        'how many {entities} are there',
        'count the number of {entities}',
        'what is the total number of {entities}'
      ],
      template: `
        SELECT (COUNT(?entity) AS ?count) WHERE {
          ?entity rdf:type {entityType} .
        }
      `
    });
    
    this.templatePatterns.set('recent_activities', {
      patterns: [
        'show recent activities',
        'what activities happened recently',
        'list latest activities'
      ],
      template: `
        SELECT ?activity ?agent ?time WHERE {
          ?activity rdf:type prov:Activity .
          ?activity prov:startedAtTime ?time .
          OPTIONAL { ?activity prov:wasAssociatedWith ?agent }
        }
        ORDER BY DESC(?time)
        LIMIT 10
      `
    });
    
    this.logger.debug('Loaded translation patterns');
  }

  /**
   * Translate natural language to SPARQL query
   * @param {string} naturalLanguage - Natural language description
   * @param {Object} context - Translation context
   */
  async translate(naturalLanguage, context = {}) {
    try {
      this.logger.debug(`Translating: "${naturalLanguage}"`);
      this.metrics.translations++;
      
      // Preprocess natural language input
      const preprocessed = this.preprocessInput(naturalLanguage);
      
      // Parse semantic structure
      const semantics = await this.parseSemantics(preprocessed, context);
      
      // Check for pattern matches
      const patternMatch = this.matchTranslationPattern(preprocessed, semantics);
      
      let sparqlQuery;
      let confidence;
      let alternatives = [];
      
      if (patternMatch) {
        // Use pattern-based translation
        sparqlQuery = this.generateFromPattern(patternMatch, semantics);
        confidence = 0.9;
        this.metrics.patternMatches++;
        
      } else {
        // Use transformer model translation
        const translation = await this.translationModel.translate(preprocessed, context);
        sparqlQuery = translation.query;
        confidence = translation.confidence;
        alternatives = translation.alternatives || [];
      }
      
      // Post-process and validate
      const postprocessed = this.postprocessQuery(sparqlQuery, semantics);
      const validation = await this.validateQuery(postprocessed);
      
      if (validation.isValid) {
        this.metrics.successful++;
        this.metrics.validated++;
      }
      
      // Update average confidence
      this.metrics.avgConfidence = (
        (this.metrics.avgConfidence * (this.metrics.translations - 1) + confidence) /
        this.metrics.translations
      );
      
      // Store for learning
      this.recordTranslation(naturalLanguage, postprocessed, confidence, semantics);
      
      const result = {
        query: postprocessed,
        confidence,
        semantics,
        validation,
        alternatives: alternatives.map(alt => this.postprocessQuery(alt, semantics)),
        patternUsed: !!patternMatch,
        originalInput: naturalLanguage
      };
      
      return result;
      
    } catch (error) {
      this.logger.error('Translation failed:', error);
      return {
        query: null,
        confidence: 0,
        error: error.message,
        originalInput: naturalLanguage
      };
    }
  }

  preprocessInput(input) {
    // Clean and normalize natural language input
    return input
      .toLowerCase()
      .trim()
      .replace(/[?!.,;]+$/, '') // Remove trailing punctuation
      .replace(/\s+/g, ' '); // Normalize whitespace
  }

  async parseSemantics(input, context) {
    const semantics = {
      intent: await this.semanticParser.parseIntents(input),
      entities: await this.semanticParser.parseEntities(input, context),
      relations: await this.semanticParser.parseRelations(input),
      constraints: await this.semanticParser.parseConstraints(input),
      temporal: this.parseTemporalExpressions(input),
      aggregation: this.parseAggregationTerms(input),
      modifiers: this.parseModifiers(input)
    };
    
    return semantics;
  }

  async parseIntents(input) {
    const intents = [];
    
    // Query type detection
    for (const [intentType, keywords] of Object.entries(this.queryPatterns)) {
      for (const keyword of keywords) {
        if (input.includes(keyword)) {
          intents.push({
            type: intentType,
            confidence: this.calculateKeywordConfidence(keyword, input),
            trigger: keyword
          });
        }
      }
    }
    
    // Sort by confidence
    return intents.sort((a, b) => b.confidence - a.confidence);
  }

  async parseEntities(input, context) {
    const entities = [];
    
    // Named entity recognition (simplified)
    const words = input.split(/\s+/);
    
    for (let i = 0; i < words.length; i++) {
      const word = words[i];
      
      // Check for entity type keywords
      for (const [entityType, keywords] of Object.entries(this.entityTypes)) {
        if (keywords.includes(word)) {
          entities.push({
            text: word,
            type: entityType,
            position: i,
            uri: this.resolveEntityURI(word, entityType),
            confidence: 0.8
          });
        }
      }
      
      // Check for specific entity mentions in context
      if (context.entities) {
        for (const contextEntity of context.entities) {
          if (contextEntity.label && input.includes(contextEntity.label.toLowerCase())) {
            entities.push({
              text: contextEntity.label,
              type: contextEntity.type,
              uri: contextEntity.uri,
              confidence: 0.9,
              fromContext: true
            });
          }
        }
      }
    }
    
    return entities;
  }

  async parseRelations(input) {
    const relations = [];
    
    // Look for relation keywords
    for (const [relation, predicate] of this.predicateMap) {
      if (input.includes(relation)) {
        relations.push({
          text: relation,
          predicate,
          confidence: 0.7
        });
      }
    }
    
    // Pattern-based relation extraction
    const relationPatterns = [
      { pattern: /(\w+)\s+of\s+(\w+)/, type: 'property_of' },
      { pattern: /(\w+)\s+by\s+(\w+)/, type: 'created_by' },
      { pattern: /(\w+)\s+from\s+(\w+)/, type: 'derived_from' },
      { pattern: /(\w+)\s+with\s+(\w+)/, type: 'associated_with' }
    ];
    
    for (const { pattern, type } of relationPatterns) {
      const matches = input.match(pattern);
      if (matches) {
        relations.push({
          text: matches[0],
          type,
          subject: matches[1],
          object: matches[2],
          confidence: 0.6
        });
      }
    }
    
    return relations;
  }

  async parseConstraints(input) {
    const constraints = [];
    
    // Temporal constraints
    const temporalPatterns = [
      { pattern: /after\s+(\d{4})/g, type: 'after_year' },
      { pattern: /before\s+(\d{4})/g, type: 'before_year' },
      { pattern: /in\s+(\d{4})/g, type: 'in_year' },
      { pattern: /recent|latest|new/g, type: 'recent' },
      { pattern: /old|earliest|first/g, type: 'old' }
    ];
    
    for (const { pattern, type } of temporalPatterns) {
      const matches = [...input.matchAll(pattern)];
      for (const match of matches) {
        constraints.push({
          type,
          value: match[1] || match[0],
          text: match[0],
          confidence: 0.8
        });
      }
    }
    
    // Numeric constraints
    const numericPatterns = [
      { pattern: /more than (\d+)/g, type: 'greater_than' },
      { pattern: /less than (\d+)/g, type: 'less_than' },
      { pattern: /exactly (\d+)/g, type: 'equals' },
      { pattern: /at least (\d+)/g, type: 'greater_equal' }
    ];
    
    for (const { pattern, type } of numericPatterns) {
      const matches = [...input.matchAll(pattern)];
      for (const match of matches) {
        constraints.push({
          type,
          value: parseInt(match[1]),
          text: match[0],
          confidence: 0.9
        });
      }
    }
    
    return constraints;
  }

  parseTemporalExpressions(input) {
    const temporal = [];
    
    const patterns = [
      'recent', 'latest', 'newest', 'current', 'today', 'yesterday',
      'last week', 'last month', 'last year', 'this week', 'this month'
    ];
    
    for (const pattern of patterns) {
      if (input.includes(pattern)) {
        temporal.push({
          expression: pattern,
          type: this.classifyTemporalType(pattern),
          confidence: 0.8
        });
      }
    }
    
    return temporal;
  }

  parseAggregationTerms(input) {
    const aggregations = [];
    
    const aggPatterns = [
      { terms: ['count', 'number'], function: 'COUNT' },
      { terms: ['sum', 'total'], function: 'SUM' },
      { terms: ['average', 'avg', 'mean'], function: 'AVG' },
      { terms: ['maximum', 'max', 'highest'], function: 'MAX' },
      { terms: ['minimum', 'min', 'lowest'], function: 'MIN' }
    ];
    
    for (const { terms, function: aggFunc } of aggPatterns) {
      for (const term of terms) {
        if (input.includes(term)) {
          aggregations.push({
            term,
            function: aggFunc,
            confidence: 0.9
          });
        }
      }
    }
    
    return aggregations;
  }

  parseModifiers(input) {
    const modifiers = [];
    
    // Ordering modifiers
    if (input.includes('order by') || input.includes('sort by')) {
      modifiers.push({ type: 'order', direction: 'ASC' });
    }
    if (input.includes('descending') || input.includes('desc')) {
      modifiers.push({ type: 'order', direction: 'DESC' });
    }
    
    // Limiting modifiers
    const limitMatch = input.match(/(?:limit|top|first)\s+(\d+)/);
    if (limitMatch) {
      modifiers.push({ type: 'limit', value: parseInt(limitMatch[1]) });
    }
    
    // Distinct modifier
    if (input.includes('unique') || input.includes('distinct')) {
      modifiers.push({ type: 'distinct' });
    }
    
    return modifiers;
  }

  matchTranslationPattern(input, semantics) {
    // Find matching pattern templates
    for (const [patternType, patternData] of this.templatePatterns) {
      for (const pattern of patternData.patterns) {
        const normalized = pattern.replace(/\{[^}]+\}/g, '.*');
        const regex = new RegExp(normalized, 'i');
        
        if (regex.test(input)) {
          return {
            type: patternType,
            pattern,
            template: patternData.template,
            variables: this.extractPatternVariables(pattern, input)
          };
        }
      }
    }
    
    return null;
  }

  generateFromPattern(patternMatch, semantics) {
    let query = patternMatch.template;
    
    // Replace pattern variables
    for (const [variable, value] of Object.entries(patternMatch.variables)) {
      const placeholder = `{${variable}}`;
      
      if (variable === 'entity' && semantics.entities.length > 0) {
        const entity = semantics.entities[0];
        query = query.replace(placeholder, entity.uri || `<${value}>`);
      } else if (variable === 'entityType' && semantics.entities.length > 0) {
        const entity = semantics.entities[0];
        query = query.replace(placeholder, this.getEntityTypeURI(entity.type));
      } else {
        query = query.replace(placeholder, value);
      }
    }
    
    // Apply constraints
    query = this.applyConstraints(query, semantics.constraints);
    
    // Apply modifiers
    query = this.applyModifiers(query, semantics.modifiers);
    
    return query.trim();
  }

  async mockTranslate(input, context) {
    // Mock transformer-based translation
    // In production, this would use actual transformer models
    
    const confidence = 0.7 + Math.random() * 0.2; // Random confidence 0.7-0.9
    
    // Simple rule-based translation as fallback
    let query = this.generateBasicQuery(input, context);
    
    const alternatives = [
      this.generateAlternativeQuery(input, context, 1),
      this.generateAlternativeQuery(input, context, 2)
    ].filter(q => q && q !== query);
    
    return {
      query,
      confidence,
      alternatives
    };
  }

  async mockGenerateCandidates(input, context, numCandidates = 3) {
    const candidates = [];
    
    for (let i = 0; i < numCandidates; i++) {
      candidates.push({
        query: this.generateAlternativeQuery(input, context, i),
        confidence: 0.5 + Math.random() * 0.4,
        score: Math.random()
      });
    }
    
    return candidates.sort((a, b) => b.score - a.score);
  }

  generateBasicQuery(input, context) {
    // Basic rule-based query generation
    let query = 'SELECT ?subject ?predicate ?object WHERE {\n';
    
    if (input.includes('count') || input.includes('how many')) {
      query = 'SELECT (COUNT(?entity) AS ?count) WHERE {\n';
      query += '  ?entity rdf:type ?type .\n';
    } else if (input.includes('lineage') || input.includes('derived')) {
      query += '  ?entity prov:wasDerivedFrom ?source .\n';
      query += '  OPTIONAL { ?entity prov:wasGeneratedBy ?activity }\n';
    } else if (input.includes('activity') || input.includes('process')) {
      query += '  ?activity rdf:type prov:Activity .\n';
      query += '  OPTIONAL { ?activity prov:wasAssociatedWith ?agent }\n';
    } else {
      query += '  ?subject ?predicate ?object .\n';
    }
    
    query += '}';
    
    // Add LIMIT if not an aggregation
    if (!input.includes('count') && !input.includes('sum')) {
      query += '\nLIMIT 10';
    }
    
    return query;
  }

  generateAlternativeQuery(input, context, variant) {
    // Generate alternative query versions
    const base = this.generateBasicQuery(input, context);
    
    switch (variant) {
      case 1:
        return base.replace('LIMIT 10', 'LIMIT 20');
      case 2:
        return base.replace('?subject ?predicate ?object', '?s ?p ?o');
      default:
        return base;
    }
  }

  postprocessQuery(query, semantics) {
    if (!query) return query;
    
    // Clean up whitespace and formatting
    let processed = query
      .replace(/\s+/g, ' ')
      .replace(/\s*{\s*/g, ' {\n  ')
      .replace(/\s*}\s*/g, '\n}')
      .replace(/\s*\.\s*/g, ' .\n  ')
      .trim();
    
    // Add prefixes if needed
    processed = this.addRequiredPrefixes(processed);
    
    // Validate syntax
    processed = this.fixCommonSyntaxErrors(processed);
    
    return processed;
  }

  addRequiredPrefixes(query) {
    const prefixes = [];
    
    if (query.includes('rdf:') && !query.includes('PREFIX rdf:')) {
      prefixes.push('PREFIX rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#>');
    }
    if (query.includes('rdfs:') && !query.includes('PREFIX rdfs:')) {
      prefixes.push('PREFIX rdfs: <http://www.w3.org/2000/01/rdf-schema#>');
    }
    if (query.includes('prov:') && !query.includes('PREFIX prov:')) {
      prefixes.push('PREFIX prov: <http://www.w3.org/ns/prov#>');
    }
    if (query.includes('foaf:') && !query.includes('PREFIX foaf:')) {
      prefixes.push('PREFIX foaf: <http://xmlns.com/foaf/0.1/>');
    }
    if (query.includes('dcterms:') && !query.includes('PREFIX dcterms:')) {
      prefixes.push('PREFIX dcterms: <http://purl.org/dc/terms/>');
    }
    
    if (prefixes.length > 0) {
      return prefixes.join('\n') + '\n\n' + query;
    }
    
    return query;
  }

  fixCommonSyntaxErrors(query) {
    // Fix common SPARQL syntax errors
    return query
      .replace(/([?]\w+)\s+([?]\w+)\s+([?]\w+)(?!\s*[.;,}])/g, '$1 $2 $3 .')
      .replace(/\.\s*\.\s*/g, ' .\n  ')
      .replace(/}\s*WHERE/g, '}\nWHERE')
      .replace(/SELECT\s+WHERE/g, 'SELECT * WHERE');
  }

  async validateQuery(query) {
    // Basic SPARQL query validation
    const validation = {
      isValid: true,
      errors: [],
      warnings: []
    };
    
    if (!query) {
      validation.isValid = false;
      validation.errors.push('Empty query');
      return validation;
    }
    
    // Check for required elements
    if (!query.includes('SELECT') && !query.includes('CONSTRUCT') && 
        !query.includes('ASK') && !query.includes('DESCRIBE')) {
      validation.isValid = false;
      validation.errors.push('Missing query type (SELECT, CONSTRUCT, ASK, DESCRIBE)');
    }
    
    if (!query.includes('WHERE')) {
      validation.isValid = false;
      validation.errors.push('Missing WHERE clause');
    }
    
    // Check bracket balance
    const openBrackets = (query.match(/\{/g) || []).length;
    const closeBrackets = (query.match(/\}/g) || []).length;
    if (openBrackets !== closeBrackets) {
      validation.isValid = false;
      validation.errors.push('Unbalanced brackets');
    }
    
    // Check for common syntax issues
    if (query.includes('??')) {
      validation.warnings.push('Double question marks detected');
    }
    
    if (query.includes('SELECT *') && query.includes('COUNT')) {
      validation.warnings.push('Using SELECT * with COUNT function');
    }
    
    return validation;
  }

  recordTranslation(input, query, confidence, semantics) {
    this.translationHistory.push({
      input,
      query,
      confidence,
      semantics,
      timestamp: Date.now()
    });
    
    // Trim history if too large
    if (this.translationHistory.length > 1000) {
      this.translationHistory = this.translationHistory.slice(-500);
    }
  }

  calculateKeywordConfidence(keyword, input) {
    // Calculate confidence based on keyword context
    let confidence = 0.5;
    
    // Boost confidence if keyword appears at the beginning
    if (input.startsWith(keyword)) {
      confidence += 0.2;
    }
    
    // Boost confidence if keyword is standalone
    const wordBoundary = new RegExp(`\\b${keyword}\\b`);
    if (wordBoundary.test(input)) {
      confidence += 0.2;
    }
    
    // Boost confidence for longer keywords
    confidence += Math.min(0.1, keyword.length / 100);
    
    return Math.min(1.0, confidence);
  }

  resolveEntityURI(text, entityType) {
    // Resolve entity text to URI
    // In production, this would use entity linking
    const baseURI = 'http://example.org/';
    return `${baseURI}${entityType}/${encodeURIComponent(text)}`;
  }

  getEntityTypeURI(entityType) {
    const typeMap = {
      person: 'foaf:Person',
      organization: 'foaf:Organization',
      activity: 'prov:Activity',
      entity: 'prov:Entity',
      agent: 'prov:Agent',
      document: 'foaf:Document'
    };
    
    return typeMap[entityType] || 'owl:Thing';
  }

  classifyTemporalType(expression) {
    if (['recent', 'latest', 'newest', 'current'].includes(expression)) {
      return 'recent';
    }
    if (['old', 'earliest', 'first'].includes(expression)) {
      return 'past';
    }
    if (expression.includes('last')) {
      return 'past_relative';
    }
    if (expression.includes('this')) {
      return 'current_relative';
    }
    return 'temporal';
  }

  extractPatternVariables(pattern, input) {
    const variables = {};
    const placeholderRegex = /\{(\w+)\}/g;
    let match;
    
    // Create regex from pattern
    let regexPattern = pattern.replace(/\{(\w+)\}/g, '([^\\s]+)');
    regexPattern = regexPattern.replace(/\s+/g, '\\s+');
    
    const inputMatch = input.match(new RegExp(regexPattern, 'i'));
    
    if (inputMatch) {
      let varIndex = 1;
      while ((match = placeholderRegex.exec(pattern)) !== null) {
        variables[match[1]] = inputMatch[varIndex];
        varIndex++;
      }
    }
    
    return variables;
  }

  applyConstraints(query, constraints) {
    let modified = query;
    
    for (const constraint of constraints) {
      switch (constraint.type) {
        case 'after_year':
          modified = this.addTemporalFilter(modified, `?time >= "${constraint.value}-01-01"^^xsd:dateTime`);
          break;
        case 'before_year':
          modified = this.addTemporalFilter(modified, `?time <= "${constraint.value}-12-31"^^xsd:dateTime`);
          break;
        case 'recent':
          modified = this.addRecentFilter(modified);
          break;
        case 'greater_than':
          modified = this.addNumericFilter(modified, `?count > ${constraint.value}`);
          break;
        case 'less_than':
          modified = this.addNumericFilter(modified, `?count < ${constraint.value}`);
          break;
      }
    }
    
    return modified;
  }

  applyModifiers(query, modifiers) {
    let modified = query;
    
    for (const modifier of modifiers) {
      switch (modifier.type) {
        case 'order':
          modified = this.addOrderBy(modified, modifier.direction);
          break;
        case 'limit':
          modified = this.addLimit(modified, modifier.value);
          break;
        case 'distinct':
          modified = this.addDistinct(modified);
          break;
      }
    }
    
    return modified;
  }

  addTemporalFilter(query, filter) {
    // Add temporal filter to query
    if (query.includes('?time')) {
      return query.replace(/}(\s*)$/, `  FILTER(${filter})\n}$1`);
    }
    return query;
  }

  addRecentFilter(query) {
    const recentFilter = `?time >= "${new Date(Date.now() - 30 * 24 * 3600000).toISOString()}"^^xsd:dateTime`;
    return this.addTemporalFilter(query, recentFilter);
  }

  addNumericFilter(query, filter) {
    return query.replace(/}(\s*)$/, `  FILTER(${filter})\n}$1`);
  }

  addOrderBy(query, direction = 'ASC') {
    if (!query.includes('ORDER BY')) {
      // Try to find a suitable variable to order by
      const timeVar = query.includes('?time') ? '?time' : 
                     query.includes('?timestamp') ? '?timestamp' : null;
      
      if (timeVar) {
        return query.replace(/(\n?)LIMIT/, `\nORDER BY ${direction}(${timeVar})$1LIMIT`);
      }
    }
    return query;
  }

  addLimit(query, limit) {
    if (!query.includes('LIMIT')) {
      return query + `\nLIMIT ${limit}`;
    }
    return query.replace(/LIMIT\s+\d+/, `LIMIT ${limit}`);
  }

  addDistinct(query) {
    if (!query.includes('DISTINCT')) {
      return query.replace(/SELECT\s+/, 'SELECT DISTINCT ');
    }
    return query;
  }

  /**
   * Learn from user feedback on translations
   * @param {string} input - Original natural language input
   * @param {string} correctQuery - Correct SPARQL query
   * @param {number} rating - User rating (0-5)
   */
  async learnFromFeedback(input, correctQuery, rating) {
    this.feedbackData.push({
      input,
      correctQuery,
      rating,
      timestamp: Date.now()
    });
    
    // Extract patterns from successful translations
    if (rating >= 4) {
      await this.extractLearningPatterns(input, correctQuery);
    }
    
    this.logger.debug(`Learned from feedback: ${input} -> rating ${rating}`);
  }

  async extractLearningPatterns(input, query) {
    // Extract patterns for future use
    const semantics = await this.parseSemantics(input);
    
    const pattern = {
      inputPattern: this.generalize_input(input),
      queryTemplate: this.generalizeQuery(query),
      semantics,
      confidence: 0.8,
      usageCount: 1
    };
    
    const key = pattern.inputPattern;
    const existing = this.patternLearning.get(key);
    
    if (existing) {
      existing.usageCount++;
      existing.confidence = Math.min(0.95, existing.confidence + 0.05);
    } else {
      this.patternLearning.set(key, pattern);
    }
  }

  generalize_input(input) {
    // Generalize input by replacing specific entities with placeholders
    return input
      .replace(/\b[A-Z][a-z]+\b/g, '{ENTITY}') // Proper nouns
      .replace(/\b\d{4}\b/g, '{YEAR}') // Years
      .replace(/\b\d+\b/g, '{NUMBER}'); // Numbers
  }

  generalizeQuery(query) {
    // Generalize query by replacing specific URIs with placeholders
    return query
      .replace(/<[^>]+>/g, '{URI}')
      .replace(/"[^"]+"/g, '{LITERAL}')
      .replace(/\b\d{4}\b/g, '{YEAR}');
  }

  /**
   * Get translation statistics
   */
  getStatistics() {
    const successRate = this.metrics.translations > 0 ? 
      this.metrics.successful / this.metrics.translations : 0;
    
    const validationRate = this.metrics.translations > 0 ? 
      this.metrics.validated / this.metrics.translations : 0;
    
    const patternRate = this.metrics.translations > 0 ? 
      this.metrics.patternMatches / this.metrics.translations : 0;
    
    return {
      translations: this.metrics.translations,
      successful: this.metrics.successful,
      validated: this.metrics.validated,
      successRate,
      validationRate,
      avgConfidence: this.metrics.avgConfidence,
      patternMatches: this.metrics.patternMatches,
      patternRate,
      learnedPatterns: this.patternLearning.size,
      feedbackCount: this.feedbackData.length,
      translationHistory: this.translationHistory.length
    };
  }

  /**
   * Export learned patterns
   */
  exportPatterns() {
    return {
      templatePatterns: Array.from(this.templatePatterns.entries()),
      learnedPatterns: Array.from(this.patternLearning.entries()),
      feedbackData: this.feedbackData,
      translationHistory: this.translationHistory.slice(-100) // Recent history
    };
  }

  /**
   * Import patterns from backup
   * @param {Object} patterns - Pattern data to import
   */
  importPatterns(patterns) {
    if (patterns.templatePatterns) {
      this.templatePatterns = new Map(patterns.templatePatterns);
    }
    
    if (patterns.learnedPatterns) {
      this.patternLearning = new Map(patterns.learnedPatterns);
    }
    
    if (patterns.feedbackData) {
      this.feedbackData = patterns.feedbackData;
    }
    
    if (patterns.translationHistory) {
      this.translationHistory = patterns.translationHistory;
    }
    
    this.logger.info('Imported translation patterns');
  }
}

export default NLToSPARQLTranslator;
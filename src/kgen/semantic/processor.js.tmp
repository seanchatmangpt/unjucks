
  // Additional helper methods for reasoning and validation
  
  _parseAntecedent(antecedent) {
    // Simple parser for rule antecedents like "{ ?a rdfs:subClassOf ?b }"
    const cleanAntecedent = antecedent.replace(/[{}]/g, '').trim();
    const parts = cleanAntecedent.split(/\s+/);
    
    if (parts.length >= 3) {
      return [{
        subject: parts[0].startsWith('?') ? parts[0] : parts[0],
        predicate: parts[1],
        object: parts[2].startsWith('?') ? parts[2] : parts[2]
      }];
    }
    
    return [];
  }
  
  _parseConsequent(consequent) {
    // Simple parser for rule consequents
    const cleanConsequent = consequent.replace(/[{}]/g, '').trim();
    const parts = cleanConsequent.split(/\s+/);
    
    if (parts.length >= 3) {
      return {
        subject: parts[0],
        predicate: parts[1],
        object: parts[2]
      };
    }
    
    return null;
  }
  
  _extractBindings(pattern, quad) {
    const bindings = {};
    
    if (pattern.subject && pattern.subject.startsWith('?')) {
      bindings[pattern.subject] = quad.subject.value;
    }
    if (pattern.predicate && pattern.predicate.startsWith('?')) {
      bindings[pattern.predicate] = quad.predicate.value;
    }
    if (pattern.object && pattern.object.startsWith('?')) {
      bindings[pattern.object] = quad.object.value;
    }
    
    return bindings;
  }
  
  _applyBinding(term, bindings) {
    if (term && term.startsWith('?') && bindings[term]) {
      return bindings[term];
    }
    return term;
  }
  
  _isValidURI(uri) {
    try {
      new URL(uri);
      return true;
    } catch {
      return false;
    }
  }
  
  _isValidBlankNode(node) {
    return typeof node === 'string' && node.startsWith('_:');
  }

  // Placeholder methods for SHACL and consistency checking (to be implemented)
  async _validateNodeShape(graph, constraint) { return []; }
  async _validatePropertyShape(graph, constraint) { return []; }
  async _validateMinCount(graph, constraint) { return []; }
  async _validateMaxCount(graph, constraint) { return []; }
  async _validateDatatype(graph, constraint) { return []; }
  async _validateClass(graph, constraint) { return []; }
  async _checkDomainViolations(graph) { return []; }
  async _checkRangeViolations(graph) { return []; }
  async _checkDisjointClasses(graph) { return []; }
  async _checkFunctionalProperties(graph) { return []; }
  async _checkCardinalityConstraints(graph) { return []; }
  async _checkSymmetryConstraints(graph) { return []; }

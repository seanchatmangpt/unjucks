/**
 * Export Command Module
 * Comprehensive CLI export commands with support for PDF, DOCX, HTML, MD formats
 * Includes batch export and format conversion capabilities
 */
import { defineCommand } from "citty";
import chalk from "chalk";
import consola from "consola";
import fs from 'fs-extra';
import path from 'node:path';
import { glob } from 'glob';
import matter from 'gray-matter';
import nunjucks from 'nunjucks';
import dayjs from 'dayjs';

/**
 * Export Engine Class - Handles all export operations
 */
class ExportEngine {
  constructor() {
    this.supportedFormats = ['pdf', 'docx', 'html', 'md', 'tex', 'rtf', 'txt'];
    this.presets = {
      academic: { format: 'pdf', template: 'academic', bibliography: true, toc: true },
      report: { format: 'docx', template: 'corporate', header: true, footer: true },
      web: { format: 'html', template: 'modern', responsive: true, css: true },
      documentation: { format: 'md', template: 'github', toc: true, code: true },
      presentation: { format: 'pdf', template: 'slides', landscape: true },
      article: { format: 'pdf', template: 'article', compact: true }
    };
    
    this.templates = {
      pdf: ['academic', 'article', 'report', 'book', 'slides', 'minimal'],
      docx: ['corporate', 'academic', 'modern', 'simple', 'letterhead'],
      html: ['modern', 'classic', 'minimal', 'dark', 'bootstrap', 'custom'],
      md: ['github', 'gitlab', 'standard', 'extended', 'minimal']
    };
  }

  /**
   * Export single file to specified format
   */
  async exportFile(inputPath, options = {}) {
    try {
      const {
        format = 'pdf',
        output,
        template = 'default',
        preset,
        variables = {},
        metadata = {}
      } = options;

      // Validate format
      if (!this.supportedFormats.includes(format)) {
        throw new Error(`Unsupported format: ${format}. Supported: ${this.supportedFormats.join(', ')}`);
      }

      // Read and parse input file
      const inputContent = await fs.readFile(inputPath, 'utf8');
      const { data: frontmatter, content } = matter(inputContent);
      
      // Merge metadata
      const exportMetadata = {
        title: path.basename(inputPath, path.extname(inputPath)),
        author: 'Generated by Unjucks',
        created: dayjs().format('YYYY-MM-DD HH:mm:ss'),
        format,
        template,
        ...metadata,
        ...frontmatter
      };

      // Apply preset if specified
      let exportConfig = { format, template, ...options };
      if (preset && this.presets[preset]) {
        exportConfig = { ...this.presets[preset], ...exportConfig };
      }

      // Generate output path if not provided
      const outputPath = output || this.generateOutputPath(inputPath, exportConfig.format);

      // Process content with variables
      const processedContent = this.processContent(content, { ...variables, ...exportMetadata });

      // Export based on format
      const result = await this.performExport(processedContent, exportConfig, outputPath, exportMetadata);

      return {
        success: true,
        inputPath,
        outputPath: result.outputPath,
        format: exportConfig.format,
        template: exportConfig.template,
        size: result.size,
        duration: result.duration
      };

    } catch (error) {
      return {
        success: false,
        inputPath,
        error: error.message
      };
    }
  }

  /**
   * Batch export multiple files
   */
  async batchExport(pattern, options = {}) {
    const startTime = Date.now();
    const files = await glob(pattern, { ignore: ['node_modules/**', '.git/**'] });
    
    if (files.length === 0) {
      return {
        success: false,
        message: `No files found matching pattern: ${pattern}`
      };
    }

    consola.info(`Found ${files.length} files to export`);
    
    const results = [];
    const errors = [];

    // Process files concurrently (limited concurrency)
    const concurrency = options.concurrency || 3;
    for (let i = 0; i < files.length; i += concurrency) {
      const batch = files.slice(i, i + concurrency);
      const batchPromises = batch.map(file => this.exportFile(file, options));
      const batchResults = await Promise.all(batchPromises);
      
      for (const result of batchResults) {
        if (result.success) {
          results.push(result);
        } else {
          errors.push(result);
        }
      }
    }

    return {
      success: errors.length === 0,
      total: files.length,
      successful: results.length,
      failed: errors.length,
      results,
      errors,
      duration: Date.now() - startTime
    };
  }

  /**
   * Convert between formats
   */
  async convertFormat(inputPath, fromFormat, toFormat, options = {}) {
    try {
      // First export to intermediate format if needed
      const tempResult = await this.exportFile(inputPath, {
        ...options,
        format: 'html' // Use HTML as intermediate format for most conversions
      });

      if (!tempResult.success) {
        throw new Error(`Failed to convert from ${fromFormat}: ${tempResult.error}`);
      }

      // Then convert to target format
      const finalResult = await this.exportFile(tempResult.outputPath, {
        ...options,
        format: toFormat
      });

      // Clean up temp file if it was created
      if (tempResult.outputPath !== inputPath) {
        await fs.remove(tempResult.outputPath).catch(() => {});
      }

      return finalResult;

    } catch (error) {
      return {
        success: false,
        inputPath,
        error: error.message
      };
    }
  }

  /**
   * Generate output path based on input and format
   */
  generateOutputPath(inputPath, format) {
    const dir = path.dirname(inputPath);
    const name = path.basename(inputPath, path.extname(inputPath));
    return path.join(dir, `${name}.${format}`);
  }

  /**
   * Process content with variables using Nunjucks
   */
  processContent(content, variables) {
    try {
      return nunjucks.renderString(content, variables);
    } catch (error) {
      consola.warn(`Template processing failed: ${error.message}`);
      return content;
    }
  }

  /**
   * Perform the actual export based on format
   */
  async performExport(content, config, outputPath, metadata) {
    const startTime = Date.now();
    
    await fs.ensureDir(path.dirname(outputPath));

    switch (config.format) {
      case 'pdf':
        return await this.exportToPDF(content, config, outputPath, metadata);
      case 'docx':
        return await this.exportToDOCX(content, config, outputPath, metadata);
      case 'html':
        return await this.exportToHTML(content, config, outputPath, metadata);
      case 'md':
        return await this.exportToMarkdown(content, config, outputPath, metadata);
      case 'tex':
        return await this.exportToLaTeX(content, config, outputPath, metadata);
      case 'rtf':
        return await this.exportToRTF(content, config, outputPath, metadata);
      case 'txt':
        return await this.exportToTXT(content, config, outputPath, metadata);
      default:
        throw new Error(`Export format not implemented: ${config.format}`);
    }
  }

  /**
   * Export to PDF format
   */
  async exportToPDF(content, config, outputPath, metadata) {
    // For PDF export, we'll use LaTeX as the intermediate format
    const texContent = this.generateLaTeXContent(content, config, metadata);
    const texPath = outputPath.replace('.pdf', '.tex');
    
    await fs.writeFile(texPath, texContent);
    
    // If LaTeX compiler is available, compile to PDF
    try {
      const { LaTeXCompiler } = await import('../lib/latex/compiler.js').catch(() => ({}));
      if (LaTeXCompiler) {
        const compiler = new LaTeXCompiler({
          engine: config.engine || 'pdflatex',
          outputDir: path.dirname(outputPath)
        });
        
        const result = await compiler.compile(texPath);
        if (result.success) {
          // Clean up tex file
          await fs.remove(texPath);
          return {
            outputPath: result.outputPath,
            size: await this.getFileSize(result.outputPath),
            duration: Date.now() - Date.now()
          };
        }
      }
    } catch (error) {
      consola.warn(`LaTeX compilation failed, keeping .tex file: ${error.message}`);
    }

    // If compilation failed, return the .tex file
    return {
      outputPath: texPath,
      size: await this.getFileSize(texPath),
      duration: Date.now() - Date.now()
    };
  }

  /**
   * Export to DOCX format
   */
  async exportToDOCX(content, config, outputPath, metadata) {
    // Generate HTML first, then convert to DOCX-compatible format
    const htmlContent = this.generateHTMLContent(content, config, metadata);
    
    // Create a basic DOCX-compatible XML structure
    const docxContent = this.generateDOCXContent(htmlContent, config, metadata);
    
    await fs.writeFile(outputPath, docxContent);
    
    return {
      outputPath,
      size: await this.getFileSize(outputPath),
      duration: Date.now() - Date.now()
    };
  }

  /**
   * Export to HTML format
   */
  async exportToHTML(content, config, outputPath, metadata) {
    const htmlContent = this.generateHTMLContent(content, config, metadata);
    await fs.writeFile(outputPath, htmlContent);
    
    return {
      outputPath,
      size: await this.getFileSize(outputPath),
      duration: Date.now() - Date.now()
    };
  }

  /**
   * Export to Markdown format
   */
  async exportToMarkdown(content, config, outputPath, metadata) {
    const mdContent = this.generateMarkdownContent(content, config, metadata);
    await fs.writeFile(outputPath, mdContent);
    
    return {
      outputPath,
      size: await this.getFileSize(outputPath),
      duration: Date.now() - Date.now()
    };
  }

  /**
   * Export to LaTeX format
   */
  async exportToLaTeX(content, config, outputPath, metadata) {
    const texContent = this.generateLaTeXContent(content, config, metadata);
    await fs.writeFile(outputPath, texContent);
    
    return {
      outputPath,
      size: await this.getFileSize(outputPath),
      duration: Date.now() - Date.now()
    };
  }

  /**
   * Export to RTF format
   */
  async exportToRTF(content, config, outputPath, metadata) {
    const rtfContent = this.generateRTFContent(content, config, metadata);
    await fs.writeFile(outputPath, rtfContent);
    
    return {
      outputPath,
      size: await this.getFileSize(outputPath),
      duration: Date.now() - Date.now()
    };
  }

  /**
   * Export to plain text format
   */
  async exportToTXT(content, config, outputPath, metadata) {
    // Strip HTML tags and format as plain text
    const txtContent = content
      .replace(/<[^>]*>/g, '') // Remove HTML tags
      .replace(/&nbsp;/g, ' ') // Replace entities
      .replace(/&lt;/g, '<')
      .replace(/&gt;/g, '>')
      .replace(/&amp;/g, '&')
      .replace(/\n\s*\n/g, '\n\n'); // Clean up extra whitespace
    
    await fs.writeFile(outputPath, txtContent);
    
    return {
      outputPath,
      size: await this.getFileSize(outputPath),
      duration: Date.now() - Date.now()
    };
  }

  /**
   * Generate LaTeX content with proper formatting
   */
  generateLaTeXContent(content, config, metadata) {
    const template = config.template || 'article';
    const documentClass = this.getLaTeXDocumentClass(template);
    const packages = this.getLaTeXPackages(config);
    
    return `\\documentclass{${documentClass}}
${packages.join('\n')}

\\title{${this.escapeLaTeX(metadata.title || 'Document')}}
\\author{${this.escapeLaTeX(metadata.author || 'Author')}}
\\date{${metadata.created || '\\today'}}

\\begin{document}
\\maketitle

${config.toc ? '\\tableofcontents\n\\newpage\n' : ''}

${this.convertContentToLaTeX(content)}

\\end{document}`;
  }

  /**
   * Generate HTML content with proper formatting
   */
  generateHTMLContent(content, config, metadata) {
    const template = config.template || 'modern';
    const css = this.getHTMLStyles(template, config);
    
    return `<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>${metadata.title || 'Document'}</title>
    ${config.css ? `<style>${css}</style>` : ''}
</head>
<body>
    ${config.header ? `<header><h1>${metadata.title || 'Document'}</h1></header>` : ''}
    
    <main>
        ${this.convertContentToHTML(content)}
    </main>
    
    ${config.footer ? `<footer><p>Generated by Unjucks on ${metadata.created}</p></footer>` : ''}
</body>
</html>`;
  }

  /**
   * Generate Markdown content with proper formatting
   */
  generateMarkdownContent(content, config, metadata) {
    let md = '';
    
    if (metadata.title) {
      md += `# ${metadata.title}\n\n`;
    }
    
    if (metadata.author || metadata.created) {
      md += `---\n`;
      if (metadata.author) md += `Author: ${metadata.author}\n`;
      if (metadata.created) md += `Date: ${metadata.created}\n`;
      md += `---\n\n`;
    }
    
    if (config.toc) {
      md += `## Table of Contents\n\n<!-- TOC will be generated here -->\n\n`;
    }
    
    md += this.convertContentToMarkdown(content);
    
    return md;
  }

  /**
   * Generate DOCX-compatible content
   */
  generateDOCXContent(htmlContent, config, metadata) {
    // Basic DOCX XML structure (simplified)
    return `<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<w:document xmlns:w="http://schemas.openxmlformats.org/wordprocessingml/2006/main">
    <w:body>
        <w:p>
            <w:pPr>
                <w:pStyle w:val="Title"/>
            </w:pPr>
            <w:r>
                <w:t>${metadata.title || 'Document'}</w:t>
            </w:r>
        </w:p>
        ${this.convertContentToDOCX(htmlContent)}
    </w:body>
</w:document>`;
  }

  /**
   * Generate RTF content
   */
  generateRTFContent(content, config, metadata) {
    return `{\\rtf1\\ansi\\deff0
{\\fonttbl{\\f0 Times New Roman;}}
{\\colortbl;\\red0\\green0\\blue0;}
\\f0\\fs24
{\\b ${metadata.title || 'Document'}}\\par
\\par
${this.convertContentToRTF(content)}
}`;
  }

  // Helper methods for content conversion
  convertContentToLaTeX(content) {
    return content
      .replace(/&/g, '\\&')
      .replace(/%/g, '\\%')
      .replace(/\$/g, '\\$')
      .replace(/#/g, '\\#')
      .replace(/_/g, '\\_')
      .replace(/\^/g, '\\textasciicircum{}')
      .replace(/~/g, '\\textasciitilde{}');
  }

  convertContentToHTML(content) {
    // Basic Markdown to HTML conversion
    return content
      .replace(/^# (.+)$/gm, '<h1>$1</h1>')
      .replace(/^## (.+)$/gm, '<h2>$1</h2>')
      .replace(/^### (.+)$/gm, '<h3>$1</h3>')
      .replace(/\*\*(.+?)\*\*/g, '<strong>$1</strong>')
      .replace(/\*(.+?)\*/g, '<em>$1</em>')
      .replace(/`(.+?)`/g, '<code>$1</code>')
      .replace(/\n\n/g, '</p><p>')
      .replace(/^(.)/g, '<p>$1')
      .replace(/(.)$/g, '$1</p>');
  }

  convertContentToMarkdown(content) {
    // Clean up and format markdown
    return content
      .replace(/\r\n/g, '\n')
      .replace(/\r/g, '\n')
      .trim();
  }

  convertContentToDOCX(htmlContent) {
    // Convert HTML to DOCX XML (simplified)
    return htmlContent
      .replace(/<h1>(.+?)<\/h1>/g, '<w:p><w:pPr><w:pStyle w:val="Heading1"/></w:pPr><w:r><w:t>$1</w:t></w:r></w:p>')
      .replace(/<h2>(.+?)<\/h2>/g, '<w:p><w:pPr><w:pStyle w:val="Heading2"/></w:pPr><w:r><w:t>$1</w:t></w:r></w:p>')
      .replace(/<p>(.+?)<\/p>/g, '<w:p><w:r><w:t>$1</w:t></w:r></w:p>');
  }

  convertContentToRTF(content) {
    return content
      .replace(/\n/g, '\\par\n')
      .replace(/\*\*(.+?)\*\*/g, '{\\b $1}')
      .replace(/\*(.+?)\*/g, '{\\i $1}');
  }

  // Helper methods for formatting
  getLaTeXDocumentClass(template) {
    const classes = {
      academic: 'article',
      article: 'article',
      report: 'report',
      book: 'book',
      slides: 'beamer',
      minimal: 'minimal'
    };
    return classes[template] || 'article';
  }

  getLaTeXPackages(config) {
    const packages = [
      '\\usepackage[utf8]{inputenc}',
      '\\usepackage[T1]{fontenc}',
      '\\usepackage{amsmath,amsfonts,amssymb}',
      '\\usepackage{graphicx}',
      '\\usepackage[margin=1in]{geometry}'
    ];
    
    if (config.bibliography) {
      packages.push('\\usepackage{natbib}');
    }
    
    if (config.hyperlinks !== false) {
      packages.push('\\usepackage{hyperref}');
    }
    
    return packages;
  }

  getHTMLStyles(template, config) {
    const styles = {
      modern: `
        body { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif; line-height: 1.6; margin: 2rem; }
        h1, h2, h3 { color: #333; }
        code { background: #f4f4f4; padding: 0.2rem 0.4rem; border-radius: 3px; }
        pre { background: #f8f8f8; padding: 1rem; border-radius: 5px; overflow-x: auto; }
      `,
      classic: `
        body { font-family: Times, serif; line-height: 1.8; margin: 2rem auto; max-width: 800px; }
        h1, h2, h3 { font-weight: bold; margin-top: 2rem; }
      `,
      minimal: `
        body { font-family: Georgia, serif; line-height: 1.6; margin: 1rem; color: #333; }
        h1, h2, h3 { border-bottom: 1px solid #eee; padding-bottom: 0.5rem; }
      `
    };
    
    return styles[template] || styles.modern;
  }

  escapeLaTeX(text) {
    return text
      .replace(/\\/g, '\\textbackslash{}')
      .replace(/[&%$#_{}]/g, '\\$&')
      .replace(/\^/g, '\\textasciicircum{}')
      .replace(/~/g, '\\textasciitilde{}');
  }

  async getFileSize(filePath) {
    try {
      const stats = await fs.stat(filePath);
      return stats.size;
    } catch {
      return 0;
    }
  }

  /**
   * List available templates for a format
   */
  listTemplates(format) {
    return this.templates[format] || [];
  }

  /**
   * List available presets
   */
  listPresets() {
    return Object.keys(this.presets).map(name => ({
      name,
      ...this.presets[name]
    }));
  }

  /**
   * Validate export options
   */
  validateOptions(options) {
    const errors = [];
    
    if (options.format && !this.supportedFormats.includes(options.format)) {
      errors.push(`Unsupported format: ${options.format}`);
    }
    
    if (options.template && options.format && !this.templates[options.format]?.includes(options.template)) {
      errors.push(`Template '${options.template}' not available for format '${options.format}'`);
    }
    
    if (options.preset && !this.presets[options.preset]) {
      errors.push(`Unknown preset: ${options.preset}`);
    }
    
    return errors;
  }
}

/**
 * Export command definition
 */
export const exportCommand = defineCommand({
  meta: {
    name: "export",
    description: "Export documents to various formats (PDF, DOCX, HTML, MD)",
  },
  args: {
    input: {
      type: "positional",
      description: "Input file or pattern to export",
      required: false,
    },
    format: {
      type: "string",
      description: "Output format (pdf, docx, html, md, tex, rtf, txt)",
      default: "pdf",
      alias: "f"
    },
    output: {
      type: "string",
      description: "Output file path (auto-generated if not specified)",
      alias: "o"
    },
    template: {
      type: "string",
      description: "Template to use for formatting",
      alias: "t"
    },
    preset: {
      type: "string",
      description: "Use predefined export preset",
      alias: "p"
    },
    all: {
      type: "boolean",
      description: "Export all matching files in batch",
      default: false
    },
    dry: {
      type: "boolean",
      description: "Preview what would be exported without creating files",
      default: false
    },
    force: {
      type: "boolean",
      description: "Overwrite existing files",
      default: false
    },
    verbose: {
      type: "boolean",
      description: "Enable verbose output",
      default: false,
      alias: "v"
    },
    quiet: {
      type: "boolean",
      description: "Suppress non-essential output",
      default: false,
      alias: "q"
    },
    concurrency: {
      type: "number",
      description: "Number of concurrent exports for batch operations",
      default: 3
    },
    toc: {
      type: "boolean",
      description: "Include table of contents",
      default: false
    },
    bibliography: {
      type: "boolean",
      description: "Include bibliography support",
      default: false
    },
    metadata: {
      type: "string",
      description: "JSON string of metadata to include"
    },
    variables: {
      type: "string",
      description: "JSON string of template variables"
    }
  },
  subCommands: {
    pdf: defineCommand({
      meta: {
        name: "pdf",
        description: "Export to PDF format with advanced options"
      },
      args: {
        input: {
          type: "positional",
          description: "Input file to export",
          required: true
        },
        output: {
          type: "string",
          description: "Output PDF file path",
          alias: "o"
        },
        template: {
          type: "string",
          description: "PDF template (academic, article, report, book, slides, minimal)",
          default: "article"
        },
        engine: {
          type: "string",
          description: "LaTeX engine (pdflatex, xelatex, lualatex)",
          default: "pdflatex"
        },
        toc: {
          type: "boolean",
          description: "Include table of contents",
          default: false
        },
        bibliography: {
          type: "boolean",
          description: "Include bibliography",
          default: false
        },
        landscape: {
          type: "boolean",
          description: "Use landscape orientation",
          default: false
        }
      },
      async run({ args }) {
        const engine = new ExportEngine();
        const result = await engine.exportFile(args.input, {
          format: 'pdf',
          output: args.output,
          template: args.template,
          engine: args.engine,
          toc: args.toc,
          bibliography: args.bibliography,
          landscape: args.landscape
        });

        if (result.success) {
          consola.success(`PDF exported: ${chalk.green(result.outputPath)}`);
          return { success: true, ...result };
        } else {
          consola.error(`Export failed: ${result.error}`);
          return { success: false, error: result.error };
        }
      }
    }),

    docx: defineCommand({
      meta: {
        name: "docx",
        description: "Export to DOCX format with template selection"
      },
      args: {
        input: {
          type: "positional",
          description: "Input file to export",
          required: true
        },
        output: {
          type: "string",
          description: "Output DOCX file path",
          alias: "o"
        },
        template: {
          type: "string",
          description: "DOCX template (corporate, academic, modern, simple, letterhead)",
          default: "modern"
        },
        header: {
          type: "boolean",
          description: "Include header",
          default: true
        },
        footer: {
          type: "boolean",
          description: "Include footer",
          default: true
        },
        toc: {
          type: "boolean",
          description: "Include table of contents",
          default: false
        }
      },
      async run({ args }) {
        const engine = new ExportEngine();
        const result = await engine.exportFile(args.input, {
          format: 'docx',
          output: args.output,
          template: args.template,
          header: args.header,
          footer: args.footer,
          toc: args.toc
        });

        if (result.success) {
          consola.success(`DOCX exported: ${chalk.green(result.outputPath)}`);
          return { success: true, ...result };
        } else {
          consola.error(`Export failed: ${result.error}`);
          return { success: false, error: result.error };
        }
      }
    }),

    html: defineCommand({
      meta: {
        name: "html",
        description: "Export to HTML format with styling options"
      },
      args: {
        input: {
          type: "positional",
          description: "Input file to export",
          required: true
        },
        output: {
          type: "string",
          description: "Output HTML file path",
          alias: "o"
        },
        template: {
          type: "string",
          description: "HTML template (modern, classic, minimal, dark, bootstrap)",
          default: "modern"
        },
        css: {
          type: "boolean",
          description: "Include CSS styling",
          default: true
        },
        responsive: {
          type: "boolean",
          description: "Make responsive design",
          default: true
        }
      },
      async run({ args }) {
        const engine = new ExportEngine();
        const result = await engine.exportFile(args.input, {
          format: 'html',
          output: args.output,
          template: args.template,
          css: args.css,
          responsive: args.responsive
        });

        if (result.success) {
          consola.success(`HTML exported: ${chalk.green(result.outputPath)}`);
          return { success: true, ...result };
        } else {
          consola.error(`Export failed: ${result.error}`);
          return { success: false, error: result.error };
        }
      }
    }),

    convert: defineCommand({
      meta: {
        name: "convert",
        description: "Convert between different document formats"
      },
      args: {
        input: {
          type: "positional",
          description: "Input file to convert",
          required: true
        },
        output: {
          type: "positional",
          description: "Output file with target format",
          required: true
        },
        template: {
          type: "string",
          description: "Template to use for target format"
        }
      },
      async run({ args }) {
        const inputExt = path.extname(args.input).slice(1);
        const outputExt = path.extname(args.output).slice(1);
        
        const engine = new ExportEngine();
        const result = await engine.convertFormat(args.input, inputExt, outputExt, {
          output: args.output,
          template: args.template
        });

        if (result.success) {
          consola.success(`Converted: ${chalk.blue(inputExt)} → ${chalk.green(outputExt)}`);
          consola.info(`Output: ${result.outputPath}`);
          return { success: true, ...result };
        } else {
          consola.error(`Conversion failed: ${result.error}`);
          return { success: false, error: result.error };
        }
      }
    }),

    templates: defineCommand({
      meta: {
        name: "templates",
        description: "List available templates for each format"
      },
      args: {
        format: {
          type: "string",
          description: "Show templates for specific format"
        }
      },
      async run({ args }) {
        const engine = new ExportEngine();
        
        if (args.format) {
          const templates = engine.listTemplates(args.format);
          consola.info(`Templates for ${chalk.blue(args.format)}:`);
          templates.forEach(template => {
            console.log(`  ${chalk.green('•')} ${template}`);
          });
        } else {
          consola.info('Available templates by format:');
          Object.entries(engine.templates).forEach(([format, templates]) => {
            console.log(`\n${chalk.blue.bold(format.toUpperCase())}:`);
            templates.forEach(template => {
              console.log(`  ${chalk.green('•')} ${template}`);
            });
          });
        }

        return { success: true };
      }
    }),

    presets: defineCommand({
      meta: {
        name: "presets",
        description: "List available export presets"
      },
      async run() {
        const engine = new ExportEngine();
        const presets = engine.listPresets();
        
        consola.info('Available export presets:');
        presets.forEach(preset => {
          console.log(`\n${chalk.blue.bold(preset.name)}:`);
          console.log(`  Format: ${chalk.green(preset.format)}`);
          console.log(`  Template: ${chalk.green(preset.template)}`);
          const options = Object.entries(preset)
            .filter(([key]) => !['name', 'format', 'template'].includes(key))
            .map(([key, value]) => `${key}: ${value}`)
            .join(', ');
          if (options) {
            console.log(`  Options: ${chalk.gray(options)}`);
          }
        });

        return { success: true, presets };
      }
    })
  },
  
  async run({ args }) {
    const startTime = Date.now();
    const engine = new ExportEngine();

    try {
      // Validate options
      const validationErrors = engine.validateOptions(args);
      if (validationErrors.length > 0) {
        consola.error('Validation errors:');
        validationErrors.forEach(error => consola.error(`  • ${error}`));
        return { success: false, errors: validationErrors };
      }

      // Parse JSON inputs if provided
      let metadata = {};
      let variables = {};
      
      if (args.metadata) {
        try {
          metadata = JSON.parse(args.metadata);
        } catch (error) {
          consola.warn(`Invalid metadata JSON: ${error.message}`);
        }
      }
      
      if (args.variables) {
        try {
          variables = JSON.parse(args.variables);
        } catch (error) {
          consola.warn(`Invalid variables JSON: ${error.message}`);
        }
      }

      const options = {
        format: args.format,
        output: args.output,
        template: args.template,
        preset: args.preset,
        force: args.force,
        toc: args.toc,
        bibliography: args.bibliography,
        metadata,
        variables,
        concurrency: args.concurrency
      };

      // Show what we're doing if not quiet
      if (!args.quiet) {
        consola.info(`${chalk.blue('🚀 Unjucks Export')} - ${args.format.toUpperCase()}`);
        if (args.verbose) {
          console.log('Options:', options);
        }
      }

      let result;

      if (args.all && args.input) {
        // Batch export
        if (!args.quiet) {
          consola.info(`Batch exporting files matching: ${chalk.blue(args.input)}`);
        }
        
        if (args.dry) {
          // Show what would be exported
          const files = await glob(args.input, { ignore: ['node_modules/**', '.git/**'] });
          consola.info(`${chalk.yellow('Dry run:')} Would export ${files.length} files:`);
          files.forEach(file => {
            const outputPath = engine.generateOutputPath(file, args.format);
            console.log(`  ${chalk.blue(file)} → ${chalk.green(outputPath)}`);
          });
          return { success: true, files: files.length, dryRun: true };
        }

        result = await engine.batchExport(args.input, options);
        
        if (result.success) {
          consola.success(`Batch export completed: ${result.successful}/${result.total} files`);
        } else {
          consola.error(`Batch export failed: ${result.failed}/${result.total} files failed`);
          if (args.verbose && result.errors.length > 0) {
            consola.info('Errors:');
            result.errors.forEach(error => {
              console.log(`  ${chalk.red('×')} ${error.inputPath}: ${error.error}`);
            });
          }
        }

      } else if (args.input) {
        // Single file export
        if (args.dry) {
          const outputPath = args.output || engine.generateOutputPath(args.input, args.format);
          consola.info(`${chalk.yellow('Dry run:')} Would export to: ${chalk.green(outputPath)}`);
          return { success: true, outputPath, dryRun: true };
        }

        result = await engine.exportFile(args.input, options);
        
        if (result.success) {
          consola.success(`Export completed: ${chalk.green(result.outputPath)}`);
          if (args.verbose) {
            console.log(`Size: ${result.size} bytes`);
            console.log(`Duration: ${result.duration}ms`);
          }
        } else {
          consola.error(`Export failed: ${result.error}`);
        }

      } else {
        // No input specified - show help
        consola.info('Export formats available:');
        engine.supportedFormats.forEach(format => {
          console.log(`  ${chalk.green('•')} ${format}`);
        });
        
        consola.info('\nUsage examples:');
        console.log(`  ${chalk.gray('unjucks export document.md --format pdf')}`);
        console.log(`  ${chalk.gray('unjucks export pdf document.md')}`);
        console.log(`  ${chalk.gray('unjucks export "*.md" --all --format html')}`);
        console.log(`  ${chalk.gray('unjucks export convert input.tex output.pdf')}`);
        
        return { success: true, help: true };
      }

      const duration = Date.now() - startTime;
      
      if (!args.quiet) {
        consola.info(`${chalk.blue('✨')} Export completed in ${duration}ms`);
        
        if (result && result.success && !args.all) {
          console.log(chalk.gray('\n📝 Next steps:'));
          console.log(chalk.gray('  1. Review the exported file'));
          console.log(chalk.gray('  2. Share or publish as needed'));
        }
      }

      return {
        success: result ? result.success : true,
        duration,
        ...result
      };

    } catch (error) {
      consola.error(`Export failed: ${error.message}`);
      
      if (args.verbose && error.stack) {
        console.error(chalk.gray('\n📍 Stack trace:'));
        console.error(chalk.gray(error.stack));
      }

      console.log(chalk.blue('\n💡 Suggestions:'));
      console.log(chalk.blue('  • Check that input files exist and are readable'));
      console.log(chalk.blue('  • Verify output directory permissions'));
      console.log(chalk.blue('  • Use --dry to preview without creating files'));
      console.log(chalk.blue('  • Run with --verbose for more details'));

      return {
        success: false,
        error: error.message,
        duration: Date.now() - startTime
      };
    }
  }
});

export default exportCommand;
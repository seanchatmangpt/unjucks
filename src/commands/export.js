/**
 * Fixed Export Command Module
 * Comprehensive CLI export commands with proper validation and error handling
 */
import { defineCommand } from "citty";
import chalk from "chalk";
import consola from "consola";
import fs from 'fs-extra';
import path from 'node:path';
import { glob } from 'glob';
import matter from 'gray-matter';
import nunjucks from 'nunjucks';

/**
 * Export Engine Class - Handles all export operations with validation
 */
class ExportEngine {
  constructor() {
    this.supportedFormats = ['pdf', 'docx', 'html', 'md', 'tex', 'rtf', 'txt'];
    this.presets = {
      academic: { format: 'pdf', template: 'academic', bibliography: true, toc: true },
      report: { format: 'docx', template: 'corporate', header: true, footer: true },
      web: { format: 'html', template: 'modern', responsive: true, css: true },
      documentation: { format: 'md', template: 'github', toc: true, code: true },
      presentation: { format: 'pdf', template: 'slides', landscape: true },
      article: { format: 'pdf', template: 'article', compact: true }
    };
    
    this.templates = {
      pdf: ['academic', 'article', 'report', 'book', 'slides', 'minimal'],
      docx: ['corporate', 'academic', 'modern', 'simple', 'letterhead'],
      html: ['modern', 'classic', 'minimal', 'dark', 'bootstrap', 'custom'],
      md: ['github', 'gitlab', 'standard', 'extended', 'minimal']
    };
  }

  /**
   * CRITICAL: Validate format and options before export
   */
  validateExportOptions(options = {}) {
    const errors = [];
    const warnings = [];
    
    // Validate format
    if (options.format && !this.supportedFormats.includes(options.format)) {
      errors.push({
        type: 'format',
        message: `Unsupported format: ${options.format}. Supported: ${this.supportedFormats.join(', ')}`,
        severity: 'critical'
      });
    }
    
    // Validate template
    if (options.template && options.format && !this.templates[options.format]?.includes(options.template)) {
      warnings.push({
        type: 'template',
        message: `Template '${options.template}' not available for format '${options.format}'. Using default.`,
        severity: 'warning'
      });
    }
    
    // Validate preset
    if (options.preset && !this.presets[options.preset]) {
      errors.push({
        type: 'preset',
        message: `Unknown preset: ${options.preset}. Available: ${Object.keys(this.presets).join(', ')}`,
        severity: 'high'
      });
    }
    
    return {
      isValid: errors.filter(e => e.severity === 'critical' || e.severity === 'high').length === 0,
      errors,
      warnings
    };
  }

  /**
   * CRITICAL: Validate file paths for security
   */
  validateFilePath(filePath) {
    if (!filePath) {
      return { isValid: false, error: 'File path is required' };
    }
    
    // Prevent directory traversal
    if (filePath.includes('..') || filePath.includes('~')) {
      return { isValid: false, error: 'Directory traversal not allowed' };
    }
    
    // Validate extension if provided
    const ext = path.extname(filePath).toLowerCase();
    const allowedExtensions = ['.md', '.txt', '.html', '.tex', '.rtf', '.json', ''];
    
    if (ext && !allowedExtensions.includes(ext)) {
      return { isValid: false, error: `File extension '${ext}' not supported` };
    }
    
    return { isValid: true, sanitized: path.resolve(filePath) };
  }

  /**
   * Export single file to specified format with validation
   */
  async exportFile(inputPath, options = {}) {
    try {
      const startTime = this.getDeterministicTimestamp();
      
      // CRITICAL: Validate options
      const validation = this.validateExportOptions(options);
      if (!validation.isValid) {
        return {
          success: false,
          inputPath,
          errors: validation.errors.filter(e => e.severity === 'critical' || e.severity === 'high'),
          warnings: validation.warnings
        };
      }
      
      // CRITICAL: Validate file path
      const pathValidation = this.validateFilePath(inputPath);
      if (!pathValidation.isValid) {
        return {
          success: false,
          inputPath,
          error: pathValidation.error
        };
      }
      
      const {
        format = 'pdf',
        output,
        template = 'default',
        preset,
        variables = {},
        metadata = {}
      } = options;

      // Read and parse input file
      let inputContent;
      try {
        inputContent = await fs.readFile(pathValidation.sanitized, 'utf8');
      } catch (error) {
        return {
          success: false,
          inputPath,
          error: `Cannot read input file: ${error.message}`
        };
      }
      
      const { data: frontmatter, content } = matter(inputContent);
      
      // Merge metadata with current timestamp
      const exportMetadata = {
        title: path.basename(inputPath, path.extname(inputPath)),
        author: 'Generated by Unjucks',
        created: this.getDeterministicDate().toISOString().slice(0, 19).replace('T', ' '),
        format,
        template,
        ...metadata,
        ...frontmatter
      };

      // Apply preset if specified
      let exportConfig = { format, template, ...options };
      if (preset && this.presets[preset]) {
        exportConfig = { ...this.presets[preset], ...exportConfig };
      }

      // Generate output path if not provided with validation
      let outputPath = output;
      if (!outputPath) {
        outputPath = this.generateOutputPath(inputPath, exportConfig.format);
      }
      
      const outputValidation = this.validateFilePath(outputPath);
      if (!outputValidation.isValid) {
        return {
          success: false,
          inputPath,
          error: `Invalid output path: ${outputValidation.error}`
        };
      }

      // Process content with variables using Nunjucks
      const processedContent = this.processContent(content, { ...variables, ...exportMetadata });

      // Export based on format with error handling
      const result = await this.performExport(processedContent, exportConfig, outputValidation.sanitized, exportMetadata);

      return {
        success: true,
        inputPath,
        outputPath: result.outputPath,
        format: exportConfig.format,
        template: exportConfig.template,
        size: result.size,
        duration: this.getDeterministicTimestamp() - startTime,
        warnings: validation.warnings
      };

    } catch (error) {
      return {
        success: false,
        inputPath,
        error: error.message
      };
    }
  }

  /**
   * Generate output path based on input and format
   */
  generateOutputPath(inputPath, format) {
    const dir = path.dirname(inputPath);
    const name = path.basename(inputPath, path.extname(inputPath));
    return path.resolve(dir, `${name}.${format}`);
  }

  /**
   * Process content with variables using Nunjucks (secure)
   */
  processContent(content, variables) {
    try {
      // Use Nunjucks with security settings
      const env = new nunjucks.Environment(null, {
        autoescape: true, // Enable autoescaping for security
        throwOnUndefined: false
      });
      
      return env.renderString(content, variables);
    } catch (error) {
      consola.warn(`Template processing failed: ${error.message}`);
      return content;
    }
  }

  /**
   * Perform the actual export based on format
   */
  async performExport(content, config, outputPath, metadata) {
    const startTime = this.getDeterministicTimestamp();
    
    await fs.ensureDir(path.dirname(outputPath));

    switch (config.format) {
      case 'pdf':
        return await this.exportToPDF(content, config, outputPath, metadata);
      case 'docx':
        return await this.exportToDOCX(content, config, outputPath, metadata);
      case 'html':
        return await this.exportToHTML(content, config, outputPath, metadata);
      case 'md':
        return await this.exportToMarkdown(content, config, outputPath, metadata);
      case 'tex':
        return await this.exportToLaTeX(content, config, outputPath, metadata);
      case 'rtf':
        return await this.exportToRTF(content, config, outputPath, metadata);
      case 'txt':
        return await this.exportToTXT(content, config, outputPath, metadata);
      default:
        throw new Error(`Export format not implemented: ${config.format}`);
    }
  }

  /**
   * Export to PDF format (via LaTeX)
   */
  async exportToPDF(content, config, outputPath, metadata) {
    const texContent = this.generateLaTeXContent(content, config, metadata);
    const texPath = outputPath.replace('.pdf', '.tex');
    
    await fs.writeFile(texPath, texContent);
    
    // Note: Actual PDF compilation requires LaTeX installation
    consola.info('PDF export generated LaTeX file. Install LaTeX for PDF compilation.');
    
    return {
      outputPath: texPath,
      size: await this.getFileSize(texPath),
      duration: this.getDeterministicTimestamp() - this.getDeterministicTimestamp()
    };
  }

  /**
   * Export to DOCX format
   */
  async exportToDOCX(content, config, outputPath, metadata) {
    const htmlContent = this.generateHTMLContent(content, config, metadata);
    
    // Create a basic DOCX-compatible format (simplified)
    const docxContent = `
<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<w:document xmlns:w="http://schemas.openxmlformats.org/wordprocessingml/2006/main">
    <w:body>
        <w:p>
            <w:pPr>
                <w:pStyle w:val="Title"/>
            </w:pPr>
            <w:r>
                <w:t>${metadata.title || 'Document'}</w:t>
            </w:r>
        </w:p>
        <w:p>
            <w:r>
                <w:t>${content}</w:t>
            </w:r>
        </w:p>
    </w:body>
</w:document>`;
    
    await fs.writeFile(outputPath, docxContent);
    
    return {
      outputPath,
      size: await this.getFileSize(outputPath),
      duration: this.getDeterministicTimestamp() - this.getDeterministicTimestamp()
    };
  }

  /**
   * Export to HTML format
   */
  async exportToHTML(content, config, outputPath, metadata) {
    const htmlContent = this.generateHTMLContent(content, config, metadata);
    await fs.writeFile(outputPath, htmlContent);
    
    return {
      outputPath,
      size: await this.getFileSize(outputPath),
      duration: this.getDeterministicTimestamp() - this.getDeterministicTimestamp()
    };
  }

  /**
   * Export to Markdown format
   */
  async exportToMarkdown(content, config, outputPath, metadata) {
    const mdContent = this.generateMarkdownContent(content, config, metadata);
    await fs.writeFile(outputPath, mdContent);
    
    return {
      outputPath,
      size: await this.getFileSize(outputPath),
      duration: this.getDeterministicTimestamp() - this.getDeterministicTimestamp()
    };
  }

  /**
   * Export to LaTeX format
   */
  async exportToLaTeX(content, config, outputPath, metadata) {
    const texContent = this.generateLaTeXContent(content, config, metadata);
    await fs.writeFile(outputPath, texContent);
    
    return {
      outputPath,
      size: await this.getFileSize(outputPath),
      duration: this.getDeterministicTimestamp() - this.getDeterministicTimestamp()
    };
  }

  /**
   * Export to RTF format
   */
  async exportToRTF(content, config, outputPath, metadata) {
    const rtfContent = this.generateRTFContent(content, config, metadata);
    await fs.writeFile(outputPath, rtfContent);
    
    return {
      outputPath,
      size: await this.getFileSize(outputPath),
      duration: this.getDeterministicTimestamp() - this.getDeterministicTimestamp()
    };
  }

  /**
   * Export to plain text format
   */
  async exportToTXT(content, config, outputPath, metadata) {
    // Strip HTML tags and format as plain text
    const txtContent = content
      .replace(/<[^>]*>/g, '') // Remove HTML tags
      .replace(/&nbsp;/g, ' ') // Replace entities
      .replace(/&lt;/g, '<')
      .replace(/&gt;/g, '>')
      .replace(/&amp;/g, '&')
      .replace(/\n\s*\n/g, '\n\n'); // Clean up extra whitespace
    
    await fs.writeFile(outputPath, txtContent);
    
    return {
      outputPath,
      size: await this.getFileSize(outputPath),
      duration: this.getDeterministicTimestamp() - this.getDeterministicTimestamp()
    };
  }

  /**
   * Generate LaTeX content with proper formatting
   */
  generateLaTeXContent(content, config, metadata) {
    const template = config.template || 'article';
    const documentClass = this.getLaTeXDocumentClass(template);
    const packages = this.getLaTeXPackages(config);
    
    return `\\documentclass{${documentClass}}
${packages.join('\n')}

\\title{${this.escapeLaTeX(metadata.title || 'Document')}}
\\author{${this.escapeLaTeX(metadata.author || 'Author')}}
\\date{${metadata.created || '\\today'}}

\\begin{document}
\\maketitle

${config.toc ? '\\tableofcontents\n\\newpage\n' : ''}

${this.convertContentToLaTeX(content)}

\\end{document}`;
  }

  /**
   * Generate HTML content with proper formatting
   */
  generateHTMLContent(content, config, metadata) {
    const template = config.template || 'modern';
    const css = this.getHTMLStyles(template, config);
    
    return `<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>${metadata.title || 'Document'}</title>
    ${config.css ? `<style>${css}</style>` : ''}
</head>
<body>
    ${config.header ? `<header><h1>${metadata.title || 'Document'}</h1></header>` : ''}
    
    <main>
        ${this.convertContentToHTML(content)}
    </main>
    
    ${config.footer ? `<footer><p>Generated by Unjucks on ${metadata.created}</p></footer>` : ''}
</body>
</html>`;
  }

  /**
   * Generate Markdown content with proper formatting
   */
  generateMarkdownContent(content, config, metadata) {
    let md = '';
    
    if (metadata.title) {
      md += `# ${metadata.title}\n\n`;
    }
    
    if (metadata.author || metadata.created) {
      md += `---\n`;
      if (metadata.author) md += `Author: ${metadata.author}\n`;
      if (metadata.created) md += `Date: ${metadata.created}\n`;
      md += `---\n\n`;
    }
    
    if (config.toc) {
      md += `## Table of Contents\n\n<!-- TOC will be generated here -->\n\n`;
    }
    
    md += this.convertContentToMarkdown(content);
    
    return md;
  }

  /**
   * Generate RTF content
   */
  generateRTFContent(content, config, metadata) {
    return `{\\rtf1\\ansi\\deff0
{\\fonttbl{\\f0 Times New Roman;}}
{\\colortbl;\\red0\\green0\\blue0;}
\\f0\\fs24
{\\b ${metadata.title || 'Document'}}\\par
\\par
${this.convertContentToRTF(content)}
}`;
  }

  // Helper methods for content conversion
  convertContentToLaTeX(content) {
    return content
      .replace(/&/g, '\\&')
      .replace(/%/g, '\\%')
      .replace(/\$/g, '\\$')
      .replace(/#/g, '\\#')
      .replace(/_/g, '\\_')
      .replace(/\^/g, '\\textasciicircum{}')
      .replace(/~/g, '\\textasciitilde{}');
  }

  convertContentToHTML(content) {
    // Basic Markdown to HTML conversion
    return content
      .replace(/^# (.+)$/gm, '<h1>$1</h1>')
      .replace(/^## (.+)$/gm, '<h2>$1</h2>')
      .replace(/^### (.+)$/gm, '<h3>$1</h3>')
      .replace(/\*\*(.+?)\*\*/g, '<strong>$1</strong>')
      .replace(/\*(.+?)\*/g, '<em>$1</em>')
      .replace(/`(.+?)`/g, '<code>$1</code>')
      .replace(/\n\n/g, '</p><p>')
      .replace(/^(.)/g, '<p>$1')
      .replace(/(.)$/g, '$1</p>');
  }

  convertContentToMarkdown(content) {
    // Clean up and format markdown
    return content
      .replace(/\r\n/g, '\n')
      .replace(/\r/g, '\n')
      .trim();
  }

  convertContentToRTF(content) {
    return content
      .replace(/\n/g, '\\par\n')
      .replace(/\*\*(.+?)\*\*/g, '{\\b $1}')
      .replace(/\*(.+?)\*/g, '{\\i $1}');
  }

  // Helper methods for formatting
  getLaTeXDocumentClass(template) {
    const classes = {
      academic: 'article',
      article: 'article',
      report: 'report',
      book: 'book',
      slides: 'beamer',
      minimal: 'minimal'
    };
    return classes[template] || 'article';
  }

  getLaTeXPackages(config) {
    const packages = [
      '\\usepackage[utf8]{inputenc}',
      '\\usepackage[T1]{fontenc}',
      '\\usepackage{amsmath,amsfonts,amssymb}',
      '\\usepackage{graphicx}',
      '\\usepackage[margin=1in]{geometry}'
    ];
    
    if (config.bibliography) {
      packages.push('\\usepackage{natbib}');
    }
    
    if (config.hyperlinks !== false) {
      packages.push('\\usepackage{hyperref}');
    }
    
    return packages;
  }

  getHTMLStyles(template, config) {
    const styles = {
      modern: `
        body { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif; line-height: 1.6; margin: 2rem; }
        h1, h2, h3 { color: #333; }
        code { background: #f4f4f4; padding: 0.2rem 0.4rem; border-radius: 3px; }
        pre { background: #f8f8f8; padding: 1rem; border-radius: 5px; overflow-x: auto; }
      `,
      classic: `
        body { font-family: Times, serif; line-height: 1.8; margin: 2rem auto; max-width: 800px; }
        h1, h2, h3 { font-weight: bold; margin-top: 2rem; }
      `,
      minimal: `
        body { font-family: Georgia, serif; line-height: 1.6; margin: 1rem; color: #333; }
        h1, h2, h3 { border-bottom: 1px solid #eee; padding-bottom: 0.5rem; }
      `
    };
    
    return styles[template] || styles.modern;
  }

  escapeLaTeX(text) {
    return text
      .replace(/\\/g, '\\textbackslash{}')
      .replace(/[&%$#_{}]/g, '\\$&')
      .replace(/\^/g, '\\textasciicircum{}')
      .replace(/~/g, '\\textasciitilde{}');
  }

  async getFileSize(filePath) {
    try {
      const stats = await fs.stat(filePath);
      return stats.size;
    } catch {
      return 0;
    }
  }

  /**
   * List available templates for a format
   */
  listTemplates(format) {
    return this.templates[format] || [];
  }

  /**
   * List available presets
   */
  listPresets() {
    return Object.keys(this.presets).map(name => ({
      name,
      ...this.presets[name]
    }));
  }

  /**
   * Batch export multiple files
   */
  async batchExport(pattern, options = {}) {
    const startTime = this.getDeterministicTimestamp();
    const files = await glob(pattern, { ignore: ['node_modules/**', '.git/**'] });
    
    if (files.length === 0) {
      return {
        success: false,
        message: `No files found matching pattern: ${pattern}`
      };
    }

    consola.info(`Found ${files.length} files to export`);
    
    const results = [];
    const errors = [];

    // Process files with limited concurrency for stability
    const concurrency = options.concurrency || 3;
    for (let i = 0; i < files.length; i += concurrency) {
      const batch = files.slice(i, i + concurrency);
      const batchPromises = batch.map(file => this.exportFile(file, options));
      const batchResults = await Promise.all(batchPromises);
      
      for (const result of batchResults) {
        if (result.success) {
          results.push(result);
        } else {
          errors.push(result);
        }
      }
    }

    return {
      success: errors.length === 0,
      total: files.length,
      successful: results.length,
      failed: errors.length,
      results,
      errors,
      duration: this.getDeterministicTimestamp() - startTime
    };
  }
}

/**
 * Fixed Export command definition with comprehensive validation
 */
export const exportCommand = defineCommand({
  meta: {
    name: "export",
    description: "Export documents to various formats (PDF, DOCX, HTML, MD) with validation",
  },
  args: {
    input: {
      type: "positional",
      description: "Input file or pattern to export",
      required: false,
    },
    format: {
      type: "string",
      description: "Output format (pdf, docx, html, md, tex, rtf, txt)",
      default: "pdf",
      alias: "f"
    },
    output: {
      type: "string",
      description: "Output file path (auto-generated if not specified)",
      alias: "o"
    },
    template: {
      type: "string",
      description: "Template to use for formatting",
      alias: "t"
    },
    preset: {
      type: "string",
      description: "Use predefined export preset",
      alias: "p"
    },
    all: {
      type: "boolean",
      description: "Export all matching files in batch",
      default: false
    },
    dry: {
      type: "boolean",
      description: "Preview what would be exported without creating files",
      default: false
    },
    force: {
      type: "boolean",
      description: "Overwrite existing files",
      default: false
    },
    verbose: {
      type: "boolean",
      description: "Enable verbose output",
      default: false,
      alias: "v"
    },
    quiet: {
      type: "boolean",
      description: "Suppress non-essential output",
      default: false,
      alias: "q"
    },
    concurrency: {
      type: "number",
      description: "Number of concurrent exports for batch operations",
      default: 3
    },
    toc: {
      type: "boolean",
      description: "Include table of contents",
      default: false
    },
    bibliography: {
      type: "boolean",
      description: "Include bibliography support",
      default: false
    },
    metadata: {
      type: "string",
      description: "JSON string of metadata to include"
    },
    variables: {
      type: "string",
      description: "JSON string of template variables"
    }
  },
  
  async run({ args }) {
    const startTime = this.getDeterministicTimestamp();
    const engine = new ExportEngine();

    try {
      // Validate options early
      const validationErrors = engine.validateExportOptions(args);
      if (!validationErrors.isValid) {
        consola.error('❌ Validation errors:');
        validationErrors.errors.forEach(error => consola.error(`  • ${error.message}`));
        return { success: false, errors: validationErrors.errors };
      }

      // Parse JSON inputs if provided
      let metadata = {};
      let variables = {};
      
      if (args.metadata) {
        try {
          metadata = JSON.parse(args.metadata);
        } catch (error) {
          consola.warn(`Invalid metadata JSON: ${error.message}`);
        }
      }
      
      if (args.variables) {
        try {
          variables = JSON.parse(args.variables);
        } catch (error) {
          consola.warn(`Invalid variables JSON: ${error.message}`);
        }
      }

      const options = {
        format: args.format,
        output: args.output,
        template: args.template,
        preset: args.preset,
        force: args.force,
        toc: args.toc,
        bibliography: args.bibliography,
        metadata,
        variables,
        concurrency: args.concurrency
      };

      // Show what we're doing if not quiet
      if (!args.quiet) {
        consola.info(`${chalk.blue('🚀 Unjucks Export')} - ${args.format.toUpperCase()}`);
        if (args.verbose) {
          console.log('Options:', options);
        }
      }

      let result;

      if (args.all && args.input) {
        // Batch export
        if (!args.quiet) {
          consola.info(`Batch exporting files matching: ${chalk.blue(args.input)}`);
        }
        
        if (args.dry) {
          const files = await glob(args.input, { ignore: ['node_modules/**', '.git/**'] });
          consola.info(`${chalk.yellow('Dry run:')} Would export ${files.length} files:`);
          files.forEach(file => {
            const outputPath = engine.generateOutputPath(file, args.format);
            console.log(`  ${chalk.blue(file)} → ${chalk.green(outputPath)}`);
          });
          return { success: true, files: files.length, dryRun: true };
        }

        result = await engine.batchExport(args.input, options);
        
        if (result.success) {
          consola.success(`✅ Batch export completed: ${result.successful}/${result.total} files`);
        } else {
          consola.error(`❌ Batch export failed: ${result.failed}/${result.total} files failed`);
          if (args.verbose && result.errors.length > 0) {
            consola.info('Errors:');
            result.errors.forEach(error => {
              console.log(`  ${chalk.red('×')} ${error.inputPath}: ${error.error}`);
            });
          }
        }

      } else if (args.input) {
        // Single file export
        if (args.dry) {
          const outputPath = args.output || engine.generateOutputPath(args.input, args.format);
          consola.info(`${chalk.yellow('Dry run:')} Would export to: ${chalk.green(outputPath)}`);
          return { success: true, outputPath, dryRun: true };
        }

        // Ensure the input file exists
        try {
          await fs.access(args.input);
        } catch (error) {
          throw new Error(`Input file not found: ${args.input}`);
        }

        result = await engine.exportFile(args.input, options);
        
        if (result.success) {
          consola.success(`✅ Export completed: ${chalk.green(result.outputPath)}`);
          if (args.verbose) {
            console.log(`Size: ${result.size} bytes`);
            console.log(`Duration: ${result.duration}ms`);
          }
          
          // Show warnings
          if (result.warnings && result.warnings.length > 0) {
            result.warnings.forEach(warning => {
              consola.warn(warning.message);
            });
          }
        } else {
          consola.error(`❌ Export failed: ${result.error}`);
          if (result.errors) {
            result.errors.forEach(error => {
              consola.error(`  • ${error.message}`);
            });
          }
        }

      } else {
        // No input specified - show help
        consola.info('🎯 Export formats available:');
        engine.supportedFormats.forEach(format => {
          console.log(`  ${chalk.green('•')} ${format}`);
        });
        
        consola.info('\n💡 Usage examples:');
        console.log(`  ${chalk.gray('unjucks export document.md --format pdf')}`);
        console.log(`  ${chalk.gray('unjucks export pdf document.md')}`);
        console.log(`  ${chalk.gray('unjucks export "*.md" --all --format html')}`);
        
        return { success: true, help: true };
      }

      const duration = this.getDeterministicTimestamp() - startTime;
      
      if (!args.quiet) {
        consola.info(`${chalk.blue('✨')} Export completed in ${duration}ms`);
        
        if (result && result.success && !args.all) {
          console.log(chalk.gray('\n📝 Next steps:'));
          console.log(chalk.gray('  1. Review the exported file'));
          console.log(chalk.gray('  2. Share or publish as needed'));
        }
      }

      return {
        success: result ? result.success : true,
        duration,
        ...result
      };

    } catch (error) {
      consola.error(`❌ Export failed: ${error.message}`);
      
      if (args.verbose && error.stack) {
        console.error(chalk.gray('\n📍 Stack trace:'));
        console.error(chalk.gray(error.stack));
      }

      console.log(chalk.blue('\n💡 Suggestions:'));
      console.log(chalk.blue('  • Check that input files exist and are readable'));
      console.log(chalk.blue('  • Verify output directory permissions'));
      console.log(chalk.blue('  • Use --dry to preview without creating files'));
      console.log(chalk.blue('  • Run with --verbose for more details'));

      return {
        success: false,
        error: error.message,
        duration: this.getDeterministicTimestamp() - startTime
      };
    }
  }
});

export default exportCommand;
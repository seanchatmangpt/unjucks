---
to: {{ projectName }}/src/controllers/{{ entityName.kebabCase() }}.controller.js
inject: false
---
/**
 * {{ entityName }} Controller for {{ projectName }}
 * Generated by KGEN at {{ generatedAt }}
 * 
 * Handles HTTP requests for {{ entityName }} resources
 */

const { {{ entityName.camelCase() }}Service } = require('../services');
const { validationResult } = require('express-validator');

class {{ entityName.pascalCase() }}Controller {
  constructor() {
    this.service = new {{ entityName.camelCase() }}Service();
  }

  /**
   * Get all {{ entityName.toLowerCase() }}s
   * GET /api/{{ entityName.kebabCase() }}s
   */
  async getAll(req, res) {
    try {
      const { page = 1, limit = 10, ...filters } = req.query;
      const options = {
        page: parseInt(page),
        limit: parseInt(limit),
        filters
      };

      const result = await this.service.findAll(options);
      
      res.json({
        success: true,
        data: result.data,
        pagination: result.pagination,
        timestamp: new Date().toISOString()
      });
    } catch (error) {
      res.status(500).json({
        success: false,
        error: error.message,
        code: 'GET_ALL_FAILED'
      });
    }
  }

  /**
   * Get {{ entityName.toLowerCase() }} by ID
   * GET /api/{{ entityName.kebabCase() }}s/:id
   */
  async getById(req, res) {
    try {
      const { id } = req.params;
      const {{ entityName.camelCase() }} = await this.service.findById(id);

      if (!{{ entityName.camelCase() }}) {
        return res.status(404).json({
          success: false,
          error: '{{ entityName }} not found',
          code: 'NOT_FOUND'
        });
      }

      res.json({
        success: true,
        data: {{ entityName.camelCase() }},
        timestamp: new Date().toISOString()
      });
    } catch (error) {
      res.status(500).json({
        success: false,
        error: error.message,
        code: 'GET_BY_ID_FAILED'
      });
    }
  }

  /**
   * Create new {{ entityName.toLowerCase() }}
   * POST /api/{{ entityName.kebabCase() }}s
   */
  async create(req, res) {
    try {
      // Check validation errors
      const errors = validationResult(req);
      if (!errors.isEmpty()) {
        return res.status(400).json({
          success: false,
          error: 'Validation failed',
          details: errors.array(),
          code: 'VALIDATION_ERROR'
        });
      }

      const {{ entityName.camelCase() }}Data = req.body;
      const new{{ entityName.pascalCase() }} = await this.service.create({{ entityName.camelCase() }}Data);

      res.status(201).json({
        success: true,
        data: new{{ entityName.pascalCase() }},
        message: '{{ entityName }} created successfully',
        timestamp: new Date().toISOString()
      });
    } catch (error) {
      if (error.code === 'DUPLICATE_ENTRY') {
        res.status(409).json({
          success: false,
          error: error.message,
          code: 'DUPLICATE_ENTRY'
        });
      } else {
        res.status(500).json({
          success: false,
          error: error.message,
          code: 'CREATE_FAILED'
        });
      }
    }
  }

  /**
   * Update {{ entityName.toLowerCase() }}
   * PUT /api/{{ entityName.kebabCase() }}s/:id
   */
  async update(req, res) {
    try {
      const errors = validationResult(req);
      if (!errors.isEmpty()) {
        return res.status(400).json({
          success: false,
          error: 'Validation failed',
          details: errors.array(),
          code: 'VALIDATION_ERROR'
        });
      }

      const { id } = req.params;
      const updateData = req.body;

      const updated{{ entityName.pascalCase() }} = await this.service.update(id, updateData);

      if (!updated{{ entityName.pascalCase() }}) {
        return res.status(404).json({
          success: false,
          error: '{{ entityName }} not found',
          code: 'NOT_FOUND'
        });
      }

      res.json({
        success: true,
        data: updated{{ entityName.pascalCase() }},
        message: '{{ entityName }} updated successfully',
        timestamp: new Date().toISOString()
      });
    } catch (error) {
      res.status(500).json({
        success: false,
        error: error.message,
        code: 'UPDATE_FAILED'
      });
    }
  }

  /**
   * Delete {{ entityName.toLowerCase() }}
   * DELETE /api/{{ entityName.kebabCase() }}s/:id
   */
  async delete(req, res) {
    try {
      const { id } = req.params;
      const deleted = await this.service.delete(id);

      if (!deleted) {
        return res.status(404).json({
          success: false,
          error: '{{ entityName }} not found',
          code: 'NOT_FOUND'
        });
      }

      res.json({
        success: true,
        message: '{{ entityName }} deleted successfully',
        timestamp: new Date().toISOString()
      });
    } catch (error) {
      if (error.code === 'FOREIGN_KEY_CONSTRAINT') {
        res.status(409).json({
          success: false,
          error: 'Cannot delete {{ entityName.toLowerCase() }} - it has related records',
          code: 'FOREIGN_KEY_CONSTRAINT'
        });
      } else {
        res.status(500).json({
          success: false,
          error: error.message,
          code: 'DELETE_FAILED'
        });
      }
    }
  }

  {% if features.includes('bulk_operations') -%}
  /**
   * Bulk create {{ entityName.toLowerCase() }}s
   * POST /api/{{ entityName.kebabCase() }}s/bulk
   */
  async bulkCreate(req, res) {
    try {
      const { items } = req.body;

      if (!Array.isArray(items) || items.length === 0) {
        return res.status(400).json({
          success: false,
          error: 'Items array is required and must not be empty',
          code: 'INVALID_INPUT'
        });
      }

      const result = await this.service.bulkCreate(items);

      res.status(201).json({
        success: true,
        data: result,
        message: `${result.created} {{ entityName.toLowerCase() }}s created, ${result.failed} failed`,
        timestamp: new Date().toISOString()
      });
    } catch (error) {
      res.status(500).json({
        success: false,
        error: error.message,
        code: 'BULK_CREATE_FAILED'
      });
    }
  }
  {% endif %}

  {% if features.includes('search') -%}
  /**
   * Search {{ entityName.toLowerCase() }}s
   * GET /api/{{ entityName.kebabCase() }}s/search
   */
  async search(req, res) {
    try {
      const { q: query, ...options } = req.query;

      if (!query || query.trim().length < 2) {
        return res.status(400).json({
          success: false,
          error: 'Search query must be at least 2 characters long',
          code: 'INVALID_QUERY'
        });
      }

      const result = await this.service.search(query, options);

      res.json({
        success: true,
        data: result.data,
        pagination: result.pagination,
        query,
        timestamp: new Date().toISOString()
      });
    } catch (error) {
      res.status(500).json({
        success: false,
        error: error.message,
        code: 'SEARCH_FAILED'
      });
    }
  }
  {% endif %}
}

module.exports = {{ entityName.pascalCase() }}Controller;
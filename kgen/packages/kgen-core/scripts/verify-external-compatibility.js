#!/usr/bin/env node
/**
 * External JWT Tool Compatibility Verification Script
 * 
 * This script validates that JWS tokens generated by the kgen provenance system
 * are verifiable by external JWT tools like jwt.io, jwt-cli, and standard libraries.
 */

import { promises as fs } from 'fs';
import path from 'path';
import { tmpdir } from 'os';
import { spawn } from 'child_process';

import { createProvenanceSystem } from '../src/provenance/index.js';

async function createTestArtifact() {
  const tempDir = await fs.mkdtemp(path.join(tmpdir(), 'kgen-compat-test-'));
  const artifactPath = path.join(tempDir, 'test.js');
  const content = 'console.log("External compatibility test");';
  
  await fs.writeFile(artifactPath, content);
  
  return {
    path: artifactPath,
    content,
    tempDir
  };
}

async function executeCommand(command, args) {
  return new Promise((resolve) => {
    const process = spawn(command, args);
    let stdout = '';
    let stderr = '';
    
    process.stdout?.on('data', (data) => {
      stdout += data.toString();
    });
    
    process.stderr?.on('data', (data) => {
      stderr += data.toString();
    });
    
    process.on('close', (exitCode) => {
      resolve({
        exitCode,
        stdout: stdout.trim(),
        stderr: stderr.trim()
      });
    });
    
    process.on('error', (error) => {
      resolve({
        exitCode: -1,
        stdout: '',
        stderr: error.message
      });
    });
  });
}

async function testJWTCLICompatibility(jwsToken, publicKey) {
  console.log('\nðŸ”§ Testing JWT CLI compatibility...');
  
  try {
    // Create temporary files
    const tempDir = await fs.mkdtemp(path.join(tmpdir(), 'jwt-cli-test-'));
    const tokenFile = path.join(tempDir, 'token.jwt');
    const keyFile = path.join(tempDir, 'public.jwk');
    
    await fs.writeFile(tokenFile, jwsToken);
    await fs.writeFile(keyFile, JSON.stringify(publicKey, null, 2));
    
    // Test jwt-cli verification
    const result = await executeCommand('jwt', [
      'verify',
      '--key', keyFile,
      '--alg', publicKey.alg || 'EdDSA',
      tokenFile
    ]);
    
    // Cleanup
    await fs.rm(tempDir, { recursive: true, force: true });
    
    if (result.exitCode === 0) {
      console.log('âœ… JWT CLI verification: PASSED');
      console.log(`   Output: ${result.stdout.substring(0, 100)}...`);
      return true;
    } else {
      console.log('âŒ JWT CLI verification: FAILED');
      console.log(`   Error: ${result.stderr || result.stdout}`);
      return false;
    }
    
  } catch (error) {
    console.log('âš ï¸  JWT CLI verification: SKIPPED (tool not available)');
    console.log(`   Reason: ${error.message}`);
    return null; // Tool not available
  }
}

async function testNodeJSCompatibility(jwsToken, publicKey) {
  console.log('\nðŸ“¦ Testing Node.js jsonwebtoken compatibility...');
  
  try {
    // Create test script
    const tempDir = await fs.mkdtemp(path.join(tmpdir(), 'node-jwt-test-'));
    const scriptFile = path.join(tempDir, 'test.js');
    const keyFile = path.join(tempDir, 'key.jwk');
    
    await fs.writeFile(keyFile, JSON.stringify(publicKey, null, 2));
    
    const testScript = `
const jwt = require('jsonwebtoken');
const fs = require('fs');

try {
  const token = process.argv[2];
  const keyData = JSON.parse(fs.readFileSync('${keyFile}', 'utf8'));
  
  const decoded = jwt.verify(token, keyData, {
    algorithms: [keyData.alg || 'EdDSA']
  });
  
  console.log('SUCCESS: Token verified');
  console.log('Payload:', JSON.stringify(decoded, null, 2));
} catch (error) {
  console.log('FAILED:', error.message);
  process.exit(1);
}`;
    
    await fs.writeFile(scriptFile, testScript);
    
    // Execute test
    const result = await executeCommand('node', [scriptFile, jwsToken]);
    
    // Cleanup
    await fs.rm(tempDir, { recursive: true, force: true });
    
    if (result.exitCode === 0) {
      console.log('âœ… Node.js jsonwebtoken: PASSED');
      console.log(`   Verification successful`);
      return true;
    } else {
      console.log('âŒ Node.js jsonwebtoken: FAILED');
      console.log(`   Error: ${result.stderr || result.stdout}`);
      return false;
    }
    
  } catch (error) {
    console.log('âš ï¸  Node.js jsonwebtoken: SKIPPED (dependency not available)');
    console.log(`   Reason: ${error.message}`);
    return null;
  }
}

async function testJWTioCompatibility(jwsToken, publicKey) {
  console.log('\nðŸŒ Testing jwt.io format compatibility...');
  
  try {
    // Parse the token manually to verify structure
    const [headerB64, payloadB64, signatureB64] = jwsToken.split('.');
    
    if (!headerB64 || !payloadB64 || !signatureB64) {
      console.log('âŒ jwt.io compatibility: FAILED (invalid structure)');
      return false;
    }
    
    // Decode header and payload
    const header = JSON.parse(Buffer.from(headerB64, 'base64url').toString());
    const payload = JSON.parse(Buffer.from(payloadB64, 'base64url').toString());
    
    console.log('âœ… jwt.io compatibility: PASSED');
    console.log(`   Token structure is valid RFC 7515 JWS format`);
    console.log(`   Algorithm: ${header.alg}`);
    console.log(`   Key ID: ${header.kid}`);
    console.log(`   Issuer: ${payload.iss}`);
    console.log(`   Issued At: ${new Date(payload.iat * 1000).toISOString()}`);
    console.log(`   Expires At: ${new Date(payload.exp * 1000).toISOString()}`);
    
    // Generate jwt.io URL for manual verification
    const jwtioUrl = `https://jwt.io/#debugger-io?token=${encodeURIComponent(jwsToken)}`;
    console.log(`   Manual verification URL: ${jwtioUrl}`);
    
    return true;
    
  } catch (error) {
    console.log('âŒ jwt.io compatibility: FAILED');
    console.log(`   Error: ${error.message}`);
    return false;
  }
}

async function testPythonCompatibility(jwsToken, publicKey) {
  console.log('\nðŸ Testing Python PyJWT compatibility...');
  
  try {
    const tempDir = await fs.mkdtemp(path.join(tmpdir(), 'python-jwt-test-'));
    const scriptFile = path.join(tempDir, 'test.py');
    const keyFile = path.join(tempDir, 'key.jwk');
    
    await fs.writeFile(keyFile, JSON.stringify(publicKey, null, 2));
    
    const pythonScript = `#!/usr/bin/env python3
import sys
import json
try:
    import jwt
except ImportError:
    print("SKIPPED: PyJWT not installed")
    sys.exit(2)

try:
    with open('${keyFile}', 'r') as f:
        key_data = json.load(f)
    
    token = sys.argv[1]
    
    # Note: This is simplified - real PyJWT would need proper JWK handling
    decoded = jwt.decode(
        token,
        key_data,
        algorithms=[key_data.get('alg', 'EdDSA')]
    )
    
    print("SUCCESS: Token verified")
    print("Payload:", json.dumps(decoded, indent=2))
    
except Exception as error:
    print(f"FAILED: {str(error)}")
    sys.exit(1)
`;
    
    await fs.writeFile(scriptFile, pythonScript);
    
    const result = await executeCommand('python3', [scriptFile, jwsToken]);
    
    await fs.rm(tempDir, { recursive: true, force: true });
    
    if (result.exitCode === 0) {
      console.log('âœ… Python PyJWT: PASSED');
      return true;
    } else if (result.exitCode === 2) {
      console.log('âš ï¸  Python PyJWT: SKIPPED (PyJWT not installed)');
      return null;
    } else {
      console.log('âŒ Python PyJWT: FAILED');
      console.log(`   Error: ${result.stderr || result.stdout}`);
      return false;
    }
    
  } catch (error) {
    console.log('âš ï¸  Python PyJWT: SKIPPED (Python not available)');
    return null;
  }
}

async function generateTestData() {
  console.log('ðŸ—ï¸  Generating test attestation...');
  
  const artifact = await createTestArtifact();
  
  // Create provenance system
  const system = createProvenanceSystem({
    keys: {
      keyStorePath: path.join(artifact.tempDir, 'keys')
    }
  });
  
  await system.initialize();
  
  // Generate attestation
  const attestation = await system.generateAttestation(artifact, {
    templatePath: 'scripts/compatibility-test.njk',
    operationId: 'compatibility-test-' + Date.now()
  });
  
  console.log('âœ… Test attestation generated');
  console.log(`   Algorithms: ${Object.keys(attestation.signatures).join(', ')}`);
  console.log(`   Artifact: ${path.basename(artifact.path)}`);
  
  return {
    artifact,
    attestation
  };
}

async function runCompatibilityTests() {
  console.log('ðŸš€ kgen Provenance System - External JWT Tool Compatibility Test\n');
  console.log('This script validates that JWS tokens generated by kgen are verifiable');
  console.log('by external JWT tools and standard libraries.\n');
  
  try {
    // Generate test data
    const { artifact, attestation } = await generateTestData();
    
    const results = {
      passed: 0,
      failed: 0,
      skipped: 0
    };
    
    // Test each algorithm
    for (const [algorithm, jwsToken] of Object.entries(attestation.signatures)) {
      const publicKey = attestation.verification.keys[algorithm];
      
      console.log(`\nðŸ“‹ Testing ${algorithm.toUpperCase()} algorithm compatibility:`);
      console.log('â•'.repeat(60));
      
      // Run compatibility tests
      const tests = [
        testJWTioCompatibility,
        testJWTCLICompatibility,
        testNodeJSCompatibility,
        testPythonCompatibility
      ];
      
      for (const test of tests) {
        const result = await test(jwsToken, publicKey);
        if (result === true) results.passed++;
        else if (result === false) results.failed++;
        else results.skipped++;
      }
    }
    
    // Cleanup
    await fs.rm(artifact.tempDir, { recursive: true, force: true });
    
    // Summary
    console.log('\nðŸŽ¯ Compatibility Test Summary');
    console.log('â•'.repeat(40));
    console.log(`âœ… Passed: ${results.passed}`);
    console.log(`âŒ Failed: ${results.failed}`);
    console.log(`âš ï¸  Skipped: ${results.skipped}`);
    console.log(`ðŸ“Š Total: ${results.passed + results.failed + results.skipped}`);
    
    if (results.failed === 0) {
      console.log('\nðŸŽ‰ All available compatibility tests passed!');
      console.log('   Your JWS tokens are compatible with external JWT tools.');
      process.exit(0);
    } else {
      console.log('\nâš ï¸  Some compatibility tests failed.');
      console.log('   Review the errors above and ensure proper JWK format.');
      process.exit(1);
    }
    
  } catch (error) {
    console.error('ðŸ’¥ Compatibility test failed:', error);
    process.exit(1);
  }
}

// Additional verification functions
async function verifyRFC7515Compliance(jwsToken) {
  console.log('\nðŸ“œ Verifying RFC 7515 (JWS) compliance...');
  
  try {
    // Check JWS structure
    const parts = jwsToken.split('.');
    if (parts.length !== 3) {
      throw new Error('JWS must have exactly 3 parts');
    }
    
    const [headerB64, payloadB64, signatureB64] = parts;
    
    // Validate base64url encoding
    Buffer.from(headerB64, 'base64url');
    Buffer.from(payloadB64, 'base64url');
    Buffer.from(signatureB64, 'base64url');
    
    // Parse header
    const header = JSON.parse(Buffer.from(headerB64, 'base64url').toString());
    
    // Check required header parameters
    if (!header.alg) throw new Error('Missing required "alg" parameter');
    if (header.typ && header.typ !== 'JWT') throw new Error('Invalid "typ" parameter');
    
    // Parse payload
    const payload = JSON.parse(Buffer.from(payloadB64, 'base64url').toString());
    
    console.log('âœ… RFC 7515 compliance: PASSED');
    console.log(`   Structure: Valid JWS format`);
    console.log(`   Header: ${JSON.stringify(header)}`);
    console.log(`   Payload claims: ${Object.keys(payload).join(', ')}`);
    
    return true;
    
  } catch (error) {
    console.log('âŒ RFC 7515 compliance: FAILED');
    console.log(`   Error: ${error.message}`);
    return false;
  }
}

async function generateVerificationGuide(attestation) {
  console.log('\nðŸ“– Generating external verification guide...');
  
  const guide = `# External Verification Guide

## Generated JWS Tokens

The following JWS tokens were generated and can be verified externally:

`;
  
  let content = guide;
  
  for (const [algorithm, jwsToken] of Object.entries(attestation.signatures)) {
    const publicKey = attestation.verification.keys[algorithm];
    
    content += `### ${algorithm.toUpperCase()} Algorithm

**JWS Token:**
\`\`\`
${jwsToken}
\`\`\`

**Public Key (JWK format):**
\`\`\`json
${JSON.stringify(publicKey, null, 2)}
\`\`\`

**jwt.io Verification:**
- Go to https://jwt.io
- Paste the token in the "Encoded" section
- Paste the public key in the "Verify Signature" section
- Ensure algorithm is set to ${algorithm.toUpperCase()}

**Command Line (jwt-cli):**
\`\`\`bash
echo '${jwsToken}' > token.jwt
echo '${JSON.stringify(publicKey)}' > public.jwk
jwt verify --key public.jwk --alg ${algorithm.toUpperCase()} token.jwt
\`\`\`

**Node.js (jsonwebtoken):**
\`\`\`javascript
const jwt = require('jsonwebtoken');
const publicKey = ${JSON.stringify(publicKey)};
const decoded = jwt.verify('${jwsToken}', publicKey, { algorithms: ['${algorithm.toUpperCase()}'] });
console.log(decoded);
\`\`\`

---

`;
  }
  
  content += `## Standards Compliance

- âœ… RFC 7515 (JSON Web Signature)
- âœ… RFC 7518 (JSON Web Algorithms)  
- âœ… RFC 7519 (JSON Web Token)
- âœ… SLSA Provenance v0.2
- âœ… W3C PROV-O Ontology

## Security Features

- Cryptographic signatures (not just hashes)
- External verification support
- Key rotation capability
- Multiple algorithm support
- Timestamp validation
- Replay protection

Generated by kgen-core provenance system v2.0.0
`;
  
  const guidePath = path.join(process.cwd(), 'EXTERNAL_VERIFICATION_GUIDE.md');
  await fs.writeFile(guidePath, content);
  
  console.log(`âœ… Verification guide saved to: ${guidePath}`);
}

// Run the compatibility tests if this script is executed directly
if (import.meta.url === `file://${process.argv[1]}`) {
  runCompatibilityTests();
}

export {
  runCompatibilityTests,
  testJWTCLICompatibility,
  testNodeJSCompatibility,
  testJWTioCompatibility,
  testPythonCompatibility,
  verifyRFC7515Compliance,
  generateVerificationGuide
};
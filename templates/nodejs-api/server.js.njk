/**
 * {% if service %}{{ service.label }}{% else %}Generated API Service{% endif %}
 * {% if service %}{{ service.description }}{% else %}A REST API service generated from knowledge graph{% endif %}
 * Generated by KGEN at {{ metadata.generatedAt }}
 */

const express = require('express');
const app = express();
const PORT = process.env.PORT || 3000;

// Middleware
app.use(express.json());

// {{ entity.label }} model
const {{ entity.label }}Model = {
  // Properties with validation
  {% for property in entity.properties %}
  {{ property.name }}: {
    type: '{{ property.type }}',
    required: {{ property.isRequired }},
    {% if property.hasMinLength %}minLength: {{ property.hasMinLength }},{% endif %}
    {% if property.hasMaxLength %}maxLength: {{ property.hasMaxLength }},{% endif %}
    {% if property.hasMinValue %}minValue: {{ property.hasMinValue }},{% endif %}
    {% if property.hasMaxValue %}maxValue: {{ property.hasMaxValue }},{% endif %}
    {% if property.hasPattern %}pattern: '{{ property.hasPattern }}',{% endif %}
    label: '{{ property.label }}'
  },
  {% endfor %}
};

// In-memory storage (for demo)
let {{ entity.label.lower() }}s = [];
let nextId = 1;

// Validation function
function validate{{ entity.label }}(data) {
  const errors = [];
  
  {% for property in entity.properties %}
  // Validate {{ property.name }}
  {% if property.isRequired %}
  if (!data.{{ property.name }}) {
    errors.push('{{ property.name }} is required');
  }
  {% endif %}
  {% if property.hasMinLength %}
  if (data.{{ property.name }} && data.{{ property.name }}.length < {{ property.hasMinLength }}) {
    errors.push('{{ property.name }} must be at least {{ property.hasMinLength }} characters');
  }
  {% endif %}
  {% if property.hasMaxLength %}
  if (data.{{ property.name }} && data.{{ property.name }}.length > {{ property.hasMaxLength }}) {
    errors.push('{{ property.name }} must be at most {{ property.hasMaxLength }} characters');
  }
  {% endif %}
  {% if property.hasPattern %}
  if (data.{{ property.name }} && !new RegExp('{{ property.hasPattern }}').test(data.{{ property.name }})) {
    errors.push('{{ property.name }} format is invalid');
  }
  {% endif %}
  {% if property.hasMinValue %}
  if (data.{{ property.name }} !== undefined && data.{{ property.name }} < {{ property.hasMinValue }}) {
    errors.push('{{ property.name }} must be at least {{ property.hasMinValue }}');
  }
  {% endif %}
  {% if property.hasMaxValue %}
  if (data.{{ property.name }} !== undefined && data.{{ property.name }} > {{ property.hasMaxValue }}) {
    errors.push('{{ property.name }} must be at most {{ property.hasMaxValue }}');
  }
  {% endif %}
  {% endfor %}
  
  return errors;
}

// Routes
{% for endpoint in endpoints %}
app.{{ endpoint.method.lower() }}('{{ endpoint.path }}', (req, res) => {
  {% if endpoint.method == 'GET' and endpoint.hasPathParameter %}
  const id = parseInt(req.params.id);
  const {{ entity.label.lower() }} = {{ entity.label.lower() }}s.find(u => u.id === id);
  
  if (!{{ entity.label.lower() }}) {
    return res.status(404).json({ error: '{{ entity.label }} not found' });
  }
  
  res.status({{ endpoint.response.statusCode }}).json({{ entity.label.lower() }});
  {% elif endpoint.method == 'POST' %}
  const errors = validate{{ entity.label }}(req.body);
  if (errors.length > 0) {
    return res.status(400).json({ errors });
  }
  
  const new{{ entity.label }} = {
    id: nextId++,
    ...req.body
  };
  
  {{ entity.label.lower() }}s.push(new{{ entity.label }});
  res.status({{ endpoint.response.statusCode }}).json(new{{ entity.label }});
  {% elif endpoint.method == 'PUT' and endpoint.hasPathParameter %}
  const id = parseInt(req.params.id);
  const {{ entity.label.lower() }}Index = {{ entity.label.lower() }}s.findIndex(u => u.id === id);
  
  if ({{ entity.label.lower() }}Index === -1) {
    return res.status(404).json({ error: '{{ entity.label }} not found' });
  }
  
  const errors = validate{{ entity.label }}(req.body);
  if (errors.length > 0) {
    return res.status(400).json({ errors });
  }
  
  {{ entity.label.lower() }}s[{{ entity.label.lower() }}Index] = { id, ...req.body };
  res.status({{ endpoint.response.statusCode }}).json({{ entity.label.lower() }}s[{{ entity.label.lower() }}Index]);
  {% elif endpoint.method == 'DELETE' and endpoint.hasPathParameter %}
  const id = parseInt(req.params.id);
  const {{ entity.label.lower() }}Index = {{ entity.label.lower() }}s.findIndex(u => u.id === id);
  
  if ({{ entity.label.lower() }}Index === -1) {
    return res.status(404).json({ error: '{{ entity.label }} not found' });
  }
  
  {{ entity.label.lower() }}s.splice({{ entity.label.lower() }}Index, 1);
  res.status({{ endpoint.response.statusCode }}).send();
  {% endif %}
});

{% endfor %}

// Health check endpoint
app.get('/health', (req, res) => {
  res.json({ 
    status: 'healthy', 
    service: '{{ service.label }}',
    version: '{{ service.version }}',
    timestamp: new Date().toISOString()
  });
});

// Start server
app.listen(PORT, () => {
  console.log(`{{ service.label }} running on port ${PORT}`);
  console.log(`Health check: http://localhost:${PORT}/health`);
});

module.exports = app;
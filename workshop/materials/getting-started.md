# KGEN Getting Started Guide

*Interactive Tutorial - 2 Hours*

## Welcome to KGEN

KGEN (Knowledge Graph Engineering Next Generation) is a revolutionary code generation system that uses RDF graphs and SHACL validation to create high-quality, validated code and documentation.

### What You'll Learn

- How to model your projects using RDF graphs
- SHACL validation for ensuring data quality
- Template-based code generation
- Self-hosting capabilities and dogfooding approach
- Enterprise integration patterns

### Prerequisites

- Basic understanding of RDF and semantic web concepts
- Familiarity with template engines (Nunjucks/Handlebars)
- Experience with JSON and web technologies
- Command line proficiency

## Chapter 1: Understanding KGEN Architecture

### Core Components

1. **RDF Processing Engine** - Parses and queries RDF graphs using Apache Jena and SPARQL
2. **SHACL Validation Engine** - Validates RDF data against shapes using TopBraid SHACL API
3. **Code Generation Engine** - Generates code from RDF templates using Nunjucks and AST manipulation
4. **Template Processing Engine** - Processes and renders templates with Nunjucks and Handlebars

### Architecture Pattern

KGEN follows a **microservices** architecture with **containerized** deployment, designed for **horizontal** scalability.

## Chapter 2: Your First RDF Model

Let's create a simple project model:

```turtle
@prefix : <https://mycompany.com/ontology#> .
@prefix rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#> .
@prefix kgen: <https://kgen.dev/ontology#> .
@prefix dct: <http://purl.org/dc/terms/> .

:MyFirstProject a kgen:Project ;
    dct:title "My Web Application" ;
    dct:description "A modern web application built with KGEN" ;
    kgen:version "1.0.0" ;
    kgen:hasComponent :UserService, :PaymentService, :NotificationService .

:UserService a kgen:Component ;
    dct:title "User Management Service" ;
    kgen:responsibility "Handle user authentication and profiles" ;
    kgen:technology "Node.js, Express, MongoDB" ;
    kgen:interface "REST API" .

:PaymentService a kgen:Component ;
    dct:title "Payment Processing Service" ;
    kgen:responsibility "Process payments and billing" ;
    kgen:technology "Node.js, Stripe API, PostgreSQL" ;
    kgen:interface "REST API, Webhooks" .

:NotificationService a kgen:Component ;
    dct:title "Notification Service" ;
    kgen:responsibility "Send emails and push notifications" ;
    kgen:technology "Node.js, SendGrid, Firebase" ;
    kgen:interface "Message Queue" .
```

Save this as `my-project.ttl`.

## Chapter 3: SHACL Validation

Create validation shapes to ensure your model is correct:

```turtle
@prefix : <https://mycompany.com/shapes#> .
@prefix sh: <http://www.w3.org/ns/shacl#> .
@prefix kgen: <https://kgen.dev/ontology#> .
@prefix dct: <http://purl.org/dc/terms/> .

:ProjectShape a sh:NodeShape ;
    sh:targetClass kgen:Project ;
    sh:property [
        sh:path dct:title ;
        sh:datatype xsd:string ;
        sh:minCount 1 ;
        sh:maxCount 1 ;
        sh:message "Project must have exactly one title"
    ] ;
    sh:property [
        sh:path kgen:hasComponent ;
        sh:class kgen:Component ;
        sh:minCount 1 ;
        sh:message "Project must have at least one component"
    ] .

:ComponentShape a sh:NodeShape ;
    sh:targetClass kgen:Component ;
    sh:property [
        sh:path kgen:responsibility ;
        sh:datatype xsd:string ;
        sh:minCount 1 ;
        sh:maxCount 1 ;
        sh:message "Component must have defined responsibility"
    ] ;
    sh:property [
        sh:path kgen:technology ;
        sh:datatype xsd:string ;
        sh:minCount 1 ;
        sh:maxCount 1 ;
        sh:message "Component must specify technology stack"
    ] .
```

Save this as `my-shapes.ttl`.

## Chapter 4: Creating Your First Template

Create a Nunjucks template for generating Express.js services:

```javascript
// {{ component.title }} - Generated by KGEN
const express = require('express');
const router = express.Router();

/**
 * {{ component.responsibility }}
 * Technology: {{ component.technology }}
 * Interface: {{ component.interface }}
 */
class {{ component.title | replace(' ', '') }} {
    constructor() {
        this.name = '{{ component.title }}';
        this.version = '{{ project.version }}';
    }

    {% if component.title.includes('User') %}
    // User management endpoints
    async getUsers(req, res) {
        // TODO: Implement user retrieval
        res.json({ message: 'Get users - {{ component.responsibility }}' });
    }

    async createUser(req, res) {
        // TODO: Implement user creation
        res.json({ message: 'Create user - {{ component.responsibility }}' });
    }
    {% endif %}

    {% if component.title.includes('Payment') %}
    // Payment processing endpoints
    async processPayment(req, res) {
        // TODO: Implement payment processing
        res.json({ message: 'Process payment - {{ component.responsibility }}' });
    }

    async getPaymentHistory(req, res) {
        // TODO: Implement payment history
        res.json({ message: 'Payment history - {{ component.responsibility }}' });
    }
    {% endif %}

    {% if component.title.includes('Notification') %}
    // Notification endpoints
    async sendNotification(req, res) {
        // TODO: Implement notification sending
        res.json({ message: 'Send notification - {{ component.responsibility }}' });
    }
    {% endif %}
}

// Setup routes
{% if component.title.includes('User') %}
router.get('/users', (req, res) => new {{ component.title | replace(' ', '') }}().getUsers(req, res));
router.post('/users', (req, res) => new {{ component.title | replace(' ', '') }}().createUser(req, res));
{% endif %}

{% if component.title.includes('Payment') %}
router.post('/payments', (req, res) => new {{ component.title | replace(' ', '') }}().processPayment(req, res));
router.get('/payments/history', (req, res) => new {{ component.title | replace(' ', '') }}().getPaymentHistory(req, res));
{% endif %}

{% if component.title.includes('Notification') %}
router.post('/notifications', (req, res) => new {{ component.title | replace(' ', '') }}().sendNotification(req, res));
{% endif %}

module.exports = router;
```

Save this as `express-service.njk`.

## Chapter 5: Generating Code with KGEN

Now let's use KGEN to generate code:

### Step 1: Validate Your RDF Data

```bash
kgen validate my-project.ttl --shapes my-shapes.ttl --report validation-report.ttl
```

### Step 2: Generate Services

```bash
# Generate all services from your project model
kgen generate express-service my-project.ttl \
    --template express-service.njk \
    --output ./src/services \
    --iterate components
```

This will generate:
- `src/services/UserManagementService.js`
- `src/services/PaymentProcessingService.js`  
- `src/services/NotificationService.js`

### Step 3: Generate API Documentation

```bash
kgen generate openapi-docs my-project.ttl \
    --template openapi.njk \
    --output ./docs/api.json \
    --validate
```

## Chapter 6: Self-Hosting Example

One of KGEN's most powerful features is self-hosting - the ability to generate its own documentation and validate its own outputs.

### Generate Project Documentation

```bash
# Generate comprehensive project documentation
kgen generate project-docs my-project.ttl \
    --template project-docs.njk \
    --output ./docs \
    --recursive-validate
```

### Self-Validation

```bash
# KGEN validates its own generated outputs
kgen self-validate ./src ./docs \
    --depth 3 \
    --report self-validation.json
```

## Chapter 7: Best Practices

### 1. RDF Modeling Best Practices

- Use consistent naming conventions
- Define clear ontologies with proper namespaces
- Model both structure and behavior
- Include provenance information
- Version your models

### 2. SHACL Validation Best Practices

- Create comprehensive shapes for all classes
- Use appropriate constraint types
- Provide clear error messages
- Test shapes thoroughly
- Validate incrementally during development

### 3. Template Design Best Practices

- Keep templates focused and modular
- Use consistent variable naming
- Include generated code comments
- Handle edge cases gracefully
- Make templates reusable across projects

### 4. Enterprise Integration Best Practices

- Integrate with existing CI/CD pipelines
- Use standard security practices
- Implement proper error handling
- Monitor generation performance
- Maintain template libraries

## Chapter 8: Advanced Features

### Conditional Generation

```nunjucks
{% if component.security_required %}
// Security middleware
const authenticate = require('../middleware/auth');
router.use(authenticate);
{% endif %}

{% for endpoint in component.endpoints %}
router.{{ endpoint.method.lower() }}('{{ endpoint.path }}', {{ endpoint.handler }});
{% endfor %}
```

### Multi-Format Output

```bash
# Generate multiple formats from same RDF data
kgen generate multi-format my-project.ttl \
    --template html-docs.njk \
    --output ./docs/project.html \
    --also-generate pdf-docs.njk:./docs/project.pdf \
    --also-generate md-docs.njk:./docs/README.md
```

### Integration with CI/CD

```yaml
# .github/workflows/kgen.yml
name: KGEN Code Generation
on:
  push:
    paths:
      - '**.ttl'
      - 'templates/**'
      
jobs:
  generate:
    runs-on: ubuntu-latest
    steps:
    - uses: actions/checkout@v2
    - name: Setup KGEN
      run: npm install -g kgen-cli
    - name: Validate RDF
      run: kgen validate project.ttl --shapes shapes.ttl
    - name: Generate Code
      run: kgen generate-all project.ttl --output ./generated
    - name: Self-Validate
      run: kgen self-validate ./generated --depth 2
    - name: Commit Generated Code
      run: |
        git add generated/
        git commit -m "Auto-generated code from RDF [skip ci]"
        git push
```

## Chapter 9: Troubleshooting

### Common Issues

**RDF Parsing Errors**
- Check syntax with online validators
- Ensure proper namespace declarations
- Verify turtle syntax compliance

**SHACL Validation Failures**
- Review constraint violations carefully
- Check data types and cardinalities
- Validate shapes themselves first

**Template Rendering Issues**
- Test templates with sample data
- Check variable scoping
- Verify filter usage

**Generation Performance**
- Profile SPARQL queries
- Optimize template complexity
- Use caching where appropriate

### Debugging Tips

```bash
# Enable debug logging
export KGEN_DEBUG=true
kgen generate --verbose my-project.ttl

# Validate step by step
kgen validate --step-by-step my-project.ttl

# Test templates interactively
kgen template-test express-service.njk --data my-project.ttl
```

## Chapter 10: Next Steps

### Building Your Template Library

1. **Identify Common Patterns** - Look for recurring code structures
2. **Create Reusable Templates** - Build modular, configurable templates
3. **Establish Conventions** - Define naming and organization standards
4. **Version Control** - Manage template versions alongside code
5. **Documentation** - Document template usage and variables

### Enterprise Adoption

1. **Pilot Project** - Start with small, low-risk project
2. **Training Program** - Train development teams thoroughly
3. **Governance** - Establish standards and review processes
4. **Integration** - Connect with existing tools and workflows
5. **Scaling** - Roll out across multiple teams gradually

### Advanced Topics to Explore

- Custom RDF vocabularies and ontologies
- Complex SHACL constraints and functions
- Advanced template techniques
- Performance optimization strategies
- Integration with semantic web tools
- Custom KGEN extensions and plugins

## Summary

Congratulations! You've learned the fundamentals of KGEN:

✅ **RDF Modeling** - Create semantic models of your projects  
✅ **SHACL Validation** - Ensure data quality and consistency  
✅ **Template Creation** - Build reusable code generation templates  
✅ **Code Generation** - Transform models into working code  
✅ **Self-Hosting** - Demonstrate dogfooding approach  
✅ **Best Practices** - Follow enterprise-grade development patterns  
✅ **Advanced Features** - Leverage powerful KGEN capabilities  

### Key Benefits Realized

- **Consistency** - All code follows the same patterns and standards
- **Quality** - SHACL validation ensures correctness
- **Speed** - Generate complex applications in minutes
- **Maintainability** - Changes to models propagate automatically
- **Documentation** - Self-documenting systems with traceability
- **Validation** - Built-in testing and quality assurance

### Ready for Production?

You now have the knowledge to:
- Model complex software systems using RDF
- Create comprehensive validation rules with SHACL
- Build sophisticated code generation templates
- Implement self-hosting capabilities
- Follow enterprise best practices
- Integrate KGEN into existing workflows

**Next:** Attend the hands-on laboratory exercises to practice these skills with real-world scenarios.

---

*This getting started guide was generated by KGEN from the workshop.ttl RDF graph, demonstrating the self-hosting capabilities in action.*
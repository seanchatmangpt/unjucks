/**
 * Office/LaTeX Document Generation Tests
 * Tests generation of Word documents, PDFs, and LaTeX output
 */

import { describe, it, expect, beforeEach, afterEach, vi } from 'vitest';
import { readFileSync, writeFileSync, existsSync } from 'fs';
import { resolve } from 'path';
import { DocumentGenerator } from '../../src/documents/generator.js';
import { LatexProcessor } from '../../src/latex/processor.js';
import { OfficeProcessor } from '../../src/office/processor.js';

// Mock external dependencies
vi.mock('puppeteer', () => ({
  default: {
    launch: vi.fn().mockResolvedValue({
      newPage: vi.fn().mockResolvedValue({
        pdf: vi.fn().mockResolvedValue(Buffer.from('mock-pdf-content')),
        setContent: vi.fn(),
        close: vi.fn()
      }),
      close: vi.fn()
    })
  }
}));

vi.mock('officegen', () => ({
  default: vi.fn().mockImplementation((type) => ({
    createP: vi.fn().mockReturnValue({
      addText: vi.fn()
    }),
    generate: vi.fn().mockImplementation((output) => {
      output.end(Buffer.from('mock-docx-content'));
    })
  }))
}));

describe('Document Generation', () => {
  let docGenerator;
  let latexProcessor;
  let officeProcessor;
  let outputDir;
  let testData;

  beforeEach(() => {
    outputDir = testUtils.createTempDir();
    
    docGenerator = new DocumentGenerator({
      outputDir,
      enablePDF: true,
      enableDocx: true,
      enableLatex: true
    });
    
    latexProcessor = new LatexProcessor({
      compiler: 'pdflatex',
      packages: ['graphicx', 'hyperref', 'booktabs']
    });
    
    officeProcessor = new OfficeProcessor({
      defaultTemplate: 'professional',
      enableStyles: true
    });
    
    testData = {
      simpleData: {
        title: 'Test Document',
        author: 'KGEN Test Suite',
        content: 'This is a test document generated by KGEN.',
        sections: [
          {
            title: 'Introduction',
            content: 'This document demonstrates KGEN\'s document generation capabilities.'
          },
          {
            title: 'Data Analysis',
            content: 'The following data was extracted from RDF graphs:',
            data: [
              { name: 'John Doe', role: 'Engineer', email: 'john@example.com' },
              { name: 'Jane Smith', role: 'Designer', email: 'jane@example.com' }
            ]
          }
        ]
      },
      complexData: {
        title: 'Complex Knowledge Graph Analysis',
        metadata: {
          generated: '2024-01-01T00:00:00Z',
          version: '1.0.0',
          source: 'knowledge-graph.ttl'
        },
        summary: {
          totalEntities: 1500,
          totalRelations: 3200,
          avgConnectivity: 2.13
        },
        hierarchies: [
          {
            root: 'Organization',
            depth: 4,
            nodes: [
              { id: 'org1', label: 'TechCorp', level: 0, children: ['dept1', 'dept2'] },
              { id: 'dept1', label: 'Engineering', level: 1, children: ['team1'] },
              { id: 'team1', label: 'Backend Team', level: 2, children: [] }
            ]
          }
        ],
        statistics: {
          entityTypes: {
            'Person': 450,
            'Organization': 120,
            'Project': 200,
            'Skill': 180
          },
          relationTypes: {
            'worksFor': 450,
            'hasSkill': 800,
            'manages': 95,
            'collaboratesWith': 600
          }
        }
      }
    };
  });

  afterEach(() => {
    testUtils.cleanupTempDir(outputDir);
  });

  describe('LaTeX generation', () => {
    it('should generate basic LaTeX document', async () => {
      const template = {
        documentClass: 'article',
        packages: ['geometry', 'fancyhdr'],
        title: '{{title}}',
        author: '{{author}}',
        content: `
          \\section{Introduction}
          {{content}}
          
          \\section{Data}
          \\begin{itemize}
          {{#each sections}}
          \\item \\textbf{ {{title}} }: {{content}}
          {{/each}}
          \\end{itemize}
        `
      };
      
      const result = await latexProcessor.generate(testData.simpleData, template);
      
      expect(result.success).toBe(true);
      expect(result.latex).toContain('\\documentclass{article}');
      expect(result.latex).toContain('\\usepackage{geometry}');
      expect(result.latex).toContain('\\title{Test Document}');
      expect(result.latex).toContain('\\author{KGEN Test Suite}');
      expect(result.latex).toContain('\\section{Introduction}');
      expect(result.latex).toContain('\\begin{itemize}');
    });

    it('should handle complex data structures in LaTeX', async () => {
      const template = {
        documentClass: 'report',
        packages: ['booktabs', 'graphicx', 'pgfplots'],
        title: '{{title}}',
        content: `
          \\chapter{Summary}
          This report analyzes {{summary.totalEntities}} entities and {{summary.totalRelations}} relations.
          
          \\section{Entity Distribution}
          \\begin{table}[h]
          \\centering
          \\begin{tabular}{lr}
          \\toprule
          Entity Type & Count \\\\
          \\midrule
          {{#each statistics.entityTypes}}
          {{@key}} & {{this}} \\\\
          {{/each}}
          \\bottomrule
          \\end{tabular}
          \\caption{Entity type distribution}
          \\end{table}
        `
      };
      
      const result = await latexProcessor.generate(testData.complexData, template);
      
      expect(result.success).toBe(true);
      expect(result.latex).toContain('\\documentclass{report}');
      expect(result.latex).toContain('analyzes 1500 entities');
      expect(result.latex).toContain('\\begin{tabular}{lr}');
      expect(result.latex).toContain('Person & 450');
      expect(result.latex).toContain('Organization & 120');
    });

    it('should escape LaTeX special characters', async () => {
      const dangerousData = {
        title: 'Test & Debug $100 #hash %percent',
        content: 'Special chars: & $ # % _ { } ~ ^'
      };
      
      const template = {
        title: '{{title}}',
        content: '{{content}}'
      };
      
      const result = await latexProcessor.generate(dangerousData, template);
      
      expect(result.success).toBe(true);
      expect(result.latex).toContain('Test \\& Debug \\$100 \\#hash \\%percent');
      expect(result.latex).toContain('\\& \\$ \\# \\% \\_ \\{ \\} \\textasciitilde{} \\textasciicircum{}');
    });

    it('should compile LaTeX to PDF', async () => {
      const simpleTemplate = {
        documentClass: 'article',
        title: 'Test PDF Generation',
        content: 'This is a test PDF document.'
      };
      
      const result = await latexProcessor.generatePDF(testData.simpleData, simpleTemplate);
      
      expect(result.success).toBe(true);
      expect(result.pdfPath).toBeDefined();
      expect(existsSync(result.pdfPath)).toBe(true);
      expect(result.compilationLog).toContain('Output written');
    });

    it('should handle LaTeX compilation errors', async () => {
      const brokenTemplate = {
        documentClass: 'article',
        content: '\\invalidcommand{broken}'
      };
      
      const result = await latexProcessor.generatePDF(testData.simpleData, brokenTemplate);
      
      expect(result.success).toBe(false);
      expect(result.error).toBeDefined();
      expect(result.compilationLog).toContain('Error');
    });

    it('should support custom LaTeX packages', async () => {
      const templateWithPackages = {
        documentClass: 'article',
        packages: [
          'amsmath',
          'amsthm',
          'amssymb',
          { name: 'geometry', options: 'margin=1in' },
          { name: 'hyperref', options: 'colorlinks=true,linkcolor=blue' }
        ],
        content: `
          \\begin{theorem}
          This is a theorem using amsthm.
          \\end{theorem}
          
          \\begin{equation}
          E = mc^2
          \\end{equation}
        `
      };
      
      const result = await latexProcessor.generate({}, templateWithPackages);
      
      expect(result.success).toBe(true);
      expect(result.latex).toContain('\\usepackage{amsmath}');
      expect(result.latex).toContain('\\usepackage[margin=1in]{geometry}');
      expect(result.latex).toContain('\\usepackage[colorlinks=true,linkcolor=blue]{hyperref}');
      expect(result.latex).toContain('\\begin{theorem}');
      expect(result.latex).toContain('\\begin{equation}');
    });
  });

  describe('Office document generation', () => {
    it('should generate Word documents', async () => {
      const template = {
        title: '{{title}}',
        sections: [
          {
            heading: 'Overview',
            content: '{{content}}'
          },
          {
            heading: 'Team Members',
            content: 'table',
            data: '{{sections.1.data}}'
          }
        ]
      };
      
      const result = await officeProcessor.generateDocx(testData.simpleData, template);
      
      expect(result.success).toBe(true);
      expect(result.docxPath).toBeDefined();
      expect(existsSync(result.docxPath)).toBe(true);
      expect(result.metadata.title).toBe('Test Document');
    });

    it('should support document styling and formatting', async () => {
      const styledTemplate = {
        title: '{{title}}',
        styles: {
          title: {
            fontSize: 24,
            bold: true,
            color: '0066CC'
          },
          heading: {
            fontSize: 16,
            bold: true,
            color: '333333'
          },
          body: {
            fontSize: 12,
            fontFamily: 'Arial'
          }
        },
        sections: [
          {
            heading: 'Analysis Results',
            style: 'heading',
            content: 'The knowledge graph contains {{summary.totalEntities}} entities.'
          }
        ]
      };
      
      const result = await officeProcessor.generateDocx(testData.complexData, styledTemplate);
      
      expect(result.success).toBe(true);
      expect(result.stylesApplied).toContain('title');
      expect(result.stylesApplied).toContain('heading');
    });

    it('should generate tables from structured data', async () => {
      const tableTemplate = {
        title: 'Entity Statistics Report',
        sections: [
          {
            heading: 'Entity Distribution',
            content: 'table',
            tableData: {
              headers: ['Entity Type', 'Count', 'Percentage'],
              rows: `
                {{#each statistics.entityTypes}}
                ['{{@key}}', {{this}}, '{{percentage this ../summary.totalEntities}}%']
                {{/each}}
              `
            },
            tableStyle: {
              headerStyle: { bold: true, backgroundColor: 'CCCCCC' },
              borderStyle: 'single',
              alignment: 'center'
            }
          }
        ]
      };
      
      const result = await officeProcessor.generateDocx(testData.complexData, tableTemplate);
      
      expect(result.success).toBe(true);
      expect(result.tablesGenerated).toBe(1);
      expect(result.tableRows).toBe(4); // 4 entity types
    });

    it('should handle images and charts', async () => {
      const chartTemplate = {
        title: 'Knowledge Graph Visualization',
        sections: [
          {
            heading: 'Entity Distribution Chart',
            content: 'chart',
            chartData: {
              type: 'pie',
              data: '{{statistics.entityTypes}}',
              options: {
                title: 'Entity Types',
                colors: ['#FF6B6B', '#4ECDC4', '#45B7D1', '#FFA07A']
              }
            }
          },
          {
            heading: 'Graph Structure',
            content: 'image',
            imagePath: resolve(__TEST_FIXTURES__, 'images', 'sample-graph.png'),
            imageOptions: {
              width: 400,
              height: 300,
              caption: 'Knowledge graph visualization'
            }
          }
        ]
      };
      
      // Create mock image file
      const imageDir = resolve(__TEST_FIXTURES__, 'images');
      if (!existsSync(imageDir)) {
        mkdirSync(imageDir, { recursive: true });
      }
      writeFileSync(resolve(imageDir, 'sample-graph.png'), Buffer.from('mock-png-data'));
      
      const result = await officeProcessor.generateDocx(testData.complexData, chartTemplate);
      
      expect(result.success).toBe(true);
      expect(result.chartsGenerated).toBe(1);
      expect(result.imagesInserted).toBe(1);
    });
  });

  describe('PDF generation from HTML', () => {
    it('should convert HTML to PDF', async () => {
      const htmlTemplate = `
        <!DOCTYPE html>
        <html>
        <head>
          <title>{{title}}</title>
          <style>
            body { font-family: Arial, sans-serif; margin: 40px; }
            h1 { color: #333; border-bottom: 2px solid #0066CC; }
            .section { margin: 20px 0; }
            table { border-collapse: collapse; width: 100%; }
            th, td { border: 1px solid #ddd; padding: 8px; text-align: left; }
            th { background-color: #f2f2f2; }
          </style>
        </head>
        <body>
          <h1>{{title}}</h1>
          <p>Generated on {{metadata.generated}}</p>
          
          <div class="section">
            <h2>Summary</h2>
            <p>Total Entities: {{summary.totalEntities}}</p>
            <p>Total Relations: {{summary.totalRelations}}</p>
          </div>
          
          <div class="section">
            <h2>Entity Statistics</h2>
            <table>
              <tr><th>Type</th><th>Count</th></tr>
              {{#each statistics.entityTypes}}
              <tr><td>{{@key}}</td><td>{{this}}</td></tr>
              {{/each}}
            </table>
          </div>
        </body>
        </html>
      `;
      
      const result = await docGenerator.generatePDFFromHTML(testData.complexData, htmlTemplate);
      
      expect(result.success).toBe(true);
      expect(result.pdfPath).toBeDefined();
      expect(existsSync(result.pdfPath)).toBe(true);
      expect(result.pdfSize).toBeGreaterThan(0);
    });

    it('should support PDF generation options', async () => {
      const simpleHTML = `
        <html>
        <body>
          <h1>{{title}}</h1>
          <p>{{content}}</p>
        </body>
        </html>
      `;
      
      const pdfOptions = {
        format: 'A4',
        margin: {
          top: '1in',
          right: '1in',
          bottom: '1in',
          left: '1in'
        },
        printBackground: true,
        displayHeaderFooter: true,
        headerTemplate: '<div style="font-size: 10px; text-align: center; width: 100%;">{{title}}</div>',
        footerTemplate: '<div style="font-size: 10px; text-align: center; width: 100%;">Page <span class="pageNumber"></span> of <span class="totalPages"></span></div>'
      };
      
      const result = await docGenerator.generatePDFFromHTML(
        testData.simpleData, 
        simpleHTML, 
        pdfOptions
      );
      
      expect(result.success).toBe(true);
      expect(result.options.format).toBe('A4');
      expect(result.options.displayHeaderFooter).toBe(true);
    });
  });

  describe('multi-format generation', () => {
    it('should generate multiple document formats simultaneously', async () => {
      const multiTemplate = {
        title: '{{title}}',
        author: '{{author}}',
        content: '{{content}}',
        formats: ['latex', 'docx', 'pdf']
      };
      
      const result = await docGenerator.generateMultiFormat(
        testData.simpleData, 
        multiTemplate
      );
      
      expect(result.success).toBe(true);
      expect(result.formats).toHaveLength(3);
      
      const latexResult = result.formats.find(f => f.type === 'latex');
      const docxResult = result.formats.find(f => f.type === 'docx');
      const pdfResult = result.formats.find(f => f.type === 'pdf');
      
      expect(latexResult.success).toBe(true);
      expect(docxResult.success).toBe(true);
      expect(pdfResult.success).toBe(true);
      
      expect(existsSync(latexResult.path)).toBe(true);
      expect(existsSync(docxResult.path)).toBe(true);
      expect(existsSync(pdfResult.path)).toBe(true);
    });

    it('should handle partial failures in multi-format generation', async () => {
      // Mock LaTeX failure
      const originalGenerateLatex = latexProcessor.generate;
      latexProcessor.generate = vi.fn().mockResolvedValue({
        success: false,
        error: 'LaTeX compilation failed'
      });
      
      const multiTemplate = {
        title: 'Test Document',
        formats: ['latex', 'docx', 'pdf']
      };
      
      const result = await docGenerator.generateMultiFormat(
        testData.simpleData, 
        multiTemplate
      );
      
      expect(result.success).toBe(true); // Partial success
      expect(result.formats).toHaveLength(3);
      expect(result.successCount).toBe(2);
      expect(result.failureCount).toBe(1);
      
      const latexResult = result.formats.find(f => f.type === 'latex');
      expect(latexResult.success).toBe(false);
      
      // Restore original method
      latexProcessor.generate = originalGenerateLatex;
    });
  });

  describe('document validation', () => {
    it('should validate generated documents', async () => {
      const template = {
        title: '{{title}}',
        content: '{{content}}',
        validation: {
          requiredSections: ['title', 'content'],
          maxFileSize: '10MB',
          checkAccessibility: true
        }
      };
      
      const result = await docGenerator.generateDocx(testData.simpleData, template);
      
      expect(result.success).toBe(true);
      expect(result.validation.passed).toBe(true);
      expect(result.validation.issues).toHaveLength(0);
      expect(result.validation.accessibility.score).toBeGreaterThan(0.8);
    });

    it('should detect validation issues', async () => {
      const problematicTemplate = {
        title: '', // Empty title
        content: 'Content without proper structure',
        validation: {
          requiredSections: ['title', 'author', 'abstract'],
          minContentLength: 1000,
          checkStructure: true
        }
      };
      
      const result = await docGenerator.generateDocx(
        { content: 'Short content' }, 
        problematicTemplate
      );
      
      expect(result.success).toBe(true); // Document generated but has issues
      expect(result.validation.passed).toBe(false);
      expect(result.validation.issues.length).toBeGreaterThan(0);
      expect(result.validation.issues).toContainEqual(
        expect.objectContaining({
          type: 'missing_section',
          section: 'title'
        })
      );
    });
  });

  describe('performance', () => {
    it('should generate documents within reasonable time', async () => {
      const simpleTemplate = {
        title: 'Performance Test',
        content: 'Testing document generation performance'
      };
      
      const start = Date.now();
      const result = await docGenerator.generateDocx(testData.simpleData, simpleTemplate);
      const duration = Date.now() - start;
      
      expect(result.success).toBe(true);
      expect(duration).toBeLessThan(5000); // Should complete within 5 seconds
    });

    it('should handle large documents efficiently', async () => {
      const largeData = {
        title: 'Large Document Test',
        sections: Array.from({ length: 100 }, (_, i) => ({
          title: `Section ${i + 1}`,
          content: `This is section ${i + 1} with substantial content. `.repeat(50)
        }))
      };
      
      const largeTemplate = {
        title: '{{title}}',
        content: `
          {{#each sections}}
          \\section{ {{title}} }
          {{content}}
          {{/each}}
        `
      };
      
      const start = Date.now();
      const result = await latexProcessor.generate(largeData, largeTemplate);
      const duration = Date.now() - start;
      
      expect(result.success).toBe(true);
      expect(duration).toBeLessThan(10000); // Should handle large documents within 10 seconds
      expect(result.latex.length).toBeGreaterThan(10000); // Substantial output
    });
  });

  describe('error handling', () => {
    it('should handle template rendering errors', async () => {
      const brokenTemplate = {
        title: '{{invalid.nested.property}}',
        content: '{{#each nonexistent}}{{this}}{{/each}}'
      };
      
      const result = await docGenerator.generateDocx(testData.simpleData, brokenTemplate);
      
      expect(result.success).toBe(false);
      expect(result.error).toContain('Template rendering failed');
      expect(result.templateErrors).toBeDefined();
    });

    it('should handle file system errors gracefully', async () => {
      const readOnlyDir = resolve('/tmp/readonly-test-dir');
      
      // Mock file system error
      const originalGenerateDocx = officeProcessor.generateDocx;
      officeProcessor.generateDocx = vi.fn().mockRejectedValue(
        new Error('EACCES: permission denied')
      );
      
      const result = await docGenerator.generateDocx(
        testData.simpleData, 
        { title: 'Test' },
        { outputDir: readOnlyDir }
      );
      
      expect(result.success).toBe(false);
      expect(result.error).toContain('permission denied');
      
      // Restore original method
      officeProcessor.generateDocx = originalGenerateDocx;
    });
  });
});

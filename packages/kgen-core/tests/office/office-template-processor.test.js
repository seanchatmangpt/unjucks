/**\n * Tests for Office Template Processor\n * \n * Comprehensive test suite for the main Office template processing functionality\n * including template loading, variable extraction, processing, and validation.\n * \n * @module tests/office/office-template-processor.test\n */\n\nimport { describe, test, expect, beforeEach, afterEach } from 'vitest';\nimport { OfficeTemplateProcessor } from '../../src/office/office-template-processor.js';\nimport { DocumentType, VariableSyntax } from '../../src/office/core/types.js';\n\ndescribe('OfficeTemplateProcessor', () => {\n  let processor;\n\n  beforeEach(() => {\n    processor = new OfficeTemplateProcessor({\n      debug: false,\n      dryRun: true\n    });\n  });\n\n  afterEach(async () => {\n    if (processor) {\n      await processor.cleanup();\n    }\n  });\n\n  describe('Initialization', () => {\n    test('should initialize with default options', () => {\n      expect(processor).toBeDefined();\n      expect(processor.getSupportedTypes()).toContain(DocumentType.WORD);\n      expect(processor.getSupportedTypes()).toContain(DocumentType.EXCEL);\n      expect(processor.getSupportedTypes()).toContain(DocumentType.POWERPOINT);\n    });\n\n    test('should initialize with custom options', () => {\n      const customProcessor = new OfficeTemplateProcessor({\n        syntax: VariableSyntax.MUSTACHE,\n        debug: true,\n        validation: {\n          enabled: false\n        }\n      });\n\n      const options = customProcessor.getOptions();\n      expect(options.syntax).toBe(VariableSyntax.MUSTACHE);\n      expect(options.debug).toBe(true);\n      expect(options.validation.enabled).toBe(false);\n    });\n  });\n\n  describe('Processor Management', () => {\n    test('should get processor for supported document type', () => {\n      const wordProcessor = processor.getProcessorForType(DocumentType.WORD);\n      expect(wordProcessor).toBeDefined();\n      expect(wordProcessor.getSupportedType()).toBe(DocumentType.WORD);\n    });\n\n    test('should return null for unsupported document type', () => {\n      const unknownProcessor = processor.getProcessorForType('unknown');\n      expect(unknownProcessor).toBeNull();\n    });\n\n    test('should register custom processor', () => {\n      const mockProcessor = {\n        getSupportedType: () => 'custom',\n        getSupportedExtensions: () => ['.custom'],\n        process: async () => ({ success: true })\n      };\n\n      processor.registerProcessor('custom', mockProcessor);\n      const registeredProcessor = processor.getProcessorForType('custom');\n      expect(registeredProcessor).toBe(mockProcessor);\n    });\n\n    test('should unregister processor', () => {\n      processor.unregisterProcessor(DocumentType.WORD);\n      const wordProcessor = processor.getProcessorForType(DocumentType.WORD);\n      expect(wordProcessor).toBeNull();\n    });\n  });\n\n  describe('Options Management', () => {\n    test('should update options', () => {\n      const newOptions = {\n        syntax: VariableSyntax.HANDLEBARS,\n        debug: true\n      };\n\n      processor.updateOptions(newOptions);\n      const updatedOptions = processor.getOptions();\n      \n      expect(updatedOptions.syntax).toBe(VariableSyntax.HANDLEBARS);\n      expect(updatedOptions.debug).toBe(true);\n    });\n\n    test('should preserve existing options when updating', () => {\n      const originalValidation = processor.getOptions().validation;\n      \n      processor.updateOptions({ debug: true });\n      const updatedOptions = processor.getOptions();\n      \n      expect(updatedOptions.debug).toBe(true);\n      expect(updatedOptions.validation).toEqual(originalValidation);\n    });\n  });\n\n  describe('Statistics', () => {\n    test('should return processing statistics', () => {\n      const stats = processor.getStatistics();\n      \n      expect(stats).toHaveProperty('totalProcessors');\n      expect(stats).toHaveProperty('supportedTypes');\n      expect(stats).toHaveProperty('processorStats');\n      expect(stats.totalProcessors).toBe(3); // Word, Excel, PowerPoint\n    });\n\n    test('should reset statistics', () => {\n      processor.resetStatistics();\n      const stats = processor.getStatistics();\n      \n      // Verify that statistics have been reset\n      expect(stats.processorStats).toBeDefined();\n    });\n  });\n\n  describe('Template Processing', () => {\n    // Note: These tests would require actual template files in a real implementation\n    // For now, they test the error handling and basic flow\n\n    test('should handle unsupported file format', async () => {\n      const result = await processor.process('test.unsupported', {});\n      \n      expect(result.success).toBe(false);\n      expect(result.validation.errors).toHaveLength(1);\n      expect(result.validation.errors[0].message).toContain('Unsupported document format');\n    });\n\n    test('should handle processing errors gracefully', async () => {\n      const result = await processor.process('/nonexistent/file.docx', {});\n      \n      expect(result.success).toBe(false);\n      expect(result.validation).toBeDefined();\n      expect(result.stats).toBeDefined();\n    });\n  });\n\n  describe('Batch Processing', () => {\n    test('should process empty template array', async () => {\n      const result = await processor.batchProcess({\n        templates: [],\n        data: []\n      });\n\n      expect(result.total).toBe(0);\n      expect(result.completed).toBe(0);\n      expect(result.failed).toBe(0);\n      expect(result.results).toHaveLength(0);\n    });\n\n    test('should handle batch processing configuration', async () => {\n      const config = {\n        templates: ['template1.docx', 'template2.xlsx'],\n        data: [{ name: 'Test1' }, { name: 'Test2' }],\n        outputDir: './output',\n        parallel: false\n      };\n\n      const result = await processor.batchProcess(config);\n      \n      expect(result.total).toBe(2);\n      expect(result.results).toHaveLength(2);\n    });\n  });\n\n  describe('Validation', () => {\n    test('should validate template data structure', async () => {\n      // This would require a real template file in practice\n      try {\n        await processor.validateData({}, '/nonexistent/template.docx');\n      } catch (error) {\n        expect(error.message).toBeDefined();\n      }\n    });\n\n    test('should validate template structure', async () => {\n      // This would require a real template file in practice\n      try {\n        await processor.validateTemplate('/nonexistent/template.docx');\n      } catch (error) {\n        expect(error.message).toBeDefined();\n      }\n    });\n  });\n\n  describe('Template Discovery', () => {\n    test('should discover templates in directory', async () => {\n      // This test would require actual template files\n      const result = await processor.discoverTemplates('./test-templates', {\n        recursive: true,\n        extensions: ['.docx', '.xlsx']\n      });\n\n      expect(result).toHaveProperty('templates');\n      expect(result).toHaveProperty('stats');\n      expect(result).toHaveProperty('errors');\n      expect(Array.isArray(result.templates)).toBe(true);\n    });\n\n    test('should handle discovery options', async () => {\n      const options = {\n        recursive: false,\n        extensions: ['.docx'],\n        excludePatterns: ['*temp*']\n      };\n\n      const result = await processor.discoverTemplates('./test-templates', options);\n      expect(result.stats.directoriesSearched).toBeGreaterThanOrEqual(0);\n    });\n  });\n\n  describe('Event Handling', () => {\n    test('should emit events during processing', (done) => {\n      let eventsReceived = 0;\n\n      processor.on('templateProcessed', (data) => {\n        expect(data).toHaveProperty('templatePath');\n        expect(data).toHaveProperty('format');\n        expect(data).toHaveProperty('success');\n        eventsReceived++;\n      });\n\n      processor.on('processingError', (data) => {\n        expect(data).toHaveProperty('templatePath');\n        expect(data).toHaveProperty('error');\n        eventsReceived++;\n      });\n\n      // Process a non-existent file to trigger error event\n      processor.process('/nonexistent/file.docx', {}).then(() => {\n        // Give events time to be emitted\n        setTimeout(() => {\n          expect(eventsReceived).toBeGreaterThan(0);\n          done();\n        }, 10);\n      });\n    });\n  });\n\n  describe('Cleanup', () => {\n    test('should cleanup resources', async () => {\n      await processor.cleanup();\n      \n      // After cleanup, processors should be cleared\n      expect(processor.getSupportedTypes()).toHaveLength(0);\n    });\n  });\n});"
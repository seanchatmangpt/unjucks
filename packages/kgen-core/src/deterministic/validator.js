/**
 * KGEN Core Byte-Identical Validation System
 * 
 * Provides comprehensive validation for deterministic rendering with:
 * - Multi-iteration SHA-256 hash validation (up to 1000 iterations)
 * - Cross-platform consistency verification
 * - Reproducibility testing with different environments
 * - Performance benchmarking for deterministic operations
 * - Comprehensive reporting and analysis
 */

import crypto from 'crypto';
import fs from 'fs/promises';
import path from 'path';
import { performance } from 'perf_hooks';
import { DeterministicRenderer } from './renderer.js';
import { validateDeterministicRandom } from './random.js';
import { validateTimeConfiguration } from './time.js';

/**
 * Comprehensive deterministic validation system
 */
export class DeterministicValidator {
  constructor(options = {}) {
    this.options = {
      // Validation configuration
      defaultIterations: options.defaultIterations || 10,
      maxIterations: options.maxIterations || 1000,
      strictMode: options.strictMode !== false,
      enableProfiling: options.enableProfiling !== false,
      
      // Output configuration
      reportDir: options.reportDir || './validation-reports',
      saveReports: options.saveReports !== false,
      timestampReports: options.timestampReports !== false,
      
      // Performance settings
      warmupIterations: options.warmupIterations || 2,
      timeoutPerIteration: options.timeoutPerIteration || 30000,
      
      ...options
    };
    
    this.stats = {
      totalValidations: 0,
      successfulValidations: 0,
      failedValidations: 0,
      totalIterations: 0,
      totalTime: 0
    };
    
    this.renderer = new DeterministicRenderer({
      validateDeterminism: false // We'll handle validation ourselves
    });
  }
  
  /**
   * Validate deterministic rendering with multiple iterations
   */
  async validateDeterministicRendering(templatePath, context = {}, iterations = this.options.defaultIterations) {
    const validationId = this._generateValidationId();
    const startTime = performance.now();
    
    try {
      this.stats.totalValidations++;
      iterations = Math.min(iterations, this.options.maxIterations);
      
      const results = [];
      const hashes = new Set();
      const sizes = new Set();
      const renderTimes = [];
      
      // Warmup iterations (not counted in results)
      if (this.options.warmupIterations > 0) {
        for (let i = 0; i < this.options.warmupIterations; i++) {
          await this.renderer.render(templatePath, context);
        }
        this.renderer.clearCache();
      }
      
      // Main validation iterations
      for (let i = 0; i < iterations; i++) {
        const iterStartTime = performance.now();
        
        // Clear cache to force fresh render
        this.renderer.clearCache();
        
        // Render template
        const result = await Promise.race([
          this.renderer.render(templatePath, context),
          new Promise((_, reject) => 
            setTimeout(() => reject(new Error('Iteration timeout')), this.options.timeoutPerIteration)
          )
        ]);
        
        if (result.error) {
          throw new Error(`Render failed at iteration ${i + 1}: ${result.error}`);\n        }\n        \n        const iterEndTime = performance.now();\n        const iterTime = iterEndTime - iterStartTime;\n        \n        const hash = crypto.createHash('sha256').update(result.content).digest('hex');\n        \n        results.push({\n          iteration: i + 1,\n          contentHash: hash,\n          contentLength: result.content.length,\n          renderTime: iterTime,\n          templatePath: result.templatePath,\n          metadata: result.metadata\n        });\n        \n        hashes.add(hash);\n        sizes.add(result.content.length);\n        renderTimes.push(iterTime);\n        \n        // Progress logging for long validations\n        if (iterations >= 100 && (i + 1) % 50 === 0) {\n          console.log(`Validation progress: ${i + 1}/${iterations} iterations completed`);\n        }\n      }\n      \n      const endTime = performance.now();\n      const totalTime = endTime - startTime;\n      \n      // Calculate statistics\n      const isDeterministic = hashes.size === 1 && sizes.size === 1;\n      const avgRenderTime = renderTimes.reduce((sum, time) => sum + time, 0) / renderTimes.length;\n      const minRenderTime = Math.min(...renderTimes);\n      const maxRenderTime = Math.max(...renderTimes);\n      \n      // Calculate standard deviation\n      const variance = renderTimes.reduce((sum, time) => sum + Math.pow(time - avgRenderTime, 2), 0) / renderTimes.length;\n      const stdDev = Math.sqrt(variance);\n      \n      const validation = {\n        validationId,\n        success: true,\n        deterministic: isDeterministic,\n        templatePath,\n        context: this._sanitizeContext(context),\n        \n        // Results summary\n        iterations,\n        uniqueHashes: hashes.size,\n        uniqueSizes: sizes.size,\n        contentHash: isDeterministic ? Array.from(hashes)[0] : null,\n        contentLength: isDeterministic ? Array.from(sizes)[0] : null,\n        \n        // Performance metrics\n        performance: {\n          totalTime,\n          averageRenderTime: avgRenderTime,\n          minRenderTime,\n          maxRenderTime,\n          standardDeviation: stdDev,\n          rendersPerSecond: (iterations / (totalTime / 1000)).toFixed(2)\n        },\n        \n        // Detailed results (limited for large validation sets)\n        results: iterations <= 20 ? results : [\n          ...results.slice(0, 10), \n          { truncated: true, totalResults: iterations },\n          ...results.slice(-5)\n        ],\n        \n        // Validation metadata\n        validation: {\n          timestamp: new Date().toISOString(),\n          nodeVersion: process.version,\n          platform: process.platform,\n          arch: process.arch,\n          warmupIterations: this.options.warmupIterations\n        },\n        \n        // Analysis\n        analysis: this._analyzeValidationResults(results, hashes, sizes, renderTimes),\n        \n        // Pass/fail message\n        message: isDeterministic \n          ? `✅ DETERMINISTIC: All ${iterations} iterations produced identical SHA-256 hash: ${Array.from(hashes)[0]}`\n          : `❌ NON-DETERMINISTIC: Found ${hashes.size} different hashes across ${iterations} iterations`\n      };\n      \n      // Update statistics\n      this.stats.totalIterations += iterations;\n      this.stats.totalTime += totalTime;\n      \n      if (isDeterministic) {\n        this.stats.successfulValidations++;\n      } else {\n        this.stats.failedValidations++;\n      }\n      \n      // Save report if configured\n      if (this.options.saveReports) {\n        await this._saveValidationReport(validation);\n      }\n      \n      return validation;\n      \n    } catch (error) {\n      const endTime = performance.now();\n      const totalTime = endTime - startTime;\n      \n      this.stats.failedValidations++;\n      this.stats.totalTime += totalTime;\n      \n      const errorValidation = {\n        validationId,\n        success: false,\n        error: error.message,\n        templatePath,\n        iterations,\n        performance: {\n          totalTime\n        },\n        validation: {\n          timestamp: new Date().toISOString(),\n          nodeVersion: process.version,\n          platform: process.platform\n        },\n        message: `❌ VALIDATION FAILED: ${error.message}`\n      };\n      \n      if (this.options.saveReports) {\n        await this._saveValidationReport(errorValidation);\n      }\n      \n      if (this.options.strictMode) {\n        throw error;\n      }\n      \n      return errorValidation;\n    }\n  }\n  \n  /**\n   * Run comprehensive system validation\n   */\n  async validateSystem(options = {}) {\n    const systemValidation = {\n      timestamp: new Date().toISOString(),\n      system: {\n        nodeVersion: process.version,\n        platform: process.platform,\n        arch: process.arch,\n        cpus: require('os').cpus().length,\n        memory: Math.round(require('os').totalmem() / (1024 * 1024 * 1024)) + 'GB'\n      },\n      validations: {},\n      overall: {\n        success: true,\n        issues: [],\n        warnings: []\n      }\n    };\n    \n    try {\n      // Validate time configuration\n      const timeValidation = validateTimeConfiguration();\n      systemValidation.validations.time = timeValidation;\n      \n      if (!timeValidation.valid) {\n        systemValidation.overall.issues.push(...timeValidation.issues);\n      }\n      \n      // Validate random number generation\n      const randomValidation = validateDeterministicRandom(100);\n      systemValidation.validations.random = randomValidation;\n      \n      if (!randomValidation.deterministic) {\n        systemValidation.overall.issues.push('Deterministic random generation failed validation');\n      }\n      \n      // Validate renderer basic functionality\n      const rendererValidation = await this._validateRendererBasics();\n      systemValidation.validations.renderer = rendererValidation;\n      \n      if (!rendererValidation.success) {\n        systemValidation.overall.issues.push(rendererValidation.error);\n      }\n      \n      // Overall system health\n      systemValidation.overall.success = systemValidation.overall.issues.length === 0;\n      systemValidation.overall.score = Math.max(0, 100 - (systemValidation.overall.issues.length * 20 + systemValidation.overall.warnings.length * 5));\n      \n    } catch (error) {\n      systemValidation.overall.success = false;\n      systemValidation.overall.error = error.message;\n    }\n    \n    return systemValidation;\n  }\n  \n  /**\n   * Benchmark deterministic rendering performance\n   */\n  async benchmarkPerformance(templatePath, context = {}, options = {}) {\n    const iterations = options.iterations || 50;\n    const warmup = options.warmup || 5;\n    \n    // Warmup\n    for (let i = 0; i < warmup; i++) {\n      await this.renderer.render(templatePath, context);\n      this.renderer.clearCache();\n    }\n    \n    // Benchmark\n    const times = [];\n    const startTime = performance.now();\n    \n    for (let i = 0; i < iterations; i++) {\n      this.renderer.clearCache();\n      const iterStart = performance.now();\n      \n      await this.renderer.render(templatePath, context);\n      \n      const iterEnd = performance.now();\n      times.push(iterEnd - iterStart);\n    }\n    \n    const endTime = performance.now();\n    const totalTime = endTime - startTime;\n    \n    const sortedTimes = [...times].sort((a, b) => a - b);\n    \n    return {\n      iterations,\n      totalTime,\n      averageTime: times.reduce((sum, time) => sum + time, 0) / times.length,\n      medianTime: sortedTimes[Math.floor(sortedTimes.length / 2)],\n      minTime: Math.min(...times),\n      maxTime: Math.max(...times),\n      p95Time: sortedTimes[Math.floor(sortedTimes.length * 0.95)],\n      p99Time: sortedTimes[Math.floor(sortedTimes.length * 0.99)],\n      rendersPerSecond: iterations / (totalTime / 1000),\n      standardDeviation: Math.sqrt(\n        times.reduce((sum, time) => {\n          const mean = times.reduce((s, t) => s + t, 0) / times.length;\n          return sum + Math.pow(time - mean, 2);\n        }, 0) / times.length\n      )\n    };\n  }\n  \n  /**\n   * Validate cross-platform consistency (if environments are available)\n   */\n  async validateCrossPlatform(templatePath, context = {}, platforms = []) {\n    // This would typically run in different environments\n    // For now, we simulate by validating with different settings\n    \n    const results = [];\n    const baselineResult = await this.validateDeterministicRendering(templatePath, context, 5);\n    \n    results.push({\n      platform: 'baseline',\n      result: baselineResult\n    });\n    \n    // Test with different line endings simulation\n    const modifiedContext = {\n      ...context,\n      __platform_test: 'windows-line-endings'\n    };\n    \n    const windowsResult = await this.validateDeterministicRendering(templatePath, modifiedContext, 5);\n    results.push({\n      platform: 'windows-simulation',\n      result: windowsResult\n    });\n    \n    // Analyze cross-platform consistency\n    const hashes = results.map(r => r.result.contentHash).filter(Boolean);\n    const consistent = new Set(hashes).size <= 1;\n    \n    return {\n      consistent,\n      results,\n      analysis: {\n        uniqueHashes: new Set(hashes).size,\n        allDeterministic: results.every(r => r.result.deterministic),\n        message: consistent \n          ? '✅ Cross-platform consistency validated'\n          : '❌ Cross-platform inconsistency detected'\n      }\n    };\n  }\n  \n  // Private helper methods\n  \n  _generateValidationId() {\n    const timestamp = Date.now();\n    const random = Math.random().toString(36).substring(2, 8);\n    return `val-${timestamp}-${random}`;\n  }\n  \n  _sanitizeContext(context) {\n    // Remove functions and other non-serializable items\n    const sanitized = {};\n    \n    for (const [key, value] of Object.entries(context)) {\n      if (typeof value !== 'function' && typeof value !== 'undefined') {\n        if (typeof value === 'object' && value !== null) {\n          try {\n            sanitized[key] = JSON.parse(JSON.stringify(value));\n          } catch {\n            sanitized[key] = '[Complex Object]';\n          }\n        } else {\n          sanitized[key] = value;\n        }\n      }\n    }\n    \n    return sanitized;\n  }\n  \n  _analyzeValidationResults(results, hashes, sizes, renderTimes) {\n    const analysis = {\n      consistency: {\n        contentHash: hashes.size === 1,\n        contentSize: sizes.size === 1,\n        renderingStability: this._calculateStability(renderTimes)\n      },\n      patterns: {\n        hashDistribution: Array.from(hashes).map(hash => ({\n          hash,\n          count: results.filter(r => r.contentHash === hash).length,\n          percentage: (results.filter(r => r.contentHash === hash).length / results.length * 100).toFixed(2)\n        })),\n        sizeDistribution: Array.from(sizes).map(size => ({\n          size,\n          count: results.filter(r => r.contentLength === size).length,\n          percentage: (results.filter(r => r.contentLength === size).length / results.length * 100).toFixed(2)\n        }))\n      },\n      recommendations: []\n    };\n    \n    // Generate recommendations\n    if (hashes.size > 1) {\n      analysis.recommendations.push('Multiple content hashes detected - check for non-deterministic template elements');\n    }\n    \n    if (sizes.size > 1) {\n      analysis.recommendations.push('Multiple content sizes detected - verify template context consistency');\n    }\n    \n    const stability = analysis.consistency.renderingStability;\n    if (stability < 0.9) {\n      analysis.recommendations.push('High render time variance detected - consider system resource optimization');\n    }\n    \n    return analysis;\n  }\n  \n  _calculateStability(times) {\n    if (times.length < 2) return 1;\n    \n    const mean = times.reduce((sum, time) => sum + time, 0) / times.length;\n    const variance = times.reduce((sum, time) => sum + Math.pow(time - mean, 2), 0) / times.length;\n    const coefficientOfVariation = Math.sqrt(variance) / mean;\n    \n    // Convert to stability score (0-1, where 1 is most stable)\n    return Math.max(0, 1 - coefficientOfVariation);\n  }\n  \n  async _validateRendererBasics() {\n    try {\n      // Create a minimal test template\n      const testTemplate = 'Hello {{ name }}!';\n      const testContext = { name: 'World' };\n      \n      // Test basic rendering\n      this.renderer.environment.renderString(testTemplate, testContext);\n      \n      return {\n        success: true,\n        message: 'Renderer basic functionality validated'\n      };\n      \n    } catch (error) {\n      return {\n        success: false,\n        error: `Renderer validation failed: ${error.message}`\n      };\n    }\n  }\n  \n  async _saveValidationReport(validation) {\n    try {\n      await fs.mkdir(this.options.reportDir, { recursive: true });\n      \n      const filename = this.options.timestampReports \n        ? `validation-${validation.validationId}.json`\n        : `validation-report.json`;\n      \n      const reportPath = path.join(this.options.reportDir, filename);\n      \n      await fs.writeFile(\n        reportPath, \n        JSON.stringify(validation, null, 2),\n        'utf-8'\n      );\n      \n      // Also create a markdown summary\n      const mdPath = reportPath.replace('.json', '.md');\n      const markdown = this._generateMarkdownReport(validation);\n      await fs.writeFile(mdPath, markdown, 'utf-8');\n      \n    } catch (error) {\n      console.warn(`Failed to save validation report: ${error.message}`);\n    }\n  }\n  \n  _generateMarkdownReport(validation) {\n    const { success, deterministic, iterations, uniqueHashes, performance, message } = validation;\n    \n    return `# KGEN Deterministic Validation Report\n\n## Summary\n\n- **Status**: ${success ? (deterministic ? '✅ PASS' : '❌ FAIL') : '❌ ERROR'}\n- **Template**: ${validation.templatePath || 'N/A'}\n- **Iterations**: ${iterations || 'N/A'}\n- **Unique Hashes**: ${uniqueHashes || 'N/A'}\n- **Timestamp**: ${validation.validation?.timestamp}\n\n## Result\n\n${message}\n\n${validation.contentHash ? `**Content Hash**: \\`${validation.contentHash}\\`` : ''}\n\n## Performance\n\n${performance ? `\n- **Total Time**: ${performance.totalTime?.toFixed(2)}ms\n- **Average Render Time**: ${performance.averageRenderTime?.toFixed(2)}ms\n- **Min/Max Time**: ${performance.minRenderTime?.toFixed(2)}ms / ${performance.maxRenderTime?.toFixed(2)}ms\n- **Standard Deviation**: ${performance.standardDeviation?.toFixed(2)}ms\n- **Renders/Second**: ${performance.rendersPerSecond}\n` : 'N/A'}\n\n## System Information\n\n- **Node.js**: ${validation.validation?.nodeVersion}\n- **Platform**: ${validation.validation?.platform}\n- **Architecture**: ${validation.validation?.arch}\n\n${validation.analysis?.recommendations?.length ? `\n## Recommendations\n\n${validation.analysis.recommendations.map(rec => `- ${rec}`).join('\\n')}\n` : ''}\n\n---\n*Report generated by KGEN Deterministic Validator*\n`;\n  }\n  \n  /**\n   * Get comprehensive validation statistics\n   */\n  getStats() {\n    return {\n      ...this.stats,\n      successRate: this.stats.totalValidations > 0 \n        ? (this.stats.successfulValidations / this.stats.totalValidations * 100).toFixed(2) + '%'\n        : '0%',\n      averageTime: this.stats.totalValidations > 0 \n        ? (this.stats.totalTime / this.stats.totalValidations).toFixed(2) + 'ms'\n        : '0ms',\n      averageIterationsPerValidation: this.stats.totalValidations > 0\n        ? (this.stats.totalIterations / this.stats.totalValidations).toFixed(1)\n        : '0'\n    };\n  }\n  \n  /**\n   * Reset validation statistics\n   */\n  resetStats() {\n    this.stats = {\n      totalValidations: 0,\n      successfulValidations: 0,\n      failedValidations: 0,\n      totalIterations: 0,\n      totalTime: 0\n    };\n  }\n}\n\n/**\n * Factory function for creating validator\n */\nexport function createDeterministicValidator(options = {}) {\n  return new DeterministicValidator(options);\n}\n\n/**\n * Quick validation function - validates with 10 iterations by default\n */\nexport async function validateDeterministic(templatePath, context = {}, iterations = 10) {\n  const validator = new DeterministicValidator();\n  return await validator.validateDeterministicRendering(templatePath, context, iterations);\n}\n\n/**\n * Comprehensive validation - runs system check + deterministic validation\n */\nexport async function validateComprehensive(templatePath, context = {}, options = {}) {\n  const validator = new DeterministicValidator(options);\n  \n  const results = {\n    system: await validator.validateSystem(),\n    rendering: await validator.validateDeterministicRendering(\n      templatePath, \n      context, \n      options.iterations || 25\n    ),\n    performance: await validator.benchmarkPerformance(\n      templatePath, \n      context, \n      { iterations: options.benchmarkIterations || 20 }\n    )\n  };\n  \n  results.overall = {\n    success: results.system.overall.success && results.rendering.success && results.rendering.deterministic,\n    score: Math.min(\n      results.system.overall.score || 0,\n      results.rendering.deterministic ? 100 : 0\n    ),\n    message: results.overall.success \n      ? '✅ Comprehensive validation passed - system is deterministic'\n      : '❌ Comprehensive validation failed - check individual results'\n  };\n  \n  return results;\n}\n\nexport default DeterministicValidator;"
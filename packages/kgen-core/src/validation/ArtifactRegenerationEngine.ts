/**\n * Artifact Regeneration Engine\n * Regenerates artifacts from attestation data and templates\n */\n\nimport { readFileSync, writeFileSync, existsSync, mkdirSync } from 'fs';\nimport { resolve, dirname } from 'path';\nimport { createHash } from 'crypto';\nimport { EventEmitter } from 'events';\nimport consola from 'consola';\nimport { render } from 'nunjucks';\nimport { Parser, Store } from 'n3';\n\nexport interface RegenerationOptions {\n  mode?: 'memory' | 'disk' | 'hybrid';\n  overwrite?: boolean;\n  validateOutput?: boolean;\n  enableBackup?: boolean;\n  templateBasePath?: string;\n  outputBasePath?: string;\n  timeout?: number;\n  dryRun?: boolean;\n}\n\nexport interface RegenerationResult {\n  success: boolean;\n  artifactPath: string;\n  outputHash?: string;\n  outputSize?: number;\n  matchesExpected?: boolean;\n  validationResults?: {\n    syntax: boolean;\n    semantic: boolean;\n    attestation: boolean;\n  };\n  regenerationTime: number;\n  error?: string;\n  warnings?: string[];\n  backupPath?: string;\n}\n\nexport interface RegenerationContext {\n  variables: Record<string, unknown>;\n  sourceGraph: Record<string, unknown>;\n  templatePath: string;\n  templateHash: string;\n  outputPath: string;\n  expectedHash: string;\n  expectedSize: number;\n}\n\nexport class ArtifactRegenerationEngine extends EventEmitter {\n  private config: Required<RegenerationOptions>;\n  private stats: {\n    regenerationsAttempted: number;\n    regenerationsSucceeded: number;\n    regenerationsFailed: number;\n    averageRegenerationTime: number;\n    totalRegenerationTime: number;\n  };\n  private templateCache: Map<string, { content: string; hash: string; lastModified: number }>;\n  private activeRegenerations: Map<string, Promise<RegenerationResult>>;\n\n  constructor(options: RegenerationOptions = {}) {\n    super();\n    \n    this.config = {\n      mode: 'memory',\n      overwrite: false,\n      validateOutput: true,\n      enableBackup: true,\n      templateBasePath: process.cwd(),\n      outputBasePath: process.cwd(),\n      timeout: 30000, // 30 seconds\n      dryRun: false,\n      ...options\n    };\n\n    this.stats = {\n      regenerationsAttempted: 0,\n      regenerationsSucceeded: 0,\n      regenerationsFailed: 0,\n      averageRegenerationTime: 0,\n      totalRegenerationTime: 0\n    };\n\n    this.templateCache = new Map();\n    this.activeRegenerations = new Map();\n  }\n\n  /**\n   * Regenerate artifact from attestation data\n   */\n  async regenerateFromAttestation(\n    attestationPath: string,\n    options: Partial<RegenerationOptions> = {}\n  ): Promise<RegenerationResult> {\n    const startTime = Date.now();\n    const mergedOptions = { ...this.config, ...options };\n    \n    const result: RegenerationResult = {\n      success: false,\n      artifactPath: '',\n      regenerationTime: 0,\n      warnings: []\n    };\n\n    try {\n      this.stats.regenerationsAttempted++;\n      \n      // Load attestation data\n      const attestation = await this.loadAttestation(attestationPath);\n      if (!attestation) {\n        throw new Error('Could not load attestation data');\n      }\n\n      // Validate attestation completeness\n      const validationResult = this.validateAttestationForRegeneration(attestation);\n      if (!validationResult.valid) {\n        throw new Error(`Incomplete attestation: ${validationResult.missing.join(', ')}`);\n      }\n\n      // Extract regeneration context\n      const context = this.extractRegenerationContext(attestation);\n      result.artifactPath = context.outputPath;\n\n      // Check if artifact already exists and handle accordingly\n      if (existsSync(context.outputPath) && !mergedOptions.overwrite) {\n        if (mergedOptions.enableBackup) {\n          result.backupPath = await this.createBackup(context.outputPath);\n          result.warnings?.push(`Backup created at ${result.backupPath}`);\n        } else {\n          throw new Error('Artifact exists and overwrite is disabled');\n        }\n      }\n\n      // Perform regeneration based on mode\n      const regeneratedContent = await this.performRegeneration(context, mergedOptions);\n      \n      // Validate regenerated content\n      if (mergedOptions.validateOutput) {\n        result.validationResults = await this.validateRegeneratedContent(\n          regeneratedContent,\n          context,\n          attestation\n        );\n        \n        if (!result.validationResults.syntax) {\n          result.warnings?.push('Generated content has syntax issues');\n        }\n      }\n\n      // Calculate output metrics\n      result.outputHash = createHash('sha256').update(regeneratedContent).digest('hex');\n      result.outputSize = Buffer.byteLength(regeneratedContent, 'utf8');\n      result.matchesExpected = result.outputHash === context.expectedHash;\n      \n      if (!result.matchesExpected) {\n        result.warnings?.push('Generated content hash does not match expected hash');\n      }\n\n      // Write output if not dry run\n      if (!mergedOptions.dryRun) {\n        await this.writeRegeneratedArtifact(context.outputPath, regeneratedContent);\n      }\n\n      result.success = true;\n      this.stats.regenerationsSucceeded++;\n      \n      consola.success(`\\u2705 Successfully regenerated: ${context.outputPath}`);\n      this.emit('regeneration-complete', {\n        path: context.outputPath,\n        success: true,\n        matchesExpected: result.matchesExpected,\n        time: Date.now() - startTime\n      });\n\n    } catch (error) {\n      result.error = error.message;\n      this.stats.regenerationsFailed++;\n      \n      consola.error(`\\u274c Regeneration failed for ${attestationPath}: ${error.message}`);\n      this.emit('regeneration-error', {\n        path: attestationPath,\n        error: error.message,\n        time: Date.now() - startTime\n      });\n    } finally {\n      result.regenerationTime = Date.now() - startTime;\n      this.updateStats(result.regenerationTime);\n    }\n\n    return result;\n  }\n\n  /**\n   * Batch regenerate multiple artifacts\n   */\n  async regenerateBatch(\n    attestationPaths: string[],\n    options: Partial<RegenerationOptions> = {}\n  ): Promise<RegenerationResult[]> {\n    const results: RegenerationResult[] = [];\n    const concurrency = 3; // Limit concurrent regenerations\n    \n    consola.info(`\\ud83d\\udd04 Starting batch regeneration of ${attestationPaths.length} artifacts`);\n    \n    // Process in batches to avoid overwhelming the system\n    for (let i = 0; i < attestationPaths.length; i += concurrency) {\n      const batch = attestationPaths.slice(i, i + concurrency);\n      \n      const batchPromises = batch.map(async (path) => {\n        try {\n          return await this.regenerateFromAttestation(path, options);\n        } catch (error) {\n          return {\n            success: false,\n            artifactPath: path,\n            regenerationTime: 0,\n            error: error.message\n          };\n        }\n      });\n      \n      const batchResults = await Promise.all(batchPromises);\n      results.push(...batchResults);\n      \n      // Progress reporting\n      const completed = Math.min(i + concurrency, attestationPaths.length);\n      consola.info(`\\ud83d\\udcc8 Progress: ${completed}/${attestationPaths.length} artifacts processed`);\n    }\n    \n    const successful = results.filter(r => r.success).length;\n    consola.success(`\\u2705 Batch regeneration complete: ${successful}/${results.length} successful`);\n    \n    return results;\n  }\n\n  /**\n   * Load attestation data from file\n   */\n  private async loadAttestation(attestationPath: string): Promise<any> {\n    if (!existsSync(attestationPath)) {\n      throw new Error(`Attestation file not found: ${attestationPath}`);\n    }\n\n    try {\n      const content = readFileSync(attestationPath, 'utf8');\n      return JSON.parse(content);\n    } catch (error) {\n      throw new Error(`Failed to parse attestation: ${error.message}`);\n    }\n  }\n\n  /**\n   * Validate attestation has required data for regeneration\n   */\n  private validateAttestationForRegeneration(attestation: any): { valid: boolean; missing: string[] } {\n    const required = [\n      'provenance.templatePath',\n      'provenance.variables',\n      'provenance.sourceGraph',\n      'artifact.path',\n      'artifact.hash'\n    ];\n    \n    const missing: string[] = [];\n    \n    for (const field of required) {\n      const value = this.getNestedProperty(attestation, field);\n      if (value === undefined || value === null) {\n        missing.push(field);\n      }\n    }\n    \n    return { valid: missing.length === 0, missing };\n  }\n\n  /**\n   * Extract regeneration context from attestation\n   */\n  private extractRegenerationContext(attestation: any): RegenerationContext {\n    return {\n      variables: attestation.provenance.variables,\n      sourceGraph: attestation.provenance.sourceGraph,\n      templatePath: resolve(this.config.templateBasePath, attestation.provenance.templatePath),\n      templateHash: attestation.provenance.templateHash,\n      outputPath: resolve(this.config.outputBasePath, attestation.artifact.path),\n      expectedHash: attestation.artifact.hash,\n      expectedSize: attestation.artifact.size\n    };\n  }\n\n  /**\n   * Perform the actual regeneration based on mode\n   */\n  private async performRegeneration(\n    context: RegenerationContext,\n    options: Required<RegenerationOptions>\n  ): Promise<string> {\n    switch (options.mode) {\n      case 'memory':\n        return this.regenerateInMemory(context);\n      case 'disk':\n        return this.regenerateOnDisk(context);\n      case 'hybrid':\n        return this.regenerateHybrid(context);\n      default:\n        throw new Error(`Unknown regeneration mode: ${options.mode}`);\n    }\n  }\n\n  /**\n   * Regenerate artifact in memory\n   */\n  private async regenerateInMemory(context: RegenerationContext): Promise<string> {\n    // Load template\n    const templateContent = await this.loadTemplate(context.templatePath, context.templateHash);\n    \n    // Prepare template context\n    const templateContext = {\n      ...context.variables,\n      graph: context.sourceGraph,\n      // Add utility functions\n      hash: (input: string) => createHash('sha256').update(input).digest('hex'),\n      timestamp: () => new Date().toISOString(),\n      // Add graph traversal helpers\n      rdf: this.createRDFHelpers(context.sourceGraph)\n    };\n    \n    // Render template\n    try {\n      const rendered = render(templateContent, templateContext);\n      return rendered;\n    } catch (error) {\n      throw new Error(`Template rendering failed: ${error.message}`);\n    }\n  }\n\n  /**\n   * Regenerate artifact on disk (using temporary files)\n   */\n  private async regenerateOnDisk(context: RegenerationContext): Promise<string> {\n    // For disk mode, we still render in memory but could write intermediate files\n    // This is useful for very large templates or when template includes external resources\n    return this.regenerateInMemory(context);\n  }\n\n  /**\n   * Regenerate artifact using hybrid approach\n   */\n  private async regenerateHybrid(context: RegenerationContext): Promise<string> {\n    // Hybrid mode uses memory for small templates and disk for large ones\n    const templateContent = await this.loadTemplate(context.templatePath, context.templateHash);\n    \n    if (templateContent.length > 1024 * 1024) { // > 1MB\n      return this.regenerateOnDisk(context);\n    } else {\n      return this.regenerateInMemory(context);\n    }\n  }\n\n  /**\n   * Load template with caching and validation\n   */\n  private async loadTemplate(templatePath: string, expectedHash?: string): Promise<string> {\n    // Check cache first\n    const cached = this.templateCache.get(templatePath);\n    if (cached) {\n      const stat = { mtime: new Date() }; // Would get actual stat in real implementation\n      if (stat.mtime.getTime() <= cached.lastModified + 60000) { // 1 minute cache\n        if (!expectedHash || cached.hash === expectedHash) {\n          return cached.content;\n        }\n      }\n    }\n    \n    if (!existsSync(templatePath)) {\n      throw new Error(`Template not found: ${templatePath}`);\n    }\n    \n    const content = readFileSync(templatePath, 'utf8');\n    const hash = createHash('sha256').update(content).digest('hex');\n    \n    // Validate hash if provided\n    if (expectedHash && hash !== expectedHash) {\n      throw new Error(`Template hash mismatch. Expected: ${expectedHash}, Got: ${hash}`);\n    }\n    \n    // Cache template\n    this.templateCache.set(templatePath, {\n      content,\n      hash,\n      lastModified: Date.now()\n    });\n    \n    return content;\n  }\n\n  /**\n   * Create RDF helper functions for template context\n   */\n  private createRDFHelpers(sourceGraph: Record<string, unknown>) {\n    return {\n      // Helper to find entities by type\n      findByType: (type: string) => {\n        const results = [];\n        for (const [key, value] of Object.entries(sourceGraph)) {\n          if (typeof value === 'object' && value !== null) {\n            const obj = value as Record<string, unknown>;\n            if (obj['@type'] === type || obj.type === type) {\n              results.push({ id: key, ...obj });\n            }\n          }\n        }\n        return results;\n      },\n      \n      // Helper to get entity by ID\n      getEntity: (id: string) => {\n        return sourceGraph[id] || null;\n      },\n      \n      // Helper to get property value\n      getValue: (entityId: string, property: string) => {\n        const entity = sourceGraph[entityId];\n        if (typeof entity === 'object' && entity !== null) {\n          return (entity as Record<string, unknown>)[property];\n        }\n        return null;\n      },\n      \n      // Helper to traverse relationships\n      getRelated: (entityId: string, relationship: string) => {\n        const entity = sourceGraph[entityId];\n        if (typeof entity === 'object' && entity !== null) {\n          const relatedId = (entity as Record<string, unknown>)[relationship];\n          if (typeof relatedId === 'string') {\n            return sourceGraph[relatedId] || null;\n          }\n        }\n        return null;\n      }\n    };\n  }\n\n  /**\n   * Validate regenerated content\n   */\n  private async validateRegeneratedContent(\n    content: string,\n    context: RegenerationContext,\n    attestation: any\n  ): Promise<RegenerationResult['validationResults']> {\n    const results = {\n      syntax: false,\n      semantic: false,\n      attestation: false\n    };\n\n    try {\n      // Syntax validation (try to parse as RDF if it looks like RDF)\n      if (content.includes('@prefix') || content.includes('turtle') || context.outputPath.endsWith('.ttl')) {\n        const parser = new Parser({ format: 'turtle' });\n        const store = new Store();\n        \n        await new Promise((resolve, reject) => {\n          parser.parse(content, (error, quad, prefixes) => {\n            if (error) {\n              reject(error);\n            } else if (quad) {\n              store.addQuad(quad);\n            } else {\n              resolve(store);\n            }\n          });\n        });\n        \n        results.syntax = true;\n      } else {\n        // For non-RDF content, just check if it's valid UTF-8\n        Buffer.from(content, 'utf8');\n        results.syntax = true;\n      }\n      \n      // Semantic validation would go here (using validation engine)\n      results.semantic = true; // Placeholder\n      \n      // Attestation validation - check if content matches expected structure\n      const contentHash = createHash('sha256').update(content).digest('hex');\n      results.attestation = contentHash === context.expectedHash;\n      \n    } catch (error) {\n      // Validation errors are captured in the results structure\n      consola.warn(`Validation error: ${error.message}`);\n    }\n\n    return results;\n  }\n\n  /**\n   * Create backup of existing artifact\n   */\n  private async createBackup(artifactPath: string): Promise<string> {\n    const timestamp = new Date().toISOString().replace(/[:.]/g, '-');\n    const backupPath = `${artifactPath}.backup-${timestamp}`;\n    \n    const content = readFileSync(artifactPath);\n    writeFileSync(backupPath, content);\n    \n    return backupPath;\n  }\n\n  /**\n   * Write regenerated artifact to disk\n   */\n  private async writeRegeneratedArtifact(outputPath: string, content: string): Promise<void> {\n    // Ensure directory exists\n    const dir = dirname(outputPath);\n    if (!existsSync(dir)) {\n      mkdirSync(dir, { recursive: true });\n    }\n    \n    writeFileSync(outputPath, content, 'utf8');\n  }\n\n  /**\n   * Get nested property from object using dot notation\n   */\n  private getNestedProperty(obj: any, path: string): any {\n    return path.split('.').reduce((current, key) => {\n      return current && current[key] !== undefined ? current[key] : undefined;\n    }, obj);\n  }\n\n  /**\n   * Update regeneration statistics\n   */\n  private updateStats(regenerationTime: number): void {\n    this.stats.totalRegenerationTime += regenerationTime;\n    this.stats.averageRegenerationTime = \n      this.stats.totalRegenerationTime / this.stats.regenerationsAttempted;\n  }\n\n  /**\n   * Get engine statistics\n   */\n  getStats() {\n    return {\n      ...this.stats,\n      successRate: this.stats.regenerationsAttempted > 0 \n        ? (this.stats.regenerationsSucceeded / this.stats.regenerationsAttempted) * 100 \n        : 0,\n      templatesCached: this.templateCache.size,\n      activeRegenerations: this.activeRegenerations.size\n    };\n  }\n\n  /**\n   * Clear template cache\n   */\n  clearCache(): void {\n    this.templateCache.clear();\n    this.emit('cache-cleared');\n  }\n\n  /**\n   * Health check\n   */\n  async healthCheck() {\n    return {\n      status: 'ready',\n      stats: this.getStats(),\n      config: this.config\n    };\n  }\n\n  /**\n   * Shutdown engine\n   */\n  async shutdown(): Promise<void> {\n    // Wait for active regenerations to complete\n    if (this.activeRegenerations.size > 0) {\n      consola.info(`Waiting for ${this.activeRegenerations.size} active regenerations to complete...`);\n      await Promise.all(this.activeRegenerations.values());\n    }\n    \n    this.templateCache.clear();\n    this.removeAllListeners();\n    \n    consola.info('\\ud83d\\uded1 Artifact Regeneration Engine shutdown complete');\n  }\n}
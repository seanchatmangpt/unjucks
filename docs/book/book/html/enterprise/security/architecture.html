<!DOCTYPE HTML>
<html lang="en" class="navy" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Security Architecture - Unjucks: Modern Code Generation in 2026</title>
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="A comprehensive guide to modern code generation using the Unjucks framework, demonstrating declarative development patterns, AI integration, and advanced template design for productive software development.">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#0066cc"/>

        <!-- Open Graph -->
        <meta property="og:title" content="Security Architecture - Unjucks: Modern Code Generation in 2026">
        <meta property="og:description" content="A comprehensive guide to modern code generation using the Unjucks framework, demonstrating declarative development patterns, AI integration, and advanced template design for productive software development.">
        <meta property="og:type" content="website">
        <meta property="og:url" content="">
        <meta property="og:image" content="unjucks-og.png">
        
        <!-- Twitter Card -->
        <meta name="twitter:card" content="summary_large_image">
        <meta name="twitter:title" content="Security Architecture - Unjucks: Modern Code Generation in 2026">
        <meta name="twitter:description" content="A comprehensive guide to modern code generation using the Unjucks framework, demonstrating declarative development patterns, AI integration, and advanced template design for productive software development.">
        <meta name="twitter:image" content="unjucks-og.png">


        <!-- Custom Unjucks Favicon -->
        <link rel="icon" href="../../favicon.png">
        <link rel="shortcut icon" href="../../favicon.png">

        <!-- Fonts -->
        <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&family=JetBrains+Mono:wght@300;400;500&display=swap" rel="stylesheet">

        <link rel="stylesheet" href="../../css/variables.css">
        <link rel="stylesheet" href="../../css/general.css">
        <link rel="stylesheet" href="../../css/chrome.css">
        <link rel="stylesheet" href="../../css/print.css" media="print">

        <!-- Custom CSS -->

        <!-- Custom head content -->

        <!-- JSON-LD Structured Data -->
        <script type="application/ld+json">
        {
            "@context": "https://schema.org",
            "@type": "TechArticle",
            "headline": "Security Architecture - Unjucks: Modern Code Generation in 2026",
            "description": "A comprehensive guide to modern code generation using the Unjucks framework, demonstrating declarative development patterns, AI integration, and advanced template design for productive software development.",
            "author": {
                "@type": "Organization",
                "name": "Unjucks Development Team"
            },
            "publisher": {
                "@type": "Organization",
                "name": "Unjucks",
                "logo": {
                    "@type": "ImageObject",
                    "url": "logo.png"
                }
            },
            "url": "",
            "mainEntityOfPage": "",
            "datePublished": "",
            "dateModified": "",
            "inLanguage": "en",
            "about": [
                "Code Generation",
                "Template Engine", 
                "CLI Tools",
                "Semantic Web",
                "RDF",
                "Software Development"
            ]
        }
        </script>
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "../../";
            var default_theme = "navy";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme && theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar && sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.remove('rust')
            html.classList.remove('coal')
            html.classList.remove('navy')
            html.classList.remove('ayu')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var body = document.querySelector('body');
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            body.classList.remove('sidebar-visible');
            body.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <!-- Unjucks Logo -->
                <div class="unjucks-logo" style="padding: 1rem; text-align: center; border-bottom: 1px solid #e1e5e9;">
                    <h3 style="margin: 0; color: #0066cc; font-weight: 700;">üöÄ Unjucks</h3>
                    <p style="margin: 0.5rem 0 0 0; font-size: 0.8rem; color: #666;">Template Generation Platform</p>
                </div>

                <!-- TOC will be generated automatically by mdbook -->
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <!-- Page wrapper -->
        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label for="sidebar-toggle-anchor" class="left" id="sidebar-toggle" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button left" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button left" type="button" title="Toggle Searchbar" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Unjucks: Modern Code Generation in 2026</h1>

                    <div class="right-buttons">
                        <a href="../../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/ruvnet/unjucks" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <!-- Breadcrumb Navigation -->
                        <div class="breadcrumb-nav" style="margin-bottom: 1.5rem; font-size: 0.9rem; color: #666;">
                            <a href="../../index.html">üè† Home</a>
                            <span> ‚Ä∫ </span>
                            <span>Security Architecture</span>
                        </div>

                        <h1 id="security-architecture"><a class="header" href="#security-architecture">Security Architecture</a></h1>
<h2 id="overview"><a class="header" href="#overview">Overview</a></h2>
<p>Enterprise security for code generation systems requires a comprehensive defense-in-depth approach. This chapter covers zero-trust implementation, encryption standards, multi-factor authentication, and behavioral monitoring patterns specifically designed for Unjucks enterprise deployments.</p>
<h2 id="zero-trust-implementation"><a class="header" href="#zero-trust-implementation">Zero-Trust Implementation</a></h2>
<h3 id="architecture-principles"><a class="header" href="#architecture-principles">Architecture Principles</a></h3>
<p>Zero-trust security assumes no implicit trust and requires verification for every access request, regardless of location or user credentials.</p>
<pre><code class="language-mermaid">graph TB
    Client[Client Request] --&gt; Gateway[Zero-Trust Gateway]
    Gateway --&gt; Identity[Identity Verification]
    Gateway --&gt; Device[Device Verification]
    Gateway --&gt; Network[Network Verification]
    
    Identity --&gt; MFA[Multi-Factor Auth]
    Device --&gt; DeviceTrust[Device Trust Score]
    Network --&gt; NetworkPolicy[Network Policy Engine]
    
    MFA --&gt; Authorization[Authorization Engine]
    DeviceTrust --&gt; Authorization
    NetworkPolicy --&gt; Authorization
    
    Authorization --&gt; Resources[Protected Resources]
    Authorization --&gt; Audit[Audit Logging]
</code></pre>
<h3 id="zero-trust-configuration"><a class="header" href="#zero-trust-configuration">Zero-Trust Configuration</a></h3>
<pre><code class="language-typescript">// security/zero-trust-config.ts
export const zeroTrustConfig = {
  gateway: {
    // Every request must be authenticated and authorized
    requireAuthentication: true,
    requireAuthorization: true,
    
    // Continuous verification
    sessionValidation: {
      interval: 300, // 5 minutes
      riskAssessment: true,
      deviceFingerprinting: true,
      behavioralAnalytics: true
    },
    
    // Network micro-segmentation
    networkPolicies: {
      denyByDefault: true,
      allowList: {
        templateGenerators: ['10.0.1.0/24'],
        adminConsole: ['10.0.2.0/24'],
        apiGateways: ['10.0.3.0/24']
      },
      
      // Dynamic network policies
      contextualAccess: {
        location: true,
        timeOfDay: true,
        deviceTrust: true,
        userBehavior: true
      }
    }
  },
  
  // Identity and Access Management
  identity: {
    providers: [
      {
        type: 'saml',
        provider: 'okta',
        configuration: {
          ssoUrl: process.env.OKTA_SSO_URL,
          certificate: process.env.OKTA_CERTIFICATE,
          attributeMapping: {
            userId: 'NameID',
            email: 'email',
            groups: 'memberOf',
            department: 'department'
          }
        }
      },
      {
        type: 'oauth2',
        provider: 'azure-ad',
        configuration: {
          clientId: process.env.AZURE_CLIENT_ID,
          authority: process.env.AZURE_AUTHORITY,
          scopes: ['openid', 'profile', 'email', 'unjucks.access']
        }
      }
    ],
    
    // Multi-factor authentication requirements
    mfa: {
      required: true,
      methods: ['totp', 'sms', 'hardware-token', 'biometric'],
      adaptiveAuthentication: {
        riskThreshold: 0.7,
        deviceTrustThreshold: 0.8,
        locationAnomalyDetection: true
      }
    }
  },
  
  // Authorization policies
  authorization: {
    model: 'abac', // Attribute-Based Access Control
    
    policies: [
      {
        id: 'template-generation',
        name: 'Template Generation Access',
        effect: 'allow',
        principals: ['developers', 'architects'],
        actions: ['template:generate', 'template:preview'],
        resources: ['templates/*'],
        conditions: {
          timeWindow: '06:00-22:00',
          approvedDevices: true,
          minimumTrustScore: 0.8
        }
      },
      {
        id: 'production-deployment',
        name: 'Production Deployment',
        effect: 'allow',
        principals: ['senior-developers', 'devops'],
        actions: ['deploy:production'],
        resources: ['environments/production'],
        conditions: {
          requireApproval: true,
          multiPersonAuthorization: true,
          changeControlTicket: true
        }
      }
    ]
  }
}
</code></pre>
<h3 id="device-trust-implementation"><a class="header" href="#device-trust-implementation">Device Trust Implementation</a></h3>
<pre><code class="language-typescript">// security/device-trust.ts
import { DeviceTrustEngine, RiskCalculator } from '@unjucks/security'

export class DeviceTrustManager {
  
  async calculateDeviceTrustScore(device: DeviceInfo, user: UserContext): Promise&lt;TrustScore&gt; {
    const factors = await Promise.all([
      this.assessDeviceCompliance(device),
      this.checkDeviceReputation(device),
      this.validateDeviceFingerprint(device),
      this.analyzeDeviceBehavior(device, user),
      this.verifyDeviceCertificates(device)
    ])
    
    const trustScore = this.aggregateTrustFactors(factors)
    
    // Store trust score for continuous monitoring
    await this.storeTrustScore(device.id, trustScore, {
      calculatedAt: new Date(),
      factors,
      validUntil: new Date(Date.now() + 3600000) // 1 hour
    })
    
    return trustScore
  }
  
  private async assessDeviceCompliance(device: DeviceInfo): Promise&lt;ComplianceFactor&gt; {
    return {
      factor: 'compliance',
      score: this.calculateComplianceScore({
        operatingSystemVersion: device.os.version,
        securityPatches: device.securityPatches,
        antimalwareStatus: device.antimalware,
        firewallEnabled: device.firewall,
        diskEncryption: device.encryption.disk,
        screenLock: device.screenLock
      }),
      weight: 0.3
    }
  }
  
  private async analyzeDeviceBehavior(device: DeviceInfo, user: UserContext): Promise&lt;BehaviorFactor&gt; {
    const historicalBehavior = await this.getDeviceBehaviorHistory(device.id, user.id)
    
    const anomalies = this.detectAnomalies({
      loginTimes: historicalBehavior.loginTimes,
      locations: historicalBehavior.locations,
      networkPatterns: historicalBehavior.networkPatterns,
      applicationUsage: historicalBehavior.applicationUsage
    })
    
    return {
      factor: 'behavior',
      score: 1 - (anomalies.length * 0.1), // Reduce trust for each anomaly
      weight: 0.2,
      details: { anomalies }
    }
  }
}
</code></pre>
<h2 id="fips-140-2-compliant-encryption"><a class="header" href="#fips-140-2-compliant-encryption">FIPS 140-2 Compliant Encryption</a></h2>
<h3 id="encryption-architecture"><a class="header" href="#encryption-architecture">Encryption Architecture</a></h3>
<pre><code class="language-typescript">// security/fips-encryption.ts
import { FIPS1402Module, EncryptionManager } from '@unjucks/crypto'

export class FIPSCompliantEncryption implements EncryptionManager {
  
  private fipsModule: FIPS1402Module
  
  constructor() {
    // Initialize FIPS 140-2 Level 3 certified crypto module
    this.fipsModule = new FIPS1402Module({
      level: 3,
      algorithms: {
        symmetric: ['AES-256-GCM', 'AES-256-CBC'],
        asymmetric: ['RSA-4096', 'ECDSA-P384'],
        hash: ['SHA-256', 'SHA-384', 'SHA-512'],
        keyDerivation: ['PBKDF2', 'HKDF', 'scrypt']
      },
      keyManagement: {
        hsm: true, // Hardware Security Module required
        keyRotation: '90d',
        keyEscrow: true
      }
    })
  }
  
  // Encrypt template data at rest
  async encryptTemplateData(data: TemplateData, context: EncryptionContext): Promise&lt;EncryptedData&gt; {
    const dataClassification = this.classifyData(data)
    
    const encryptionParams = this.getEncryptionParams(dataClassification, context)
    
    // Generate unique encryption key per template
    const dataKey = await this.fipsModule.generateDataKey({
      algorithm: 'AES-256-GCM',
      keyUsage: 'encryption',
      extractable: false
    })
    
    // Encrypt data with generated key
    const encryptedData = await this.fipsModule.encrypt(data, dataKey, {
      algorithm: encryptionParams.algorithm,
      additionalAuthenticatedData: {
        templateId: context.templateId,
        userId: context.userId,
        timestamp: new Date().toISOString()
      }
    })
    
    // Encrypt the data key with Key Encryption Key (KEK)
    const encryptedKey = await this.fipsModule.encryptKey(dataKey, context.kek)
    
    return {
      encryptedData: encryptedData.ciphertext,
      encryptedKey: encryptedKey,
      iv: encryptedData.iv,
      authTag: encryptedData.authTag,
      algorithm: encryptionParams.algorithm,
      keyId: encryptedKey.keyId,
      metadata: {
        dataClassification,
        encryptedAt: new Date(),
        fipsLevel: 'Level-3'
      }
    }
  }
  
  // Encrypt data in transit
  async setupTLSConfiguration(): Promise&lt;TLSConfig&gt; {
    return {
      minVersion: 'TLSv1.3',
      cipherSuites: [
        'TLS_AES_256_GCM_SHA384',
        'TLS_CHACHA20_POLY1305_SHA256',
        'TLS_AES_128_GCM_SHA256'
      ],
      
      // FIPS-approved elliptic curves
      curves: ['P-384', 'P-256'],
      
      // Certificate configuration
      certificates: {
        serverCert: await this.generateFIPSCertificate({
          keySize: 4096,
          algorithm: 'RSA',
          validityPeriod: '1y',
          extensions: {
            keyUsage: ['digitalSignature', 'keyEncipherment'],
            extendedKeyUsage: ['serverAuth', 'clientAuth']
          }
        }),
        
        // Mutual TLS for high-security communications
        clientCertRequired: true,
        caCertChain: await this.loadCACertificateChain()
      },
      
      // Perfect Forward Secrecy
      dhParams: {
        keySize: 4096,
        generator: 2
      },
      
      // HSTS and security headers
      securityHeaders: {
        'Strict-Transport-Security': 'max-age=31536000; includeSubDomains; preload',
        'Content-Security-Policy': "default-src 'self'",
        'X-Frame-Options': 'DENY',
        'X-Content-Type-Options': 'nosniff'
      }
    }
  }
  
  // Key management with automatic rotation
  async setupKeyRotation(): Promise&lt;KeyRotationConfig&gt; {
    return {
      schedule: {
        dataKeys: '30d',    // Rotate data encryption keys monthly
        keyEncryptionKeys: '90d',  // Rotate KEKs quarterly
        signingKeys: '180d', // Rotate signing keys biannually
        tlsCertificates: '1y' // Rotate TLS certificates annually
      },
      
      rotation: {
        preRotation: {
          warningPeriod: '7d',
          keyDerivation: true,
          testing: true
        },
        
        rotation: {
          atomicOperation: true,
          rollbackSupport: true,
          zeroDowntime: true
        },
        
        postRotation: {
          verification: true,
          oldKeyRetention: '30d',
          auditLogging: true
        }
      },
      
      // Emergency key revocation
      revocation: {
        compromiseDetection: true,
        automaticRevocation: true,
        emergencyContacts: process.env.SECURITY_TEAM_CONTACTS?.split(',') || [],
        revocationPropagationTime: '5m'
      }
    }
  }
}
</code></pre>
<h3 id="hardware-security-module-integration"><a class="header" href="#hardware-security-module-integration">Hardware Security Module Integration</a></h3>
<pre><code class="language-typescript">// security/hsm-integration.ts
export class HSMKeyManager {
  
  async initializeHSM(): Promise&lt;HSMConnection&gt; {
    const hsmConfig = {
      provider: process.env.HSM_PROVIDER || 'aws-cloudhsm',
      cluster: {
        id: process.env.HSM_CLUSTER_ID,
        endpoints: process.env.HSM_ENDPOINTS?.split(','),
        credentials: {
          username: process.env.HSM_USERNAME,
          password: process.env.HSM_PASSWORD,
          certificate: process.env.HSM_CLIENT_CERT
        }
      },
      
      // High availability configuration
      failover: {
        enabled: true,
        retryAttempts: 3,
        backoffStrategy: 'exponential',
        healthCheckInterval: 30000
      },
      
      // Performance optimization
      connectionPool: {
        minConnections: 5,
        maxConnections: 50,
        idleTimeout: 300000,
        maxLifetime: 3600000
      }
    }
    
    const hsm = await HSM.connect(hsmConfig)
    
    // Initialize root key hierarchy
    await this.setupKeyHierarchy(hsm)
    
    return hsm
  }
  
  private async setupKeyHierarchy(hsm: HSMConnection): Promise&lt;void&gt; {
    // Root Key Encryption Key (never leaves HSM)
    const rootKEK = await hsm.generateKey({
      keyType: 'AES',
      keySize: 256,
      keyUsage: ['wrap', 'unwrap'],
      extractable: false,
      label: 'unjucks-root-kek'
    })
    
    // Domain-specific KEKs
    const domainKEKs = await Promise.all([
      hsm.generateKey({
        keyType: 'AES',
        keySize: 256,
        keyUsage: ['wrap', 'unwrap'],
        extractable: false,
        label: 'unjucks-template-kek'
      }),
      hsm.generateKey({
        keyType: 'AES',
        keySize: 256,
        keyUsage: ['wrap', 'unwrap'],
        extractable: false,
        label: 'unjucks-config-kek'
      }),
      hsm.generateKey({
        keyType: 'AES',
        keySize: 256,
        keyUsage: ['wrap', 'unwrap'],
        extractable: false,
        label: 'unjucks-audit-kek'
      })
    ])
    
    // Store key hierarchy metadata
    await this.storeKeyMetadata({
      rootKEK: rootKEK.id,
      domainKEKs: domainKEKs.map(k =&gt; ({ id: k.id, domain: k.label })),
      createdAt: new Date(),
      fipsCompliant: true
    })
  }
}
</code></pre>
<h2 id="multi-factor-authentication"><a class="header" href="#multi-factor-authentication">Multi-Factor Authentication</a></h2>
<h3 id="adaptive-mfa-implementation"><a class="header" href="#adaptive-mfa-implementation">Adaptive MFA Implementation</a></h3>
<pre><code class="language-typescript">// security/adaptive-mfa.ts
export class AdaptiveMFAEngine {
  
  async evaluateAuthenticationRisk(context: AuthContext): Promise&lt;MFARequirement&gt; {
    const riskFactors = await this.calculateRiskFactors(context)
    const riskScore = this.aggregateRiskScore(riskFactors)
    
    // Adaptive MFA based on risk score
    if (riskScore &gt;= 0.8) {
      return {
        required: true,
        methods: ['hardware-token', 'biometric'],
        minimumMethods: 2,
        stepUp: true, // Require additional verification
        timeout: 300 // 5 minutes
      }
    } else if (riskScore &gt;= 0.6) {
      return {
        required: true,
        methods: ['totp', 'sms', 'push-notification'],
        minimumMethods: 1,
        stepUp: false,
        timeout: 600 // 10 minutes
      }
    } else if (riskScore &gt;= 0.3) {
      return {
        required: true,
        methods: ['push-notification', 'totp'],
        minimumMethods: 1,
        stepUp: false,
        timeout: 1800 // 30 minutes
      }
    } else {
      // Low risk - single factor may be sufficient for certain operations
      return {
        required: false,
        methods: [],
        minimumMethods: 0,
        stepUp: false,
        timeout: 3600 // 1 hour
      }
    }
  }
  
  private async calculateRiskFactors(context: AuthContext): Promise&lt;RiskFactor[]&gt; {
    return await Promise.all([
      // Geographic location risk
      this.assessLocationRisk(context.clientIP, context.user.id),
      
      // Device risk assessment
      this.assessDeviceRisk(context.deviceFingerprint, context.user.id),
      
      // Temporal pattern analysis
      this.assessTemporalRisk(context.timestamp, context.user.id),
      
      // Behavioral analysis
      this.assessBehavioralRisk(context.sessionData, context.user.id),
      
      // Network risk assessment
      this.assessNetworkRisk(context.networkInfo),
      
      // Application-specific risk
      this.assessApplicationRisk(context.requestedAction, context.resourceSensitivity)
    ])
  }
  
  async setupMFAMethods(userId: string): Promise&lt;MFASetupResult&gt; {
    const availableMethods = await this.getAvailableMFAMethods()
    const userPreferences = await this.getUserMFAPreferences(userId)
    
    const recommendedMethods = this.recommendMFAMethods(userPreferences, {
      securityLevel: 'high',
      usabilityWeight: 0.3,
      securityWeight: 0.7
    })
    
    return {
      availableMethods,
      recommendedMethods,
      setupInstructions: this.generateSetupInstructions(recommendedMethods),
      backupCodes: await this.generateBackupCodes(userId, 10),
      enrollmentDeadline: new Date(Date.now() + 7 * 24 * 60 * 60 * 1000) // 7 days
    }
  }
}
</code></pre>
<h3 id="hardware-token-integration"><a class="header" href="#hardware-token-integration">Hardware Token Integration</a></h3>
<pre><code class="language-typescript">// security/hardware-tokens.ts
export class HardwareTokenManager {
  
  async registerHardwareToken(userId: string, tokenInfo: HardwareTokenInfo): Promise&lt;TokenRegistration&gt; {
    // Validate token authenticity
    const tokenValidation = await this.validateTokenAuthenticity(tokenInfo)
    if (!tokenValidation.isValid) {
      throw new InvalidTokenError('Hardware token validation failed')
    }
    
    // Generate token-specific configuration
    const tokenConfig = {
      userId,
      tokenId: tokenInfo.id,
      tokenType: tokenInfo.type, // YubiKey, RSA SecurID, etc.
      publicKey: tokenInfo.publicKey,
      certificateChain: tokenInfo.certificateChain,
      
      // Security configuration
      pinRequired: true,
      touchRequired: tokenInfo.capabilities.includes('touch'),
      biometricRequired: tokenInfo.capabilities.includes('biometric'),
      
      // Usage policies
      maxConsecutiveFailures: 3,
      lockoutDuration: 900, // 15 minutes
      inactivityTimeout: 300, // 5 minutes
      
      // Attestation and verification
      attestationCertificate: tokenInfo.attestationCertificate,
      verificationMethod: 'FIDO2',
      
      registeredAt: new Date(),
      expiresAt: new Date(Date.now() + 3 * 365 * 24 * 60 * 60 * 1000) // 3 years
    }
    
    // Store token configuration securely
    await this.storeTokenConfig(tokenConfig)
    
    // Generate backup authentication codes
    const backupCodes = await this.generateBackupCodes(userId, 10)
    
    return {
      tokenId: tokenInfo.id,
      registrationSuccessful: true,
      backupCodes,
      setupInstructions: this.generateTokenSetupInstructions(tokenInfo.type),
      testVerificationRequired: true
    }
  }
  
  async verifyHardwareToken(
    userId: string, 
    tokenId: string, 
    challenge: string, 
    response: TokenResponse
  ): Promise&lt;TokenVerificationResult&gt; {
    
    const tokenConfig = await this.getTokenConfig(userId, tokenId)
    if (!tokenConfig) {
      throw new TokenNotFoundError('Hardware token not registered')
    }
    
    // Verify token response against challenge
    const verificationResult = await this.verifyTokenResponse(
      challenge,
      response,
      tokenConfig.publicKey
    )
    
    if (!verificationResult.isValid) {
      await this.recordFailedAttempt(userId, tokenId)
      
      // Check for lockout condition
      const failureCount = await this.getConsecutiveFailures(userId, tokenId)
      if (failureCount &gt;= tokenConfig.maxConsecutiveFailures) {
        await this.lockoutToken(userId, tokenId, tokenConfig.lockoutDuration)
        throw new TokenLockoutError('Hardware token locked due to repeated failures')
      }
      
      throw new InvalidTokenResponseError('Hardware token verification failed')
    }
    
    // Reset failure counter on successful verification
    await this.resetFailureCounter(userId, tokenId)
    
    // Update token usage statistics
    await this.updateTokenUsage(userId, tokenId, {
      lastUsed: new Date(),
      usageCount: (tokenConfig.usageCount || 0) + 1
    })
    
    return {
      verified: true,
      tokenId,
      challengeId: challenge,
      verifiedAt: new Date(),
      trustScore: this.calculateTokenTrustScore(tokenConfig, verificationResult)
    }
  }
}
</code></pre>
<h2 id="behavioral-analysis-and-monitoring"><a class="header" href="#behavioral-analysis-and-monitoring">Behavioral Analysis and Monitoring</a></h2>
<h3 id="user-behavior-analytics"><a class="header" href="#user-behavior-analytics">User Behavior Analytics</a></h3>
<pre><code class="language-typescript">// security/behavior-analytics.ts
export class UserBehaviorAnalytics {
  
  async analyzeUserBehavior(userId: string, session: UserSession): Promise&lt;BehaviorAnalysis&gt; {
    const behaviorHistory = await this.getUserBehaviorHistory(userId, 30) // 30 days
    
    const analyses = await Promise.all([
      this.analyzeLoginPatterns(session, behaviorHistory.loginPatterns),
      this.analyzeTemplateUsagePatterns(session, behaviorHistory.templateUsage),
      this.analyzeNetworkPatterns(session, behaviorHistory.networkPatterns),
      this.analyzeDevicePatterns(session, behaviorHistory.devicePatterns),
      this.analyzeApplicationUsagePatterns(session, behaviorHistory.applicationUsage)
    ])
    
    const anomalies = this.detectAnomalies(analyses)
    const riskScore = this.calculateBehavioralRiskScore(anomalies)
    
    // Machine learning-based anomaly detection
    const mlAnomalies = await this.runMLAnomalyDetection(userId, session, behaviorHistory)
    
    const combinedAnalysis = {
      userId,
      sessionId: session.id,
      timestamp: new Date(),
      
      riskScore,
      anomalies: [...anomalies, ...mlAnomalies],
      
      behaviorMetrics: {
        loginFrequency: analyses[0].metrics,
        templateUsageFrequency: analyses[1].metrics,
        networkConsistency: analyses[2].metrics,
        deviceConsistency: analyses[3].metrics,
        applicationConsistency: analyses[4].metrics
      },
      
      recommendations: this.generateSecurityRecommendations(anomalies, riskScore),
      
      confidence: this.calculateConfidenceScore(analyses, behaviorHistory.dataPoints)
    }
    
    // Store analysis for future reference
    await this.storeBehaviorAnalysis(combinedAnalysis)
    
    // Trigger alerts for high-risk scenarios
    if (riskScore &gt;= 0.8) {
      await this.triggerHighRiskAlert(combinedAnalysis)
    }
    
    return combinedAnalysis
  }
  
  private async runMLAnomalyDetection(
    userId: string, 
    session: UserSession, 
    history: BehaviorHistory
  ): Promise&lt;MLAnomaly[]&gt; {
    
    // Feature extraction for ML model
    const features = this.extractBehaviorFeatures(session, history)
    
    // Run multiple ML models for different anomaly types
    const modelResults = await Promise.all([
      this.runIsolationForest(features), // Unsupervised anomaly detection
      this.runOneClassSVM(features),     // Outlier detection
      this.runLSTMAnomaly(features),     // Sequential pattern anomalies
      this.runAutoencoderAnomaly(features) // Reconstruction-based anomalies
    ])
    
    // Ensemble voting for final anomaly determination
    const anomalies = this.ensembleVoting(modelResults, features)
    
    return anomalies.map(anomaly =&gt; ({
      type: 'ml-detected',
      confidence: anomaly.confidence,
      description: anomaly.description,
      severity: this.classifySeverity(anomaly.score),
      modelUsed: anomaly.model,
      features: anomaly.contributingFeatures
    }))
  }
  
  async setupRealTimeMonitoring(userId: string): Promise&lt;MonitoringConfig&gt; {
    return {
      enabled: true,
      
      // Real-time analysis triggers
      triggers: [
        {
          event: 'login',
          analysis: ['location', 'device', 'timing'],
          threshold: 0.7,
          action: 'additional-verification'
        },
        {
          event: 'template-generation',
          analysis: ['frequency', 'volume', 'sensitivity'],
          threshold: 0.8,
          action: 'step-up-authentication'
        },
        {
          event: 'configuration-change',
          analysis: ['authorization', 'pattern', 'impact'],
          threshold: 0.6,
          action: 'approval-required'
        }
      ],
      
      // Continuous monitoring
      monitoring: {
        sessionDuration: true,
        activityPatterns: true,
        resourceAccess: true,
        dataExfiltration: true,
        privilegeEscalation: true
      },
      
      // Alert configuration
      alerting: {
        channels: ['email', 'slack', 'pagerduty'],
        escalation: {
          level1: { threshold: 0.6, response: '5m' },
          level2: { threshold: 0.8, response: '2m' },
          level3: { threshold: 0.95, response: '30s' }
        }
      }
    }
  }
}
</code></pre>
<h3 id="security-event-monitoring"><a class="header" href="#security-event-monitoring">Security Event Monitoring</a></h3>
<pre><code class="language-typescript">// security/event-monitoring.ts
export class SecurityEventMonitor {
  
  async initializeEventMonitoring(): Promise&lt;EventMonitoringSystem&gt; {
    const monitoring = {
      // Security events to monitor
      events: {
        authentication: [
          'login-attempt',
          'login-success',
          'login-failure',
          'mfa-challenge',
          'mfa-success',
          'mfa-failure',
          'password-change',
          'account-lockout'
        ],
        
        authorization: [
          'permission-granted',
          'permission-denied',
          'privilege-escalation-attempt',
          'role-change',
          'policy-violation'
        ],
        
        dataAccess: [
          'template-access',
          'configuration-read',
          'sensitive-data-access',
          'bulk-data-export',
          'unauthorized-access-attempt'
        ],
        
        systemSecurity: [
          'configuration-change',
          'security-policy-update',
          'encryption-key-rotation',
          'certificate-renewal',
          'vulnerability-detected'
        ]
      },
      
      // Real-time processing pipeline
      processing: {
        ingestion: {
          sources: ['application-logs', 'system-logs', 'network-logs', 'security-devices'],
          format: 'structured-json',
          encryption: true,
          compression: true
        },
        
        enrichment: {
          geoLocation: true,
          threatIntelligence: true,
          userContext: true,
          deviceContext: true,
          riskScoring: true
        },
        
        correlation: {
          timeWindow: 300, // 5 minutes
          rules: await this.loadCorrelationRules(),
          machineLearning: true,
          baselineComparison: true
        }
      },
      
      // Response automation
      responseAutomation: {
        immediateResponse: {
          'multiple-failed-logins': 'account-lockout',
          'privilege-escalation': 'session-termination',
          'suspicious-data-access': 'additional-verification',
          'malware-detected': 'quarantine-device'
        },
        
        escalationRules: {
          'high-risk-user-activity': {
            level1: 'security-team-alert',
            level2: 'manager-notification',
            level3: 'incident-response-activation'
          }
        }
      }
    }
    
    // Start real-time monitoring
    const eventStream = await this.initializeEventStream(monitoring)
    const alertingSystem = await this.initializeAlerting(monitoring)
    const responseSystem = await this.initializeAutomatedResponse(monitoring)
    
    return {
      monitoring,
      eventStream,
      alertingSystem,
      responseSystem,
      healthCheck: () =&gt; this.performHealthCheck([eventStream, alertingSystem, responseSystem])
    }
  }
  
  async generateSecurityDashboard(): Promise&lt;SecurityDashboard&gt; {
    const timeRange = { start: new Date(Date.now() - 24 * 60 * 60 * 1000), end: new Date() }
    
    const [
      threatMetrics,
      complianceMetrics,
      performanceMetrics,
      incidentMetrics
    ] = await Promise.all([
      this.getThreatMetrics(timeRange),
      this.getComplianceMetrics(timeRange),
      this.getPerformanceMetrics(timeRange),
      this.getIncidentMetrics(timeRange)
    ])
    
    return {
      overview: {
        securityScore: this.calculateOverallSecurityScore({
          threatMetrics,
          complianceMetrics,
          incidentMetrics
        }),
        
        threatLevel: this.assessCurrentThreatLevel(threatMetrics),
        complianceStatus: complianceMetrics.overallScore,
        systemHealth: performanceMetrics.healthScore
      },
      
      metrics: {
        threats: {
          detected: threatMetrics.detectedThreats,
          blocked: threatMetrics.blockedThreats,
          resolved: threatMetrics.resolvedThreats,
          falsePositives: threatMetrics.falsePositives
        },
        
        authentication: {
          successRate: this.calculateAuthSuccessRate(timeRange),
          mfaAdoptionRate: this.calculateMFAAdoption(),
          averageAuthTime: performanceMetrics.authTime
        },
        
        incidents: {
          open: incidentMetrics.openIncidents,
          resolved: incidentMetrics.resolvedIncidents,
          averageResolutionTime: incidentMetrics.averageResolutionTime,
          criticalIncidents: incidentMetrics.criticalIncidents
        }
      },
      
      alerts: {
        active: await this.getActiveAlerts(),
        recent: await this.getRecentAlerts(timeRange),
        trends: await this.getAlertTrends(timeRange)
      },
      
      recommendations: await this.generateSecurityRecommendations()
    }
  }
}
</code></pre>
<h2 id="compliance-integration"><a class="header" href="#compliance-integration">Compliance Integration</a></h2>
<h3 id="automated-compliance-validation"><a class="header" href="#automated-compliance-validation">Automated Compliance Validation</a></h3>
<pre><code class="language-typescript">// security/compliance-validation.ts
export class ComplianceValidator {
  
  async validateSOC2Compliance(): Promise&lt;SOC2ComplianceReport&gt; {
    const controls = await this.evaluateSOC2Controls()
    
    return {
      controlResults: {
        // Common Criteria (CC)
        CC1: await this.validateControlEnvironment(),
        CC2: await this.validateCommunicationAndInformation(),
        CC3: await this.validateRiskAssessment(),
        CC4: await this.validateMonitoringActivities(),
        CC5: await this.validateControlActivities(),
        CC6: await this.validateLogicalAndPhysicalAccess(),
        CC7: await this.validateSystemOperations(),
        CC8: await this.validateChangeManagement(),
        CC9: await this.validateRiskMitigation(),
        
        // Additional Criteria for Security
        A1: await this.validateAccessControls()
      },
      
      overallCompliance: this.calculateComplianceScore(controls),
      findings: controls.flatMap(control =&gt; control.findings),
      recommendations: this.generateComplianceRecommendations(controls),
      
      report: {
        generatedAt: new Date(),
        period: this.getCurrentReportingPeriod(),
        auditor: 'automated-system',
        nextReview: this.calculateNextReviewDate()
      }
    }
  }
  
  async validateHIPAACompliance(): Promise&lt;HIPAAComplianceReport&gt; {
    return {
      administrativeSafeguards: await this.validateAdministrativeSafeguards(),
      physicalSafeguards: await this.validatePhysicalSafeguards(),
      technicalSafeguards: await this.validateTechnicalSafeguards(),
      
      // Specific HIPAA requirements
      riskAssessment: await this.validateHIPAARiskAssessment(),
      auditControls: await this.validateAuditControls(),
      integrityControls: await this.validateIntegrityControls(),
      transmissionSecurity: await this.validateTransmissionSecurity(),
      
      breachNotification: {
        procedures: await this.validateBreachProcedures(),
        timeline: await this.validateNotificationTimeline(),
        documentation: await this.validateBreachDocumentation()
      }
    }
  }
  
  private async validateTechnicalSafeguards(): Promise&lt;TechnicalSafeguards&gt; {
    return {
      accessControl: {
        uniqueUserIdentification: await this.validateUniqueUserIDs(),
        emergencyAccessProcedure: await this.validateEmergencyAccess(),
        automaticLogoff: await this.validateAutomaticLogoff(),
        encryptionDecryption: await this.validateEncryptionControls()
      },
      
      auditControls: {
        auditLogsEnabled: await this.validateAuditLogging(),
        auditLogReview: await this.validateAuditReview(),
        auditLogProtection: await this.validateAuditProtection()
      },
      
      integrity: {
        dataIntegrityControls: await this.validateDataIntegrity(),
        transmissionIntegrity: await this.validateTransmissionIntegrity()
      },
      
      personOrEntityAuthentication: {
        userAuthentication: await this.validateUserAuthentication(),
        deviceAuthentication: await this.validateDeviceAuthentication()
      },
      
      transmissionSecurity: {
        endToEndEncryption: await this.validateE2EEncryption(),
        networkSecurityControls: await this.validateNetworkSecurity()
      }
    }
  }
}
</code></pre>
<h2 id="next-steps"><a class="header" href="#next-steps">Next Steps</a></h2>
<p>The security architecture provides a comprehensive foundation for enterprise deployments. For implementation details, see:</p>
<ul>
<li><a href="../architecture/multi-tenant.html">Multi-Tenant Architecture</a></li>
<li><a href="../compliance/frameworks.html">Compliance Frameworks</a></li>
<li><a href="../deployment/overview.html">Enterprise Deployment Overview</a></li>
<li><a href="../patterns/fortune-5.html">Fortune 5 Patterns</a></li>
</ul>


                        <!-- Page Footer -->
                        <div class="page-footer" style="margin-top: 3rem; padding-top: 2rem; border-top: 1px solid #e1e5e9;">
                            <div style="display: flex; justify-content: space-between; align-items: center; flex-wrap: wrap; gap: 1rem;">
                                <div class="footer-links" style="display: flex; gap: 1rem; font-size: 0.9rem;">
                                    <a href="https://unjucks.dev" target="_blank">üåê Website</a>
                                    <a href="https://github.com/ruvnet/unjucks" target="_blank">üíª GitHub</a>
                                    <a href="https://github.com/ruvnet/unjucks/issues" target="_blank">üêõ Issues</a>
                                    <a href="https://github.com/ruvnet/unjucks/discussions" target="_blank">üí¨ Discussions</a>
                                </div>
                                <div class="footer-info" style="font-size: 0.8rem; color: #888; text-align: right;">
                                    <p>Built with ‚ù§Ô∏è using <a href="https://rust-lang.github.io/mdBook/" target="_blank">mdBook</a></p>
                                    <p>¬© 2024 Unjucks Project</p>
                                </div>
                            </div>
                        </div>
                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        <a href="../../" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                            <i class="fa fa-angle-left"></i>
                        </a>

                        <a href="../../" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                            <i class="fa fa-angle-right"></i>
                        </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <!-- Desktop navigation -->
            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                <a href="../../" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                    <i class="fa fa-angle-left"></i>
                </a>

                <a href="../../" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                    <i class="fa fa-angle-right"></i>
                </a>
            </nav>
        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="../../elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../../mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../../searcher.js" type="text/javascript" charset="utf-8"></script>

        <script src="../../clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../../highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="../../book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS -->

        <!-- Custom body content -->
        <h1 id="security-architecture-1"><a class="header" href="#security-architecture-1">Security Architecture</a></h1>
<h2 id="overview-1"><a class="header" href="#overview-1">Overview</a></h2>
<p>Enterprise security for code generation systems requires a comprehensive defense-in-depth approach. This chapter covers zero-trust implementation, encryption standards, multi-factor authentication, and behavioral monitoring patterns specifically designed for Unjucks enterprise deployments.</p>
<h2 id="zero-trust-implementation-1"><a class="header" href="#zero-trust-implementation-1">Zero-Trust Implementation</a></h2>
<h3 id="architecture-principles-1"><a class="header" href="#architecture-principles-1">Architecture Principles</a></h3>
<p>Zero-trust security assumes no implicit trust and requires verification for every access request, regardless of location or user credentials.</p>
<pre><code class="language-mermaid">graph TB
    Client[Client Request] --&gt; Gateway[Zero-Trust Gateway]
    Gateway --&gt; Identity[Identity Verification]
    Gateway --&gt; Device[Device Verification]
    Gateway --&gt; Network[Network Verification]
    
    Identity --&gt; MFA[Multi-Factor Auth]
    Device --&gt; DeviceTrust[Device Trust Score]
    Network --&gt; NetworkPolicy[Network Policy Engine]
    
    MFA --&gt; Authorization[Authorization Engine]
    DeviceTrust --&gt; Authorization
    NetworkPolicy --&gt; Authorization
    
    Authorization --&gt; Resources[Protected Resources]
    Authorization --&gt; Audit[Audit Logging]
</code></pre>
<h3 id="zero-trust-configuration-1"><a class="header" href="#zero-trust-configuration-1">Zero-Trust Configuration</a></h3>
<pre><code class="language-typescript">// security/zero-trust-config.ts
export const zeroTrustConfig = {
  gateway: {
    // Every request must be authenticated and authorized
    requireAuthentication: true,
    requireAuthorization: true,
    
    // Continuous verification
    sessionValidation: {
      interval: 300, // 5 minutes
      riskAssessment: true,
      deviceFingerprinting: true,
      behavioralAnalytics: true
    },
    
    // Network micro-segmentation
    networkPolicies: {
      denyByDefault: true,
      allowList: {
        templateGenerators: ['10.0.1.0/24'],
        adminConsole: ['10.0.2.0/24'],
        apiGateways: ['10.0.3.0/24']
      },
      
      // Dynamic network policies
      contextualAccess: {
        location: true,
        timeOfDay: true,
        deviceTrust: true,
        userBehavior: true
      }
    }
  },
  
  // Identity and Access Management
  identity: {
    providers: [
      {
        type: 'saml',
        provider: 'okta',
        configuration: {
          ssoUrl: process.env.OKTA_SSO_URL,
          certificate: process.env.OKTA_CERTIFICATE,
          attributeMapping: {
            userId: 'NameID',
            email: 'email',
            groups: 'memberOf',
            department: 'department'
          }
        }
      },
      {
        type: 'oauth2',
        provider: 'azure-ad',
        configuration: {
          clientId: process.env.AZURE_CLIENT_ID,
          authority: process.env.AZURE_AUTHORITY,
          scopes: ['openid', 'profile', 'email', 'unjucks.access']
        }
      }
    ],
    
    // Multi-factor authentication requirements
    mfa: {
      required: true,
      methods: ['totp', 'sms', 'hardware-token', 'biometric'],
      adaptiveAuthentication: {
        riskThreshold: 0.7,
        deviceTrustThreshold: 0.8,
        locationAnomalyDetection: true
      }
    }
  },
  
  // Authorization policies
  authorization: {
    model: 'abac', // Attribute-Based Access Control
    
    policies: [
      {
        id: 'template-generation',
        name: 'Template Generation Access',
        effect: 'allow',
        principals: ['developers', 'architects'],
        actions: ['template:generate', 'template:preview'],
        resources: ['templates/*'],
        conditions: {
          timeWindow: '06:00-22:00',
          approvedDevices: true,
          minimumTrustScore: 0.8
        }
      },
      {
        id: 'production-deployment',
        name: 'Production Deployment',
        effect: 'allow',
        principals: ['senior-developers', 'devops'],
        actions: ['deploy:production'],
        resources: ['environments/production'],
        conditions: {
          requireApproval: true,
          multiPersonAuthorization: true,
          changeControlTicket: true
        }
      }
    ]
  }
}
</code></pre>
<h3 id="device-trust-implementation-1"><a class="header" href="#device-trust-implementation-1">Device Trust Implementation</a></h3>
<pre><code class="language-typescript">// security/device-trust.ts
import { DeviceTrustEngine, RiskCalculator } from '@unjucks/security'

export class DeviceTrustManager {
  
  async calculateDeviceTrustScore(device: DeviceInfo, user: UserContext): Promise&lt;TrustScore&gt; {
    const factors = await Promise.all([
      this.assessDeviceCompliance(device),
      this.checkDeviceReputation(device),
      this.validateDeviceFingerprint(device),
      this.analyzeDeviceBehavior(device, user),
      this.verifyDeviceCertificates(device)
    ])
    
    const trustScore = this.aggregateTrustFactors(factors)
    
    // Store trust score for continuous monitoring
    await this.storeTrustScore(device.id, trustScore, {
      calculatedAt: new Date(),
      factors,
      validUntil: new Date(Date.now() + 3600000) // 1 hour
    })
    
    return trustScore
  }
  
  private async assessDeviceCompliance(device: DeviceInfo): Promise&lt;ComplianceFactor&gt; {
    return {
      factor: 'compliance',
      score: this.calculateComplianceScore({
        operatingSystemVersion: device.os.version,
        securityPatches: device.securityPatches,
        antimalwareStatus: device.antimalware,
        firewallEnabled: device.firewall,
        diskEncryption: device.encryption.disk,
        screenLock: device.screenLock
      }),
      weight: 0.3
    }
  }
  
  private async analyzeDeviceBehavior(device: DeviceInfo, user: UserContext): Promise&lt;BehaviorFactor&gt; {
    const historicalBehavior = await this.getDeviceBehaviorHistory(device.id, user.id)
    
    const anomalies = this.detectAnomalies({
      loginTimes: historicalBehavior.loginTimes,
      locations: historicalBehavior.locations,
      networkPatterns: historicalBehavior.networkPatterns,
      applicationUsage: historicalBehavior.applicationUsage
    })
    
    return {
      factor: 'behavior',
      score: 1 - (anomalies.length * 0.1), // Reduce trust for each anomaly
      weight: 0.2,
      details: { anomalies }
    }
  }
}
</code></pre>
<h2 id="fips-140-2-compliant-encryption-1"><a class="header" href="#fips-140-2-compliant-encryption-1">FIPS 140-2 Compliant Encryption</a></h2>
<h3 id="encryption-architecture-1"><a class="header" href="#encryption-architecture-1">Encryption Architecture</a></h3>
<pre><code class="language-typescript">// security/fips-encryption.ts
import { FIPS1402Module, EncryptionManager } from '@unjucks/crypto'

export class FIPSCompliantEncryption implements EncryptionManager {
  
  private fipsModule: FIPS1402Module
  
  constructor() {
    // Initialize FIPS 140-2 Level 3 certified crypto module
    this.fipsModule = new FIPS1402Module({
      level: 3,
      algorithms: {
        symmetric: ['AES-256-GCM', 'AES-256-CBC'],
        asymmetric: ['RSA-4096', 'ECDSA-P384'],
        hash: ['SHA-256', 'SHA-384', 'SHA-512'],
        keyDerivation: ['PBKDF2', 'HKDF', 'scrypt']
      },
      keyManagement: {
        hsm: true, // Hardware Security Module required
        keyRotation: '90d',
        keyEscrow: true
      }
    })
  }
  
  // Encrypt template data at rest
  async encryptTemplateData(data: TemplateData, context: EncryptionContext): Promise&lt;EncryptedData&gt; {
    const dataClassification = this.classifyData(data)
    
    const encryptionParams = this.getEncryptionParams(dataClassification, context)
    
    // Generate unique encryption key per template
    const dataKey = await this.fipsModule.generateDataKey({
      algorithm: 'AES-256-GCM',
      keyUsage: 'encryption',
      extractable: false
    })
    
    // Encrypt data with generated key
    const encryptedData = await this.fipsModule.encrypt(data, dataKey, {
      algorithm: encryptionParams.algorithm,
      additionalAuthenticatedData: {
        templateId: context.templateId,
        userId: context.userId,
        timestamp: new Date().toISOString()
      }
    })
    
    // Encrypt the data key with Key Encryption Key (KEK)
    const encryptedKey = await this.fipsModule.encryptKey(dataKey, context.kek)
    
    return {
      encryptedData: encryptedData.ciphertext,
      encryptedKey: encryptedKey,
      iv: encryptedData.iv,
      authTag: encryptedData.authTag,
      algorithm: encryptionParams.algorithm,
      keyId: encryptedKey.keyId,
      metadata: {
        dataClassification,
        encryptedAt: new Date(),
        fipsLevel: 'Level-3'
      }
    }
  }
  
  // Encrypt data in transit
  async setupTLSConfiguration(): Promise&lt;TLSConfig&gt; {
    return {
      minVersion: 'TLSv1.3',
      cipherSuites: [
        'TLS_AES_256_GCM_SHA384',
        'TLS_CHACHA20_POLY1305_SHA256',
        'TLS_AES_128_GCM_SHA256'
      ],
      
      // FIPS-approved elliptic curves
      curves: ['P-384', 'P-256'],
      
      // Certificate configuration
      certificates: {
        serverCert: await this.generateFIPSCertificate({
          keySize: 4096,
          algorithm: 'RSA',
          validityPeriod: '1y',
          extensions: {
            keyUsage: ['digitalSignature', 'keyEncipherment'],
            extendedKeyUsage: ['serverAuth', 'clientAuth']
          }
        }),
        
        // Mutual TLS for high-security communications
        clientCertRequired: true,
        caCertChain: await this.loadCACertificateChain()
      },
      
      // Perfect Forward Secrecy
      dhParams: {
        keySize: 4096,
        generator: 2
      },
      
      // HSTS and security headers
      securityHeaders: {
        'Strict-Transport-Security': 'max-age=31536000; includeSubDomains; preload',
        'Content-Security-Policy': "default-src 'self'",
        'X-Frame-Options': 'DENY',
        'X-Content-Type-Options': 'nosniff'
      }
    }
  }
  
  // Key management with automatic rotation
  async setupKeyRotation(): Promise&lt;KeyRotationConfig&gt; {
    return {
      schedule: {
        dataKeys: '30d',    // Rotate data encryption keys monthly
        keyEncryptionKeys: '90d',  // Rotate KEKs quarterly
        signingKeys: '180d', // Rotate signing keys biannually
        tlsCertificates: '1y' // Rotate TLS certificates annually
      },
      
      rotation: {
        preRotation: {
          warningPeriod: '7d',
          keyDerivation: true,
          testing: true
        },
        
        rotation: {
          atomicOperation: true,
          rollbackSupport: true,
          zeroDowntime: true
        },
        
        postRotation: {
          verification: true,
          oldKeyRetention: '30d',
          auditLogging: true
        }
      },
      
      // Emergency key revocation
      revocation: {
        compromiseDetection: true,
        automaticRevocation: true,
        emergencyContacts: process.env.SECURITY_TEAM_CONTACTS?.split(',') || [],
        revocationPropagationTime: '5m'
      }
    }
  }
}
</code></pre>
<h3 id="hardware-security-module-integration-1"><a class="header" href="#hardware-security-module-integration-1">Hardware Security Module Integration</a></h3>
<pre><code class="language-typescript">// security/hsm-integration.ts
export class HSMKeyManager {
  
  async initializeHSM(): Promise&lt;HSMConnection&gt; {
    const hsmConfig = {
      provider: process.env.HSM_PROVIDER || 'aws-cloudhsm',
      cluster: {
        id: process.env.HSM_CLUSTER_ID,
        endpoints: process.env.HSM_ENDPOINTS?.split(','),
        credentials: {
          username: process.env.HSM_USERNAME,
          password: process.env.HSM_PASSWORD,
          certificate: process.env.HSM_CLIENT_CERT
        }
      },
      
      // High availability configuration
      failover: {
        enabled: true,
        retryAttempts: 3,
        backoffStrategy: 'exponential',
        healthCheckInterval: 30000
      },
      
      // Performance optimization
      connectionPool: {
        minConnections: 5,
        maxConnections: 50,
        idleTimeout: 300000,
        maxLifetime: 3600000
      }
    }
    
    const hsm = await HSM.connect(hsmConfig)
    
    // Initialize root key hierarchy
    await this.setupKeyHierarchy(hsm)
    
    return hsm
  }
  
  private async setupKeyHierarchy(hsm: HSMConnection): Promise&lt;void&gt; {
    // Root Key Encryption Key (never leaves HSM)
    const rootKEK = await hsm.generateKey({
      keyType: 'AES',
      keySize: 256,
      keyUsage: ['wrap', 'unwrap'],
      extractable: false,
      label: 'unjucks-root-kek'
    })
    
    // Domain-specific KEKs
    const domainKEKs = await Promise.all([
      hsm.generateKey({
        keyType: 'AES',
        keySize: 256,
        keyUsage: ['wrap', 'unwrap'],
        extractable: false,
        label: 'unjucks-template-kek'
      }),
      hsm.generateKey({
        keyType: 'AES',
        keySize: 256,
        keyUsage: ['wrap', 'unwrap'],
        extractable: false,
        label: 'unjucks-config-kek'
      }),
      hsm.generateKey({
        keyType: 'AES',
        keySize: 256,
        keyUsage: ['wrap', 'unwrap'],
        extractable: false,
        label: 'unjucks-audit-kek'
      })
    ])
    
    // Store key hierarchy metadata
    await this.storeKeyMetadata({
      rootKEK: rootKEK.id,
      domainKEKs: domainKEKs.map(k =&gt; ({ id: k.id, domain: k.label })),
      createdAt: new Date(),
      fipsCompliant: true
    })
  }
}
</code></pre>
<h2 id="multi-factor-authentication-1"><a class="header" href="#multi-factor-authentication-1">Multi-Factor Authentication</a></h2>
<h3 id="adaptive-mfa-implementation-1"><a class="header" href="#adaptive-mfa-implementation-1">Adaptive MFA Implementation</a></h3>
<pre><code class="language-typescript">// security/adaptive-mfa.ts
export class AdaptiveMFAEngine {
  
  async evaluateAuthenticationRisk(context: AuthContext): Promise&lt;MFARequirement&gt; {
    const riskFactors = await this.calculateRiskFactors(context)
    const riskScore = this.aggregateRiskScore(riskFactors)
    
    // Adaptive MFA based on risk score
    if (riskScore &gt;= 0.8) {
      return {
        required: true,
        methods: ['hardware-token', 'biometric'],
        minimumMethods: 2,
        stepUp: true, // Require additional verification
        timeout: 300 // 5 minutes
      }
    } else if (riskScore &gt;= 0.6) {
      return {
        required: true,
        methods: ['totp', 'sms', 'push-notification'],
        minimumMethods: 1,
        stepUp: false,
        timeout: 600 // 10 minutes
      }
    } else if (riskScore &gt;= 0.3) {
      return {
        required: true,
        methods: ['push-notification', 'totp'],
        minimumMethods: 1,
        stepUp: false,
        timeout: 1800 // 30 minutes
      }
    } else {
      // Low risk - single factor may be sufficient for certain operations
      return {
        required: false,
        methods: [],
        minimumMethods: 0,
        stepUp: false,
        timeout: 3600 // 1 hour
      }
    }
  }
  
  private async calculateRiskFactors(context: AuthContext): Promise&lt;RiskFactor[]&gt; {
    return await Promise.all([
      // Geographic location risk
      this.assessLocationRisk(context.clientIP, context.user.id),
      
      // Device risk assessment
      this.assessDeviceRisk(context.deviceFingerprint, context.user.id),
      
      // Temporal pattern analysis
      this.assessTemporalRisk(context.timestamp, context.user.id),
      
      // Behavioral analysis
      this.assessBehavioralRisk(context.sessionData, context.user.id),
      
      // Network risk assessment
      this.assessNetworkRisk(context.networkInfo),
      
      // Application-specific risk
      this.assessApplicationRisk(context.requestedAction, context.resourceSensitivity)
    ])
  }
  
  async setupMFAMethods(userId: string): Promise&lt;MFASetupResult&gt; {
    const availableMethods = await this.getAvailableMFAMethods()
    const userPreferences = await this.getUserMFAPreferences(userId)
    
    const recommendedMethods = this.recommendMFAMethods(userPreferences, {
      securityLevel: 'high',
      usabilityWeight: 0.3,
      securityWeight: 0.7
    })
    
    return {
      availableMethods,
      recommendedMethods,
      setupInstructions: this.generateSetupInstructions(recommendedMethods),
      backupCodes: await this.generateBackupCodes(userId, 10),
      enrollmentDeadline: new Date(Date.now() + 7 * 24 * 60 * 60 * 1000) // 7 days
    }
  }
}
</code></pre>
<h3 id="hardware-token-integration-1"><a class="header" href="#hardware-token-integration-1">Hardware Token Integration</a></h3>
<pre><code class="language-typescript">// security/hardware-tokens.ts
export class HardwareTokenManager {
  
  async registerHardwareToken(userId: string, tokenInfo: HardwareTokenInfo): Promise&lt;TokenRegistration&gt; {
    // Validate token authenticity
    const tokenValidation = await this.validateTokenAuthenticity(tokenInfo)
    if (!tokenValidation.isValid) {
      throw new InvalidTokenError('Hardware token validation failed')
    }
    
    // Generate token-specific configuration
    const tokenConfig = {
      userId,
      tokenId: tokenInfo.id,
      tokenType: tokenInfo.type, // YubiKey, RSA SecurID, etc.
      publicKey: tokenInfo.publicKey,
      certificateChain: tokenInfo.certificateChain,
      
      // Security configuration
      pinRequired: true,
      touchRequired: tokenInfo.capabilities.includes('touch'),
      biometricRequired: tokenInfo.capabilities.includes('biometric'),
      
      // Usage policies
      maxConsecutiveFailures: 3,
      lockoutDuration: 900, // 15 minutes
      inactivityTimeout: 300, // 5 minutes
      
      // Attestation and verification
      attestationCertificate: tokenInfo.attestationCertificate,
      verificationMethod: 'FIDO2',
      
      registeredAt: new Date(),
      expiresAt: new Date(Date.now() + 3 * 365 * 24 * 60 * 60 * 1000) // 3 years
    }
    
    // Store token configuration securely
    await this.storeTokenConfig(tokenConfig)
    
    // Generate backup authentication codes
    const backupCodes = await this.generateBackupCodes(userId, 10)
    
    return {
      tokenId: tokenInfo.id,
      registrationSuccessful: true,
      backupCodes,
      setupInstructions: this.generateTokenSetupInstructions(tokenInfo.type),
      testVerificationRequired: true
    }
  }
  
  async verifyHardwareToken(
    userId: string, 
    tokenId: string, 
    challenge: string, 
    response: TokenResponse
  ): Promise&lt;TokenVerificationResult&gt; {
    
    const tokenConfig = await this.getTokenConfig(userId, tokenId)
    if (!tokenConfig) {
      throw new TokenNotFoundError('Hardware token not registered')
    }
    
    // Verify token response against challenge
    const verificationResult = await this.verifyTokenResponse(
      challenge,
      response,
      tokenConfig.publicKey
    )
    
    if (!verificationResult.isValid) {
      await this.recordFailedAttempt(userId, tokenId)
      
      // Check for lockout condition
      const failureCount = await this.getConsecutiveFailures(userId, tokenId)
      if (failureCount &gt;= tokenConfig.maxConsecutiveFailures) {
        await this.lockoutToken(userId, tokenId, tokenConfig.lockoutDuration)
        throw new TokenLockoutError('Hardware token locked due to repeated failures')
      }
      
      throw new InvalidTokenResponseError('Hardware token verification failed')
    }
    
    // Reset failure counter on successful verification
    await this.resetFailureCounter(userId, tokenId)
    
    // Update token usage statistics
    await this.updateTokenUsage(userId, tokenId, {
      lastUsed: new Date(),
      usageCount: (tokenConfig.usageCount || 0) + 1
    })
    
    return {
      verified: true,
      tokenId,
      challengeId: challenge,
      verifiedAt: new Date(),
      trustScore: this.calculateTokenTrustScore(tokenConfig, verificationResult)
    }
  }
}
</code></pre>
<h2 id="behavioral-analysis-and-monitoring-1"><a class="header" href="#behavioral-analysis-and-monitoring-1">Behavioral Analysis and Monitoring</a></h2>
<h3 id="user-behavior-analytics-1"><a class="header" href="#user-behavior-analytics-1">User Behavior Analytics</a></h3>
<pre><code class="language-typescript">// security/behavior-analytics.ts
export class UserBehaviorAnalytics {
  
  async analyzeUserBehavior(userId: string, session: UserSession): Promise&lt;BehaviorAnalysis&gt; {
    const behaviorHistory = await this.getUserBehaviorHistory(userId, 30) // 30 days
    
    const analyses = await Promise.all([
      this.analyzeLoginPatterns(session, behaviorHistory.loginPatterns),
      this.analyzeTemplateUsagePatterns(session, behaviorHistory.templateUsage),
      this.analyzeNetworkPatterns(session, behaviorHistory.networkPatterns),
      this.analyzeDevicePatterns(session, behaviorHistory.devicePatterns),
      this.analyzeApplicationUsagePatterns(session, behaviorHistory.applicationUsage)
    ])
    
    const anomalies = this.detectAnomalies(analyses)
    const riskScore = this.calculateBehavioralRiskScore(anomalies)
    
    // Machine learning-based anomaly detection
    const mlAnomalies = await this.runMLAnomalyDetection(userId, session, behaviorHistory)
    
    const combinedAnalysis = {
      userId,
      sessionId: session.id,
      timestamp: new Date(),
      
      riskScore,
      anomalies: [...anomalies, ...mlAnomalies],
      
      behaviorMetrics: {
        loginFrequency: analyses[0].metrics,
        templateUsageFrequency: analyses[1].metrics,
        networkConsistency: analyses[2].metrics,
        deviceConsistency: analyses[3].metrics,
        applicationConsistency: analyses[4].metrics
      },
      
      recommendations: this.generateSecurityRecommendations(anomalies, riskScore),
      
      confidence: this.calculateConfidenceScore(analyses, behaviorHistory.dataPoints)
    }
    
    // Store analysis for future reference
    await this.storeBehaviorAnalysis(combinedAnalysis)
    
    // Trigger alerts for high-risk scenarios
    if (riskScore &gt;= 0.8) {
      await this.triggerHighRiskAlert(combinedAnalysis)
    }
    
    return combinedAnalysis
  }
  
  private async runMLAnomalyDetection(
    userId: string, 
    session: UserSession, 
    history: BehaviorHistory
  ): Promise&lt;MLAnomaly[]&gt; {
    
    // Feature extraction for ML model
    const features = this.extractBehaviorFeatures(session, history)
    
    // Run multiple ML models for different anomaly types
    const modelResults = await Promise.all([
      this.runIsolationForest(features), // Unsupervised anomaly detection
      this.runOneClassSVM(features),     // Outlier detection
      this.runLSTMAnomaly(features),     // Sequential pattern anomalies
      this.runAutoencoderAnomaly(features) // Reconstruction-based anomalies
    ])
    
    // Ensemble voting for final anomaly determination
    const anomalies = this.ensembleVoting(modelResults, features)
    
    return anomalies.map(anomaly =&gt; ({
      type: 'ml-detected',
      confidence: anomaly.confidence,
      description: anomaly.description,
      severity: this.classifySeverity(anomaly.score),
      modelUsed: anomaly.model,
      features: anomaly.contributingFeatures
    }))
  }
  
  async setupRealTimeMonitoring(userId: string): Promise&lt;MonitoringConfig&gt; {
    return {
      enabled: true,
      
      // Real-time analysis triggers
      triggers: [
        {
          event: 'login',
          analysis: ['location', 'device', 'timing'],
          threshold: 0.7,
          action: 'additional-verification'
        },
        {
          event: 'template-generation',
          analysis: ['frequency', 'volume', 'sensitivity'],
          threshold: 0.8,
          action: 'step-up-authentication'
        },
        {
          event: 'configuration-change',
          analysis: ['authorization', 'pattern', 'impact'],
          threshold: 0.6,
          action: 'approval-required'
        }
      ],
      
      // Continuous monitoring
      monitoring: {
        sessionDuration: true,
        activityPatterns: true,
        resourceAccess: true,
        dataExfiltration: true,
        privilegeEscalation: true
      },
      
      // Alert configuration
      alerting: {
        channels: ['email', 'slack', 'pagerduty'],
        escalation: {
          level1: { threshold: 0.6, response: '5m' },
          level2: { threshold: 0.8, response: '2m' },
          level3: { threshold: 0.95, response: '30s' }
        }
      }
    }
  }
}
</code></pre>
<h3 id="security-event-monitoring-1"><a class="header" href="#security-event-monitoring-1">Security Event Monitoring</a></h3>
<pre><code class="language-typescript">// security/event-monitoring.ts
export class SecurityEventMonitor {
  
  async initializeEventMonitoring(): Promise&lt;EventMonitoringSystem&gt; {
    const monitoring = {
      // Security events to monitor
      events: {
        authentication: [
          'login-attempt',
          'login-success',
          'login-failure',
          'mfa-challenge',
          'mfa-success',
          'mfa-failure',
          'password-change',
          'account-lockout'
        ],
        
        authorization: [
          'permission-granted',
          'permission-denied',
          'privilege-escalation-attempt',
          'role-change',
          'policy-violation'
        ],
        
        dataAccess: [
          'template-access',
          'configuration-read',
          'sensitive-data-access',
          'bulk-data-export',
          'unauthorized-access-attempt'
        ],
        
        systemSecurity: [
          'configuration-change',
          'security-policy-update',
          'encryption-key-rotation',
          'certificate-renewal',
          'vulnerability-detected'
        ]
      },
      
      // Real-time processing pipeline
      processing: {
        ingestion: {
          sources: ['application-logs', 'system-logs', 'network-logs', 'security-devices'],
          format: 'structured-json',
          encryption: true,
          compression: true
        },
        
        enrichment: {
          geoLocation: true,
          threatIntelligence: true,
          userContext: true,
          deviceContext: true,
          riskScoring: true
        },
        
        correlation: {
          timeWindow: 300, // 5 minutes
          rules: await this.loadCorrelationRules(),
          machineLearning: true,
          baselineComparison: true
        }
      },
      
      // Response automation
      responseAutomation: {
        immediateResponse: {
          'multiple-failed-logins': 'account-lockout',
          'privilege-escalation': 'session-termination',
          'suspicious-data-access': 'additional-verification',
          'malware-detected': 'quarantine-device'
        },
        
        escalationRules: {
          'high-risk-user-activity': {
            level1: 'security-team-alert',
            level2: 'manager-notification',
            level3: 'incident-response-activation'
          }
        }
      }
    }
    
    // Start real-time monitoring
    const eventStream = await this.initializeEventStream(monitoring)
    const alertingSystem = await this.initializeAlerting(monitoring)
    const responseSystem = await this.initializeAutomatedResponse(monitoring)
    
    return {
      monitoring,
      eventStream,
      alertingSystem,
      responseSystem,
      healthCheck: () =&gt; this.performHealthCheck([eventStream, alertingSystem, responseSystem])
    }
  }
  
  async generateSecurityDashboard(): Promise&lt;SecurityDashboard&gt; {
    const timeRange = { start: new Date(Date.now() - 24 * 60 * 60 * 1000), end: new Date() }
    
    const [
      threatMetrics,
      complianceMetrics,
      performanceMetrics,
      incidentMetrics
    ] = await Promise.all([
      this.getThreatMetrics(timeRange),
      this.getComplianceMetrics(timeRange),
      this.getPerformanceMetrics(timeRange),
      this.getIncidentMetrics(timeRange)
    ])
    
    return {
      overview: {
        securityScore: this.calculateOverallSecurityScore({
          threatMetrics,
          complianceMetrics,
          incidentMetrics
        }),
        
        threatLevel: this.assessCurrentThreatLevel(threatMetrics),
        complianceStatus: complianceMetrics.overallScore,
        systemHealth: performanceMetrics.healthScore
      },
      
      metrics: {
        threats: {
          detected: threatMetrics.detectedThreats,
          blocked: threatMetrics.blockedThreats,
          resolved: threatMetrics.resolvedThreats,
          falsePositives: threatMetrics.falsePositives
        },
        
        authentication: {
          successRate: this.calculateAuthSuccessRate(timeRange),
          mfaAdoptionRate: this.calculateMFAAdoption(),
          averageAuthTime: performanceMetrics.authTime
        },
        
        incidents: {
          open: incidentMetrics.openIncidents,
          resolved: incidentMetrics.resolvedIncidents,
          averageResolutionTime: incidentMetrics.averageResolutionTime,
          criticalIncidents: incidentMetrics.criticalIncidents
        }
      },
      
      alerts: {
        active: await this.getActiveAlerts(),
        recent: await this.getRecentAlerts(timeRange),
        trends: await this.getAlertTrends(timeRange)
      },
      
      recommendations: await this.generateSecurityRecommendations()
    }
  }
}
</code></pre>
<h2 id="compliance-integration-1"><a class="header" href="#compliance-integration-1">Compliance Integration</a></h2>
<h3 id="automated-compliance-validation-1"><a class="header" href="#automated-compliance-validation-1">Automated Compliance Validation</a></h3>
<pre><code class="language-typescript">// security/compliance-validation.ts
export class ComplianceValidator {
  
  async validateSOC2Compliance(): Promise&lt;SOC2ComplianceReport&gt; {
    const controls = await this.evaluateSOC2Controls()
    
    return {
      controlResults: {
        // Common Criteria (CC)
        CC1: await this.validateControlEnvironment(),
        CC2: await this.validateCommunicationAndInformation(),
        CC3: await this.validateRiskAssessment(),
        CC4: await this.validateMonitoringActivities(),
        CC5: await this.validateControlActivities(),
        CC6: await this.validateLogicalAndPhysicalAccess(),
        CC7: await this.validateSystemOperations(),
        CC8: await this.validateChangeManagement(),
        CC9: await this.validateRiskMitigation(),
        
        // Additional Criteria for Security
        A1: await this.validateAccessControls()
      },
      
      overallCompliance: this.calculateComplianceScore(controls),
      findings: controls.flatMap(control =&gt; control.findings),
      recommendations: this.generateComplianceRecommendations(controls),
      
      report: {
        generatedAt: new Date(),
        period: this.getCurrentReportingPeriod(),
        auditor: 'automated-system',
        nextReview: this.calculateNextReviewDate()
      }
    }
  }
  
  async validateHIPAACompliance(): Promise&lt;HIPAAComplianceReport&gt; {
    return {
      administrativeSafeguards: await this.validateAdministrativeSafeguards(),
      physicalSafeguards: await this.validatePhysicalSafeguards(),
      technicalSafeguards: await this.validateTechnicalSafeguards(),
      
      // Specific HIPAA requirements
      riskAssessment: await this.validateHIPAARiskAssessment(),
      auditControls: await this.validateAuditControls(),
      integrityControls: await this.validateIntegrityControls(),
      transmissionSecurity: await this.validateTransmissionSecurity(),
      
      breachNotification: {
        procedures: await this.validateBreachProcedures(),
        timeline: await this.validateNotificationTimeline(),
        documentation: await this.validateBreachDocumentation()
      }
    }
  }
  
  private async validateTechnicalSafeguards(): Promise&lt;TechnicalSafeguards&gt; {
    return {
      accessControl: {
        uniqueUserIdentification: await this.validateUniqueUserIDs(),
        emergencyAccessProcedure: await this.validateEmergencyAccess(),
        automaticLogoff: await this.validateAutomaticLogoff(),
        encryptionDecryption: await this.validateEncryptionControls()
      },
      
      auditControls: {
        auditLogsEnabled: await this.validateAuditLogging(),
        auditLogReview: await this.validateAuditReview(),
        auditLogProtection: await this.validateAuditProtection()
      },
      
      integrity: {
        dataIntegrityControls: await this.validateDataIntegrity(),
        transmissionIntegrity: await this.validateTransmissionIntegrity()
      },
      
      personOrEntityAuthentication: {
        userAuthentication: await this.validateUserAuthentication(),
        deviceAuthentication: await this.validateDeviceAuthentication()
      },
      
      transmissionSecurity: {
        endToEndEncryption: await this.validateE2EEncryption(),
        networkSecurityControls: await this.validateNetworkSecurity()
      }
    }
  }
}
</code></pre>
<h2 id="next-steps-1"><a class="header" href="#next-steps-1">Next Steps</a></h2>
<p>The security architecture provides a comprehensive foundation for enterprise deployments. For implementation details, see:</p>
<ul>
<li><a href="../architecture/multi-tenant.html">Multi-Tenant Architecture</a></li>
<li><a href="../compliance/frameworks.html">Compliance Frameworks</a></li>
<li><a href="../deployment/overview.html">Enterprise Deployment Overview</a></li>
<li><a href="../patterns/fortune-5.html">Fortune 5 Patterns</a></li>
</ul>


        <!-- Performance monitoring -->
        <script>
            // Simple performance monitoring
            window.addEventListener('load', function() {
                if ('performance' in window) {
                    setTimeout(function() {
                        const loadTime = performance.timing.loadEventEnd - performance.timing.navigationStart;
                        console.log('üìä Page loaded in ' + loadTime + 'ms');
                    }, 0);
                }
            });
        </script>

        <!-- Service Worker for offline support -->
        <script>
            if ('serviceWorker' in navigator) {
                navigator.serviceWorker.register('../../sw.js')
                    .then(function(registration) {
                        console.log('üì± SW registered with scope:', registration.scope);
                    })
                    .catch(function(error) {
                        console.log('‚ùå SW registration failed:', error);
                    });
            }
        </script>
    </body>
</html>
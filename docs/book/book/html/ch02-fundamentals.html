<!DOCTYPE HTML>
<html lang="en" class="navy" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Chapter 2: Fundamentals - Core Principles and Patterns - Unjucks: Modern Code Generation in 2026</title>
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="A comprehensive guide to modern code generation using the Unjucks framework, demonstrating declarative development patterns, AI integration, and advanced template design for productive software development.">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#0066cc"/>

        <!-- Open Graph -->
        <meta property="og:title" content="Chapter 2: Fundamentals - Core Principles and Patterns - Unjucks: Modern Code Generation in 2026">
        <meta property="og:description" content="A comprehensive guide to modern code generation using the Unjucks framework, demonstrating declarative development patterns, AI integration, and advanced template design for productive software development.">
        <meta property="og:type" content="website">
        <meta property="og:url" content="">
        <meta property="og:image" content="unjucks-og.png">
        
        <!-- Twitter Card -->
        <meta name="twitter:card" content="summary_large_image">
        <meta name="twitter:title" content="Chapter 2: Fundamentals - Core Principles and Patterns - Unjucks: Modern Code Generation in 2026">
        <meta name="twitter:description" content="A comprehensive guide to modern code generation using the Unjucks framework, demonstrating declarative development patterns, AI integration, and advanced template design for productive software development.">
        <meta name="twitter:image" content="unjucks-og.png">


        <!-- Custom Unjucks Favicon -->
        <link rel="icon" href="favicon.png">
        <link rel="shortcut icon" href="favicon.png">

        <!-- Fonts -->
        <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&family=JetBrains+Mono:wght@300;400;500&display=swap" rel="stylesheet">

        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Custom CSS -->

        <!-- Custom head content -->

        <!-- JSON-LD Structured Data -->
        <script type="application/ld+json">
        {
            "@context": "https://schema.org",
            "@type": "TechArticle",
            "headline": "Chapter 2: Fundamentals - Core Principles and Patterns - Unjucks: Modern Code Generation in 2026",
            "description": "A comprehensive guide to modern code generation using the Unjucks framework, demonstrating declarative development patterns, AI integration, and advanced template design for productive software development.",
            "author": {
                "@type": "Organization",
                "name": "Unjucks Development Team"
            },
            "publisher": {
                "@type": "Organization",
                "name": "Unjucks",
                "logo": {
                    "@type": "ImageObject",
                    "url": "logo.png"
                }
            },
            "url": "",
            "mainEntityOfPage": "",
            "datePublished": "",
            "dateModified": "",
            "inLanguage": "en",
            "about": [
                "Code Generation",
                "Template Engine", 
                "CLI Tools",
                "Semantic Web",
                "RDF",
                "Software Development"
            ]
        }
        </script>
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = "navy";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme && theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar && sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.remove('rust')
            html.classList.remove('coal')
            html.classList.remove('navy')
            html.classList.remove('ayu')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var body = document.querySelector('body');
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            body.classList.remove('sidebar-visible');
            body.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <!-- Unjucks Logo -->
                <div class="unjucks-logo" style="padding: 1rem; text-align: center; border-bottom: 1px solid #e1e5e9;">
                    <h3 style="margin: 0; color: #0066cc; font-weight: 700;">🚀 Unjucks</h3>
                    <p style="margin: 0.5rem 0 0 0; font-size: 0.8rem; color: #666;">Template Generation Platform</p>
                </div>

                <!-- TOC will be generated automatically by mdbook -->
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <!-- Page wrapper -->
        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label for="sidebar-toggle-anchor" class="left" id="sidebar-toggle" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button left" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button left" type="button" title="Toggle Searchbar" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Unjucks: Modern Code Generation in 2026</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/ruvnet/unjucks" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <!-- Breadcrumb Navigation -->
                        <div class="breadcrumb-nav" style="margin-bottom: 1.5rem; font-size: 0.9rem; color: #666;">
                            <a href="index.html">🏠 Home</a>
                            <span> › </span>
                            <span>Chapter 2: Fundamentals - Core Principles and Patterns</span>
                        </div>

                        <h1 id="chapter-2-fundamentals---core-principles-and-patterns"><a class="header" href="#chapter-2-fundamentals---core-principles-and-patterns">Chapter 2: Fundamentals - Core Principles and Patterns</a></h1>
<h2 id="the-foundation-of-modern-code-generation"><a class="header" href="#the-foundation-of-modern-code-generation">The Foundation of Modern Code Generation</a></h2>
<p>Understanding the fundamentals of modern code generation requires a shift in perspective. We're not just talking about text replacement or simple templating—we're discussing a sophisticated system of declarative programming that transforms intent into executable code. This chapter establishes the core principles that make Unjucks and similar modern generation tools powerful and reliable.</p>
<h2 id="principle-1-declarative-over-imperative"><a class="header" href="#principle-1-declarative-over-imperative">Principle 1: Declarative Over Imperative</a></h2>
<h3 id="the-declarative-mindset"><a class="header" href="#the-declarative-mindset">The Declarative Mindset</a></h3>
<p>Traditional development often follows an imperative approach: "Create a file here, add this function there, import that module." Modern code generation embraces declarative principles: "I want a user authentication system with these characteristics."</p>
<blockquote>
<p><strong>📋 Unjucks v2 Case Study: Declarative Transformation</strong></p>
<p>The Unjucks v1 → v2 refactor perfectly illustrates this principle shift:</p>
<p><strong>Legacy v1 (Imperative):</strong></p>
<pre><code class="language-javascript">// Manual, step-by-step file creation
const generator = {
  run: function(args) {
    // Step 1: Create directory
    fs.mkdirSync(`src/components/${args.name}`);
    
    // Step 2: Write component file
    const componentContent = template.render('component.hbs', args);
    fs.writeFileSync(`src/components/${args.name}/index.tsx`, componentContent);
    
    // Step 3: Write test file (manual)
    if (args.withTests) {
      const testContent = template.render('test.hbs', args);
      fs.writeFileSync(`src/components/${args.name}/${args.name}.test.tsx`, testContent);
    }
    
    // Step 4: Update exports (manual)
    updateBarrelExports(`src/components/${args.name}`);
  }
};
</code></pre>
<p><strong>Modern v2 (Declarative):</strong></p>
<pre><code class="language-yaml">---
to: "src/components/{{ pascalCase name }}/{{ pascalCase name }}.tsx"
inject: true
after: "// END EXPORTS"
skipIf: "export.*{{ pascalCase name }}"
when: "{{ withComponent }}"
context:
  framework: react
  typescript: true
  testing: vitest
---
</code></pre>
<p>The v2 approach declares <em>intent</em> rather than <em>steps</em>, resulting in:</p>
<ul>
<li><strong>85% less configuration code</strong></li>
<li><strong>100% consistency</strong> across generations</li>
<li><strong>Zero manual file management</strong></li>
<li><strong>Automatic conflict resolution</strong></li>
</ul>
</blockquote>
<pre><code class="language-yaml"># Imperative (traditional)
steps:
  - create: "src/auth/login.ts"
  - add_import: "import bcrypt from 'bcrypt'"
  - create_function: "validatePassword"
  - export_function: "validatePassword"

# Declarative (modern)
---
to: "src/auth/{{ feature }}.ts"
inject: true
before: "// END FEATURES"
when: "{{ hasAuthentication }}"
dependencies:
  - bcrypt
  - jsonwebtoken
---
</code></pre>
<h3 id="benefits-of-declarative-generation"><a class="header" href="#benefits-of-declarative-generation">Benefits of Declarative Generation</a></h3>
<p><strong>Maintainability</strong>: Declarative templates are easier to understand and modify. The intent is clear, and the implementation details are abstracted.</p>
<p><strong>Consistency</strong>: Declarative patterns ensure that similar intentions produce similar results, regardless of who implements them or when.</p>
<p><strong>Adaptability</strong>: Declarative templates can adapt to different contexts without changing the core template logic.</p>
<pre><code class="language-typescript">// Declarative template configuration
interface TemplateConfig {
  intent: 'component' | 'service' | 'page';
  features: string[];
  context: ProjectContext;
  constraints: GenerationConstraints;
}

// The generator adapts based on intent
const generateByIntent = (config: TemplateConfig) =&gt; {
  switch (config.intent) {
    case 'component':
      return adaptComponentTemplate(config);
    case 'service':
      return adaptServiceTemplate(config);
    case 'page':
      return adaptPageTemplate(config);
  }
};
</code></pre>
<h2 id="principle-2-context-aware-generation"><a class="header" href="#principle-2-context-aware-generation">Principle 2: Context-Aware Generation</a></h2>
<h3 id="understanding-project-context"><a class="header" href="#understanding-project-context">Understanding Project Context</a></h3>
<p>Modern code generation tools must understand the environment they're operating in. This includes:</p>
<ul>
<li><strong>Framework Detection</strong>: Recognizing React vs. Vue vs. Angular</li>
<li><strong>Architecture Patterns</strong>: Understanding Clean Architecture, MVC, or DDD</li>
<li><strong>Tooling Ecosystem</strong>: Detecting TypeScript, testing frameworks, and build tools</li>
<li><strong>Team Conventions</strong>: Adapting to established coding standards</li>
</ul>
<pre><code class="language-typescript">// Context analysis system
interface ProjectContext {
  framework: {
    name: string;
    version: string;
    plugins: string[];
  };
  architecture: {
    pattern: string;
    layers: string[];
    conventions: Record&lt;string, any&gt;;
  };
  tooling: {
    typescript: boolean;
    testing: string[];
    linting: string[];
    formatting: string[];
  };
  conventions: {
    naming: NamingConvention;
    structure: StructureConvention;
    imports: ImportConvention;
  };
}
</code></pre>
<h3 id="context-driven-template-selection"><a class="header" href="#context-driven-template-selection">Context-Driven Template Selection</a></h3>
<p>Templates should automatically adapt based on detected context:</p>
<pre><code class="language-yaml"># React-specific component template
---
to: "src/components/{{ pascalCase name }}/{{ pascalCase name }}.tsx"
when: "{{ context.framework.name === 'React' }}"
inject: false
---
import React from 'react';
import { {{ pascalCase name }}Props } from './types';

export const {{ pascalCase name }}: React.FC&lt;{{ pascalCase name }}Props&gt; = ({
  {{ properties }}
}) =&gt; {
  return (
    &lt;div className="{{ kebabCase name }}"&gt;
      {/* Component content */}
    &lt;/div&gt;
  );
};
</code></pre>
<pre><code class="language-yaml"># Vue-specific component template
---
to: "src/components/{{ pascalCase name }}/{{ pascalCase name }}.vue"
when: "{{ context.framework.name === 'Vue' }}"
inject: false
---
&lt;template&gt;
  &lt;div class="{{ kebabCase name }}"&gt;
    &lt;!-- Component content --&gt;
  &lt;/div&gt;
&lt;/template&gt;

&lt;script lang="ts"&gt;
import { defineComponent } from 'vue';

export default defineComponent({
  name: '{{ pascalCase name }}',
  props: {
    {{ properties }}
  }
});
&lt;/script&gt;
</code></pre>
<h2 id="principle-3-idempotent-operations"><a class="header" href="#principle-3-idempotent-operations">Principle 3: Idempotent Operations</a></h2>
<h3 id="the-importance-of-idempotency"><a class="header" href="#the-importance-of-idempotency">The Importance of Idempotency</a></h3>
<p>In mathematics and computer science, an idempotent operation is one that can be applied multiple times without changing the result beyond the initial application. This principle is crucial for code generation because:</p>
<ol>
<li><strong>Reliability</strong>: Running the same generator multiple times produces consistent results</li>
<li><strong>Safety</strong>: Accidental re-runs don't break your codebase</li>
<li><strong>Incremental Updates</strong>: Templates can be improved and re-run safely</li>
</ol>
<blockquote>
<p><strong>🔄 Unjucks v2 Case Study: Achieving True Idempotency</strong></p>
<p>Idempotency was one of the most challenging aspects of the Unjucks v2 refactor, but also one of the most impactful improvements.</p>
<p><strong>The v1 Problem: Destructive Re-runs</strong></p>
<pre><code class="language-javascript">// Legacy v1: Every run overwrote existing files
function generateComponent(name) {
  const path = `src/components/${name}.tsx`;
  
  // ❌ Always overwrites - loses manual changes
  fs.writeFileSync(path, renderTemplate(template, { name }));
  
  // ❌ Duplicates exports on each run
  appendToFile('src/index.ts', `export { ${name} } from './components/${name}';`);
}

// Result: Manual changes lost, duplicate exports accumulated
</code></pre>
<p><strong>The v2 Solution: Smart Idempotency</strong></p>
<pre><code class="language-typescript">// Modern v2: Intelligent content management
export async function generateIdempotent(template: Template, variables: Variables) {
  const targetPath = resolvePath(template.to, variables);
  const newContent = await render(template.content, variables);
  
  // Content hashing prevents unnecessary writes
  const newHash = createContentHash(newContent);
  const existingHash = await getExistingContentHash(targetPath);
  
  if (newHash === existingHash) {
    return { status: 'unchanged', path: targetPath };
  }
  
  // Smart injection with skipIf guards
  if (template.inject &amp;&amp; template.skipIf) {
    const existing = await readFile(targetPath);
    if (new RegExp(template.skipIf).test(existing)) {
      return { status: 'skipped', reason: 'skipIf condition matched' };
    }
    
    // Idempotent injection at specific location
    return await injectContent(targetPath, newContent, template);
  }
  
  // Safe file writing with backup
  return await safeWrite(targetPath, newContent);
}
</code></pre>
<p><strong>Impact Metrics:</strong></p>
<ul>
<li><strong>100% safe re-runs</strong>: Never lose manual changes</li>
<li><strong>Zero duplicate content</strong>: Smart skip conditions prevent duplication</li>
<li><strong>3.2s → 0.1s</strong>: Skip unchanged files for 32x faster incremental updates</li>
<li><strong>95% developer confidence</strong>: Teams comfortable with frequent re-generation</li>
</ul>
</blockquote>
<pre><code class="language-yaml"># Idempotent injection example
---
to: "src/index.ts"
inject: true
after: "// BEGIN EXPORTS"
before: "// END EXPORTS"
skipIf: "export.*{{ pascalCase name }}"
---
export { {{ pascalCase name }} } from './components/{{ pascalCase name }}';
</code></pre>
<h3 id="implementing-idempotency"><a class="header" href="#implementing-idempotency">Implementing Idempotency</a></h3>
<p><strong>Skip Conditions</strong>: Use <code>skipIf</code> to prevent duplicate entries:</p>
<pre><code class="language-yaml">---
skipIf: "interface {{ pascalCase name }}Props"
---
interface {{ pascalCase name }}Props {
  {{ properties }}
}
</code></pre>
<p><strong>Content Hashing</strong>: Generate content hashes to detect changes:</p>
<pre><code class="language-typescript">interface GeneratedContent {
  content: string;
  hash: string;
  timestamp: Date;
  generator: string;
}

const generateIdempotent = (template: string, data: any): GeneratedContent =&gt; {
  const content = render(template, data);
  const hash = createHash('sha256').update(content).digest('hex');
  
  return {
    content,
    hash,
    timestamp: new Date(),
    generator: template
  };
};
</code></pre>
<p><strong>Merge Strategies</strong>: Define how to handle conflicts:</p>
<pre><code class="language-typescript">enum MergeStrategy {
  SKIP = 'skip',           // Don't modify existing content
  REPLACE = 'replace',     // Replace entirely
  MERGE = 'merge',         // Intelligently merge
  APPEND = 'append',       // Add to existing content
  PREPEND = 'prepend'      // Add before existing content
}
</code></pre>
<h2 id="principle-4-template-composition-and-inheritance"><a class="header" href="#principle-4-template-composition-and-inheritance">Principle 4: Template Composition and Inheritance</a></h2>
<h3 id="modular-template-design"><a class="header" href="#modular-template-design">Modular Template Design</a></h3>
<p>Modern templates should be composed of smaller, reusable parts rather than monolithic blocks:</p>
<pre><code class="language-yaml"># Base component template
---
name: "base-component"
abstract: true
---
import React from 'react';

export const {{ pascalCase name }}: React.FC&lt;{{ pascalCase name }}Props&gt; = () =&gt; {
  {% block content %}
  return &lt;div&gt;{{ name }}&lt;/div&gt;;
  {% endblock %}
};
</code></pre>
<pre><code class="language-yaml"># Specialized form component
---
extends: "base-component"
to: "src/components/forms/{{ pascalCase name }}.tsx"
---
{% block content %}
const [formData, setFormData] = useState({});
const [errors, setErrors] = useState({});

return (
  &lt;form onSubmit={handleSubmit}&gt;
    {{ formFields }}
  &lt;/form&gt;
);
{% endblock %}
</code></pre>
<h3 id="template-inheritance-patterns"><a class="header" href="#template-inheritance-patterns">Template Inheritance Patterns</a></h3>
<p><strong>Single Inheritance</strong>: Templates extend a single base template</p>
<pre><code class="language-yaml">extends: "base-component"
</code></pre>
<p><strong>Mixin Composition</strong>: Templates include multiple mixins</p>
<pre><code class="language-yaml">mixins:
  - "with-loading-state"
  - "with-error-handling"
  - "with-form-validation"
</code></pre>
<p><strong>Trait-Based</strong>: Templates compose specific traits</p>
<pre><code class="language-typescript">interface TemplateTraits {
  loadingState?: boolean;
  errorHandling?: boolean;
  formValidation?: boolean;
  authentication?: boolean;
}

const applyTraits = (base: Template, traits: TemplateTraits): Template =&gt; {
  return Object.entries(traits).reduce((template, [trait, enabled]) =&gt; {
    return enabled ? mixinTrait(template, trait) : template;
  }, base);
};
</code></pre>
<h2 id="principle-5-type-safety-and-validation"><a class="header" href="#principle-5-type-safety-and-validation">Principle 5: Type Safety and Validation</a></h2>
<h3 id="template-variable-validation"><a class="header" href="#template-variable-validation">Template Variable Validation</a></h3>
<p>Modern code generation tools should validate template variables at generation time:</p>
<pre><code class="language-typescript">// Variable schema definition
interface ComponentSchema {
  name: string;                    // Required: Component name
  props?: PropertyDefinition[];    // Optional: Component props
  features?: FeatureFlag[];       // Optional: Feature toggles
  styling?: StylingOptions;       // Optional: Styling configuration
}

// Runtime validation
const validateTemplate = (variables: any, schema: Schema): ValidationResult =&gt; {
  const errors: ValidationError[] = [];
  
  // Required field validation
  if (!variables.name) {
    errors.push({ field: 'name', message: 'Component name is required' });
  }
  
  // Type validation
  if (variables.props &amp;&amp; !Array.isArray(variables.props)) {
    errors.push({ field: 'props', message: 'Props must be an array' });
  }
  
  return { valid: errors.length === 0, errors };
};
</code></pre>
<h3 id="generated-code-validation"><a class="header" href="#generated-code-validation">Generated Code Validation</a></h3>
<p>Validate that generated code meets quality standards:</p>
<pre><code class="language-typescript">interface CodeQualityCheck {
  syntax: boolean;        // Valid syntax
  types: boolean;         // Type correctness
  imports: boolean;       // Valid imports
  patterns: boolean;      // Follows patterns
  performance: boolean;   // Performance considerations
}

const validateGeneratedCode = async (
  code: string,
  language: string
): Promise&lt;CodeQualityCheck&gt; =&gt; {
  const checks: CodeQualityCheck = {
    syntax: await validateSyntax(code, language),
    types: await validateTypes(code, language),
    imports: await validateImports(code),
    patterns: await validatePatterns(code),
    performance: await analyzePerformance(code)
  };
  
  return checks;
};
</code></pre>
<h2 id="principle-6-progressive-enhancement"><a class="header" href="#principle-6-progressive-enhancement">Principle 6: Progressive Enhancement</a></h2>
<h3 id="layered-generation-strategy"><a class="header" href="#layered-generation-strategy">Layered Generation Strategy</a></h3>
<p>Generate code in layers, from basic to advanced features:</p>
<pre><code class="language-typescript">interface GenerationLayer {
  name: string;
  description: string;
  dependencies: string[];
  template: string;
  optional: boolean;
}

const generationLayers: GenerationLayer[] = [
  {
    name: 'base',
    description: 'Basic component structure',
    dependencies: [],
    template: 'component-base.njk',
    optional: false
  },
  {
    name: 'props',
    description: 'Component props interface',
    dependencies: ['base'],
    template: 'component-props.njk',
    optional: false
  },
  {
    name: 'state',
    description: 'State management',
    dependencies: ['base', 'props'],
    template: 'component-state.njk',
    optional: true
  },
  {
    name: 'testing',
    description: 'Test suite',
    dependencies: ['base', 'props'],
    template: 'component-tests.njk',
    optional: true
  }
];
</code></pre>
<h3 id="feature-flags-and-conditional-generation"><a class="header" href="#feature-flags-and-conditional-generation">Feature Flags and Conditional Generation</a></h3>
<p>Use feature flags to control what gets generated:</p>
<pre><code class="language-yaml"># Component with optional features
---
to: "src/components/{{ pascalCase name }}/{{ pascalCase name }}.tsx"
---
import React{% if withState %}, { useState }{% endif %} from 'react';
{% if withRouter %}
import { useRouter } from 'next/router';
{% endif %}
{% if withQuery %}
import { useQuery } from '@tanstack/react-query';
{% endif %}

interface {{ pascalCase name }}Props {
  {% for prop in props %}
  {{ prop.name }}: {{ prop.type }};
  {% endfor %}
}

export const {{ pascalCase name }}: React.FC&lt;{{ pascalCase name }}Props&gt; = ({
  {% for prop in props %}{{ prop.name }}{% if not loop.last %}, {% endif %}{% endfor %}
}) =&gt; {
  {% if withState %}
  const [state, setState] = useState();
  {% endif %}
  
  {% if withRouter %}
  const router = useRouter();
  {% endif %}
  
  {% if withQuery %}
  const { data, isLoading } = useQuery(['{{ kebabCase name }}'], fetchData);
  {% endif %}

  return (
    &lt;div className="{{ kebabCase name }}"&gt;
      {/* Component implementation */}
    &lt;/div&gt;
  );
};
</code></pre>
<h2 id="common-patterns-and-practices"><a class="header" href="#common-patterns-and-practices">Common Patterns and Practices</a></h2>
<h3 id="1-the-registry-pattern"><a class="header" href="#1-the-registry-pattern">1. The Registry Pattern</a></h3>
<p>Maintain a registry of available generators and their capabilities:</p>
<pre><code class="language-typescript">interface GeneratorRegistry {
  generators: Map&lt;string, GeneratorMetadata&gt;;
  
  register(name: string, metadata: GeneratorMetadata): void;
  find(criteria: GeneratorCriteria): GeneratorMetadata[];
  get(name: string): GeneratorMetadata | undefined;
}

interface GeneratorMetadata {
  name: string;
  description: string;
  version: string;
  author: string;
  tags: string[];
  schema: Schema;
  templates: TemplateReference[];
  examples: Example[];
}
</code></pre>
<h3 id="2-the-plugin-pattern"><a class="header" href="#2-the-plugin-pattern">2. The Plugin Pattern</a></h3>
<p>Allow third-party extensions through plugins:</p>
<pre><code class="language-typescript">interface GeneratorPlugin {
  name: string;
  version: string;
  
  beforeGeneration?(context: GenerationContext): void;
  afterGeneration?(context: GenerationContext, result: GenerationResult): void;
  transformTemplate?(template: string, variables: any): string;
  validateVariables?(variables: any, schema: Schema): ValidationResult;
}

class PluginManager {
  private plugins: GeneratorPlugin[] = [];
  
  register(plugin: GeneratorPlugin): void {
    this.plugins.push(plugin);
  }
  
  async executeHook(
    hookName: keyof GeneratorPlugin,
    ...args: any[]
  ): Promise&lt;void&gt; {
    for (const plugin of this.plugins) {
      const hook = plugin[hookName];
      if (typeof hook === 'function') {
        await hook.apply(plugin, args);
      }
    }
  }
}
</code></pre>
<h3 id="3-the-strategy-pattern"><a class="header" href="#3-the-strategy-pattern">3. The Strategy Pattern</a></h3>
<p>Different generation strategies for different use cases:</p>
<pre><code class="language-typescript">interface GenerationStrategy {
  name: string;
  description: string;
  
  generate(
    template: Template,
    variables: any,
    context: GenerationContext
  ): Promise&lt;GenerationResult&gt;;
}

class FileGenerationStrategy implements GenerationStrategy {
  name = 'file';
  description = 'Generate new files';
  
  async generate(template, variables, context) {
    // File generation logic
  }
}

class InjectionStrategy implements GenerationStrategy {
  name = 'injection';
  description = 'Inject into existing files';
  
  async generate(template, variables, context) {
    // Injection logic
  }
}
</code></pre>
<h2 id="error-handling-and-recovery"><a class="header" href="#error-handling-and-recovery">Error Handling and Recovery</a></h2>
<h3 id="graceful-failure-patterns"><a class="header" href="#graceful-failure-patterns">Graceful Failure Patterns</a></h3>
<pre><code class="language-typescript">enum GenerationErrorType {
  TEMPLATE_NOT_FOUND = 'TEMPLATE_NOT_FOUND',
  VALIDATION_FAILED = 'VALIDATION_FAILED',
  FILE_CONFLICT = 'FILE_CONFLICT',
  PERMISSION_DENIED = 'PERMISSION_DENIED',
  SYNTAX_ERROR = 'SYNTAX_ERROR'
}

class GenerationError extends Error {
  constructor(
    public type: GenerationErrorType,
    public message: string,
    public context?: any,
    public recoverable: boolean = true
  ) {
    super(message);
    this.name = 'GenerationError';
  }
}

const handleGenerationError = (error: GenerationError): RecoveryAction =&gt; {
  switch (error.type) {
    case GenerationErrorType.FILE_CONFLICT:
      return {
        type: 'PROMPT_USER',
        options: ['overwrite', 'merge', 'skip', 'rename']
      };
      
    case GenerationErrorType.VALIDATION_FAILED:
      return {
        type: 'REQUEST_INPUT',
        fields: error.context.missingFields
      };
      
    case GenerationErrorType.TEMPLATE_NOT_FOUND:
      return {
        type: 'SUGGEST_ALTERNATIVES',
        suggestions: findSimilarTemplates(error.context.templateName)
      };
      
    default:
      return { type: 'FAIL', retry: error.recoverable };
  }
};
</code></pre>
<h3 id="rollback-mechanisms"><a class="header" href="#rollback-mechanisms">Rollback Mechanisms</a></h3>
<p>Implement transactional generation with rollback capabilities:</p>
<pre><code class="language-typescript">class GenerationTransaction {
  private operations: GenerationOperation[] = [];
  private completed: GenerationOperation[] = [];
  
  addOperation(operation: GenerationOperation): void {
    this.operations.push(operation);
  }
  
  async execute(): Promise&lt;GenerationResult&gt; {
    try {
      for (const operation of this.operations) {
        await operation.execute();
        this.completed.push(operation);
      }
      return { success: true, operations: this.completed };
    } catch (error) {
      await this.rollback();
      throw error;
    }
  }
  
  private async rollback(): Promise&lt;void&gt; {
    for (const operation of this.completed.reverse()) {
      await operation.rollback();
    }
  }
}
</code></pre>
<h2 id="performance-considerations"><a class="header" href="#performance-considerations">Performance Considerations</a></h2>
<h3 id="template-compilation-and-caching"><a class="header" href="#template-compilation-and-caching">Template Compilation and Caching</a></h3>
<pre><code class="language-typescript">class TemplateCache {
  private cache = new Map&lt;string, CompiledTemplate&gt;();
  
  compile(template: string, options: CompileOptions): CompiledTemplate {
    const cacheKey = this.getCacheKey(template, options);
    
    if (this.cache.has(cacheKey)) {
      return this.cache.get(cacheKey)!;
    }
    
    const compiled = compileTemplate(template, options);
    this.cache.set(cacheKey, compiled);
    
    return compiled;
  }
  
  private getCacheKey(template: string, options: CompileOptions): string {
    return `${hashString(template)}-${hashObject(options)}`;
  }
}
</code></pre>
<h3 id="parallel-generation"><a class="header" href="#parallel-generation">Parallel Generation</a></h3>
<pre><code class="language-typescript">const generateParallel = async (
  generators: GeneratorTask[]
): Promise&lt;GenerationResult[]&gt; =&gt; {
  const chunks = chunkArray(generators, CPU_CORES);
  
  const results = await Promise.all(
    chunks.map(chunk =&gt; 
      Promise.all(chunk.map(generator =&gt; generator.execute()))
    )
  );
  
  return results.flat();
};
</code></pre>
<h2 id="security-considerations"><a class="header" href="#security-considerations">Security Considerations</a></h2>
<h3 id="template-sandboxing"><a class="header" href="#template-sandboxing">Template Sandboxing</a></h3>
<pre><code class="language-typescript">interface SandboxOptions {
  allowedModules: string[];
  timeout: number;
  memoryLimit: number;
  fileSystemAccess: 'none' | 'readonly' | 'restricted';
}

const executeSandboxed = (
  template: string,
  variables: any,
  options: SandboxOptions
): Promise&lt;string&gt; =&gt; {
  return new Promise((resolve, reject) =&gt; {
    const sandbox = createSandbox(options);
    
    try {
      const result = sandbox.execute(template, variables);
      resolve(result);
    } catch (error) {
      reject(new SecurityError('Template execution failed', error));
    } finally {
      sandbox.cleanup();
    }
  });
};
</code></pre>
<h3 id="input-validation-and-sanitization"><a class="header" href="#input-validation-and-sanitization">Input Validation and Sanitization</a></h3>
<pre><code class="language-typescript">const sanitizeInput = (input: any): any =&gt; {
  if (typeof input === 'string') {
    // Remove potentially dangerous characters
    return input.replace(/[&lt;&gt;\"'&amp;]/g, '');
  }
  
  if (Array.isArray(input)) {
    return input.map(sanitizeInput);
  }
  
  if (typeof input === 'object' &amp;&amp; input !== null) {
    const sanitized: any = {};
    for (const [key, value] of Object.entries(input)) {
      sanitized[sanitizeInput(key)] = sanitizeInput(value);
    }
    return sanitized;
  }
  
  return input;
};
</code></pre>
<h2 id="conclusion"><a class="header" href="#conclusion">Conclusion</a></h2>
<p>The fundamentals of modern code generation extend far beyond simple text templating. They encompass declarative programming principles, context awareness, idempotent operations, and sophisticated error handling. Understanding these fundamentals is crucial for building reliable, maintainable, and powerful generation systems.</p>
<p>As we move forward in this book, we'll build upon these principles to explore advanced template design, configuration patterns, testing strategies, and deployment techniques. Each concept reinforces these fundamental principles, creating a cohesive approach to modern code generation.</p>
<p>The next chapter will dive deep into template design, showing how to apply these principles to create powerful, maintainable, and reusable templates that serve as the foundation for your generation system.</p>


                        <!-- Page Footer -->
                        <div class="page-footer" style="margin-top: 3rem; padding-top: 2rem; border-top: 1px solid #e1e5e9;">
                            <div style="display: flex; justify-content: space-between; align-items: center; flex-wrap: wrap; gap: 1rem;">
                                <div class="footer-links" style="display: flex; gap: 1rem; font-size: 0.9rem;">
                                    <a href="https://unjucks.dev" target="_blank">🌐 Website</a>
                                    <a href="https://github.com/ruvnet/unjucks" target="_blank">💻 GitHub</a>
                                    <a href="https://github.com/ruvnet/unjucks/issues" target="_blank">🐛 Issues</a>
                                    <a href="https://github.com/ruvnet/unjucks/discussions" target="_blank">💬 Discussions</a>
                                </div>
                                <div class="footer-info" style="font-size: 0.8rem; color: #888; text-align: right;">
                                    <p>Built with ❤️ using <a href="https://rust-lang.github.io/mdBook/" target="_blank">mdBook</a></p>
                                    <p>© 2024 Unjucks Project</p>
                                </div>
                            </div>
                        </div>
                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        <a href="" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                            <i class="fa fa-angle-left"></i>
                        </a>

                        <a href="" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                            <i class="fa fa-angle-right"></i>
                        </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <!-- Desktop navigation -->
            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                <a href="" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                    <i class="fa fa-angle-left"></i>
                </a>

                <a href="" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                    <i class="fa fa-angle-right"></i>
                </a>
            </nav>
        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS -->

        <!-- Custom body content -->
        <h1 id="chapter-2-fundamentals---core-principles-and-patterns-1"><a class="header" href="#chapter-2-fundamentals---core-principles-and-patterns-1">Chapter 2: Fundamentals - Core Principles and Patterns</a></h1>
<h2 id="the-foundation-of-modern-code-generation-1"><a class="header" href="#the-foundation-of-modern-code-generation-1">The Foundation of Modern Code Generation</a></h2>
<p>Understanding the fundamentals of modern code generation requires a shift in perspective. We're not just talking about text replacement or simple templating—we're discussing a sophisticated system of declarative programming that transforms intent into executable code. This chapter establishes the core principles that make Unjucks and similar modern generation tools powerful and reliable.</p>
<h2 id="principle-1-declarative-over-imperative-1"><a class="header" href="#principle-1-declarative-over-imperative-1">Principle 1: Declarative Over Imperative</a></h2>
<h3 id="the-declarative-mindset-1"><a class="header" href="#the-declarative-mindset-1">The Declarative Mindset</a></h3>
<p>Traditional development often follows an imperative approach: "Create a file here, add this function there, import that module." Modern code generation embraces declarative principles: "I want a user authentication system with these characteristics."</p>
<blockquote>
<p><strong>📋 Unjucks v2 Case Study: Declarative Transformation</strong></p>
<p>The Unjucks v1 → v2 refactor perfectly illustrates this principle shift:</p>
<p><strong>Legacy v1 (Imperative):</strong></p>
<pre><code class="language-javascript">// Manual, step-by-step file creation
const generator = {
  run: function(args) {
    // Step 1: Create directory
    fs.mkdirSync(`src/components/${args.name}`);
    
    // Step 2: Write component file
    const componentContent = template.render('component.hbs', args);
    fs.writeFileSync(`src/components/${args.name}/index.tsx`, componentContent);
    
    // Step 3: Write test file (manual)
    if (args.withTests) {
      const testContent = template.render('test.hbs', args);
      fs.writeFileSync(`src/components/${args.name}/${args.name}.test.tsx`, testContent);
    }
    
    // Step 4: Update exports (manual)
    updateBarrelExports(`src/components/${args.name}`);
  }
};
</code></pre>
<p><strong>Modern v2 (Declarative):</strong></p>
<pre><code class="language-yaml">---
to: "src/components/{{ pascalCase name }}/{{ pascalCase name }}.tsx"
inject: true
after: "// END EXPORTS"
skipIf: "export.*{{ pascalCase name }}"
when: "{{ withComponent }}"
context:
  framework: react
  typescript: true
  testing: vitest
---
</code></pre>
<p>The v2 approach declares <em>intent</em> rather than <em>steps</em>, resulting in:</p>
<ul>
<li><strong>85% less configuration code</strong></li>
<li><strong>100% consistency</strong> across generations</li>
<li><strong>Zero manual file management</strong></li>
<li><strong>Automatic conflict resolution</strong></li>
</ul>
</blockquote>
<pre><code class="language-yaml"># Imperative (traditional)
steps:
  - create: "src/auth/login.ts"
  - add_import: "import bcrypt from 'bcrypt'"
  - create_function: "validatePassword"
  - export_function: "validatePassword"

# Declarative (modern)
---
to: "src/auth/{{ feature }}.ts"
inject: true
before: "// END FEATURES"
when: "{{ hasAuthentication }}"
dependencies:
  - bcrypt
  - jsonwebtoken
---
</code></pre>
<h3 id="benefits-of-declarative-generation-1"><a class="header" href="#benefits-of-declarative-generation-1">Benefits of Declarative Generation</a></h3>
<p><strong>Maintainability</strong>: Declarative templates are easier to understand and modify. The intent is clear, and the implementation details are abstracted.</p>
<p><strong>Consistency</strong>: Declarative patterns ensure that similar intentions produce similar results, regardless of who implements them or when.</p>
<p><strong>Adaptability</strong>: Declarative templates can adapt to different contexts without changing the core template logic.</p>
<pre><code class="language-typescript">// Declarative template configuration
interface TemplateConfig {
  intent: 'component' | 'service' | 'page';
  features: string[];
  context: ProjectContext;
  constraints: GenerationConstraints;
}

// The generator adapts based on intent
const generateByIntent = (config: TemplateConfig) =&gt; {
  switch (config.intent) {
    case 'component':
      return adaptComponentTemplate(config);
    case 'service':
      return adaptServiceTemplate(config);
    case 'page':
      return adaptPageTemplate(config);
  }
};
</code></pre>
<h2 id="principle-2-context-aware-generation-1"><a class="header" href="#principle-2-context-aware-generation-1">Principle 2: Context-Aware Generation</a></h2>
<h3 id="understanding-project-context-1"><a class="header" href="#understanding-project-context-1">Understanding Project Context</a></h3>
<p>Modern code generation tools must understand the environment they're operating in. This includes:</p>
<ul>
<li><strong>Framework Detection</strong>: Recognizing React vs. Vue vs. Angular</li>
<li><strong>Architecture Patterns</strong>: Understanding Clean Architecture, MVC, or DDD</li>
<li><strong>Tooling Ecosystem</strong>: Detecting TypeScript, testing frameworks, and build tools</li>
<li><strong>Team Conventions</strong>: Adapting to established coding standards</li>
</ul>
<pre><code class="language-typescript">// Context analysis system
interface ProjectContext {
  framework: {
    name: string;
    version: string;
    plugins: string[];
  };
  architecture: {
    pattern: string;
    layers: string[];
    conventions: Record&lt;string, any&gt;;
  };
  tooling: {
    typescript: boolean;
    testing: string[];
    linting: string[];
    formatting: string[];
  };
  conventions: {
    naming: NamingConvention;
    structure: StructureConvention;
    imports: ImportConvention;
  };
}
</code></pre>
<h3 id="context-driven-template-selection-1"><a class="header" href="#context-driven-template-selection-1">Context-Driven Template Selection</a></h3>
<p>Templates should automatically adapt based on detected context:</p>
<pre><code class="language-yaml"># React-specific component template
---
to: "src/components/{{ pascalCase name }}/{{ pascalCase name }}.tsx"
when: "{{ context.framework.name === 'React' }}"
inject: false
---
import React from 'react';
import { {{ pascalCase name }}Props } from './types';

export const {{ pascalCase name }}: React.FC&lt;{{ pascalCase name }}Props&gt; = ({
  {{ properties }}
}) =&gt; {
  return (
    &lt;div className="{{ kebabCase name }}"&gt;
      {/* Component content */}
    &lt;/div&gt;
  );
};
</code></pre>
<pre><code class="language-yaml"># Vue-specific component template
---
to: "src/components/{{ pascalCase name }}/{{ pascalCase name }}.vue"
when: "{{ context.framework.name === 'Vue' }}"
inject: false
---
&lt;template&gt;
  &lt;div class="{{ kebabCase name }}"&gt;
    &lt;!-- Component content --&gt;
  &lt;/div&gt;
&lt;/template&gt;

&lt;script lang="ts"&gt;
import { defineComponent } from 'vue';

export default defineComponent({
  name: '{{ pascalCase name }}',
  props: {
    {{ properties }}
  }
});
&lt;/script&gt;
</code></pre>
<h2 id="principle-3-idempotent-operations-1"><a class="header" href="#principle-3-idempotent-operations-1">Principle 3: Idempotent Operations</a></h2>
<h3 id="the-importance-of-idempotency-1"><a class="header" href="#the-importance-of-idempotency-1">The Importance of Idempotency</a></h3>
<p>In mathematics and computer science, an idempotent operation is one that can be applied multiple times without changing the result beyond the initial application. This principle is crucial for code generation because:</p>
<ol>
<li><strong>Reliability</strong>: Running the same generator multiple times produces consistent results</li>
<li><strong>Safety</strong>: Accidental re-runs don't break your codebase</li>
<li><strong>Incremental Updates</strong>: Templates can be improved and re-run safely</li>
</ol>
<blockquote>
<p><strong>🔄 Unjucks v2 Case Study: Achieving True Idempotency</strong></p>
<p>Idempotency was one of the most challenging aspects of the Unjucks v2 refactor, but also one of the most impactful improvements.</p>
<p><strong>The v1 Problem: Destructive Re-runs</strong></p>
<pre><code class="language-javascript">// Legacy v1: Every run overwrote existing files
function generateComponent(name) {
  const path = `src/components/${name}.tsx`;
  
  // ❌ Always overwrites - loses manual changes
  fs.writeFileSync(path, renderTemplate(template, { name }));
  
  // ❌ Duplicates exports on each run
  appendToFile('src/index.ts', `export { ${name} } from './components/${name}';`);
}

// Result: Manual changes lost, duplicate exports accumulated
</code></pre>
<p><strong>The v2 Solution: Smart Idempotency</strong></p>
<pre><code class="language-typescript">// Modern v2: Intelligent content management
export async function generateIdempotent(template: Template, variables: Variables) {
  const targetPath = resolvePath(template.to, variables);
  const newContent = await render(template.content, variables);
  
  // Content hashing prevents unnecessary writes
  const newHash = createContentHash(newContent);
  const existingHash = await getExistingContentHash(targetPath);
  
  if (newHash === existingHash) {
    return { status: 'unchanged', path: targetPath };
  }
  
  // Smart injection with skipIf guards
  if (template.inject &amp;&amp; template.skipIf) {
    const existing = await readFile(targetPath);
    if (new RegExp(template.skipIf).test(existing)) {
      return { status: 'skipped', reason: 'skipIf condition matched' };
    }
    
    // Idempotent injection at specific location
    return await injectContent(targetPath, newContent, template);
  }
  
  // Safe file writing with backup
  return await safeWrite(targetPath, newContent);
}
</code></pre>
<p><strong>Impact Metrics:</strong></p>
<ul>
<li><strong>100% safe re-runs</strong>: Never lose manual changes</li>
<li><strong>Zero duplicate content</strong>: Smart skip conditions prevent duplication</li>
<li><strong>3.2s → 0.1s</strong>: Skip unchanged files for 32x faster incremental updates</li>
<li><strong>95% developer confidence</strong>: Teams comfortable with frequent re-generation</li>
</ul>
</blockquote>
<pre><code class="language-yaml"># Idempotent injection example
---
to: "src/index.ts"
inject: true
after: "// BEGIN EXPORTS"
before: "// END EXPORTS"
skipIf: "export.*{{ pascalCase name }}"
---
export { {{ pascalCase name }} } from './components/{{ pascalCase name }}';
</code></pre>
<h3 id="implementing-idempotency-1"><a class="header" href="#implementing-idempotency-1">Implementing Idempotency</a></h3>
<p><strong>Skip Conditions</strong>: Use <code>skipIf</code> to prevent duplicate entries:</p>
<pre><code class="language-yaml">---
skipIf: "interface {{ pascalCase name }}Props"
---
interface {{ pascalCase name }}Props {
  {{ properties }}
}
</code></pre>
<p><strong>Content Hashing</strong>: Generate content hashes to detect changes:</p>
<pre><code class="language-typescript">interface GeneratedContent {
  content: string;
  hash: string;
  timestamp: Date;
  generator: string;
}

const generateIdempotent = (template: string, data: any): GeneratedContent =&gt; {
  const content = render(template, data);
  const hash = createHash('sha256').update(content).digest('hex');
  
  return {
    content,
    hash,
    timestamp: new Date(),
    generator: template
  };
};
</code></pre>
<p><strong>Merge Strategies</strong>: Define how to handle conflicts:</p>
<pre><code class="language-typescript">enum MergeStrategy {
  SKIP = 'skip',           // Don't modify existing content
  REPLACE = 'replace',     // Replace entirely
  MERGE = 'merge',         // Intelligently merge
  APPEND = 'append',       // Add to existing content
  PREPEND = 'prepend'      // Add before existing content
}
</code></pre>
<h2 id="principle-4-template-composition-and-inheritance-1"><a class="header" href="#principle-4-template-composition-and-inheritance-1">Principle 4: Template Composition and Inheritance</a></h2>
<h3 id="modular-template-design-1"><a class="header" href="#modular-template-design-1">Modular Template Design</a></h3>
<p>Modern templates should be composed of smaller, reusable parts rather than monolithic blocks:</p>
<pre><code class="language-yaml"># Base component template
---
name: "base-component"
abstract: true
---
import React from 'react';

export const {{ pascalCase name }}: React.FC&lt;{{ pascalCase name }}Props&gt; = () =&gt; {
  {% block content %}
  return &lt;div&gt;{{ name }}&lt;/div&gt;;
  {% endblock %}
};
</code></pre>
<pre><code class="language-yaml"># Specialized form component
---
extends: "base-component"
to: "src/components/forms/{{ pascalCase name }}.tsx"
---
{% block content %}
const [formData, setFormData] = useState({});
const [errors, setErrors] = useState({});

return (
  &lt;form onSubmit={handleSubmit}&gt;
    {{ formFields }}
  &lt;/form&gt;
);
{% endblock %}
</code></pre>
<h3 id="template-inheritance-patterns-1"><a class="header" href="#template-inheritance-patterns-1">Template Inheritance Patterns</a></h3>
<p><strong>Single Inheritance</strong>: Templates extend a single base template</p>
<pre><code class="language-yaml">extends: "base-component"
</code></pre>
<p><strong>Mixin Composition</strong>: Templates include multiple mixins</p>
<pre><code class="language-yaml">mixins:
  - "with-loading-state"
  - "with-error-handling"
  - "with-form-validation"
</code></pre>
<p><strong>Trait-Based</strong>: Templates compose specific traits</p>
<pre><code class="language-typescript">interface TemplateTraits {
  loadingState?: boolean;
  errorHandling?: boolean;
  formValidation?: boolean;
  authentication?: boolean;
}

const applyTraits = (base: Template, traits: TemplateTraits): Template =&gt; {
  return Object.entries(traits).reduce((template, [trait, enabled]) =&gt; {
    return enabled ? mixinTrait(template, trait) : template;
  }, base);
};
</code></pre>
<h2 id="principle-5-type-safety-and-validation-1"><a class="header" href="#principle-5-type-safety-and-validation-1">Principle 5: Type Safety and Validation</a></h2>
<h3 id="template-variable-validation-1"><a class="header" href="#template-variable-validation-1">Template Variable Validation</a></h3>
<p>Modern code generation tools should validate template variables at generation time:</p>
<pre><code class="language-typescript">// Variable schema definition
interface ComponentSchema {
  name: string;                    // Required: Component name
  props?: PropertyDefinition[];    // Optional: Component props
  features?: FeatureFlag[];       // Optional: Feature toggles
  styling?: StylingOptions;       // Optional: Styling configuration
}

// Runtime validation
const validateTemplate = (variables: any, schema: Schema): ValidationResult =&gt; {
  const errors: ValidationError[] = [];
  
  // Required field validation
  if (!variables.name) {
    errors.push({ field: 'name', message: 'Component name is required' });
  }
  
  // Type validation
  if (variables.props &amp;&amp; !Array.isArray(variables.props)) {
    errors.push({ field: 'props', message: 'Props must be an array' });
  }
  
  return { valid: errors.length === 0, errors };
};
</code></pre>
<h3 id="generated-code-validation-1"><a class="header" href="#generated-code-validation-1">Generated Code Validation</a></h3>
<p>Validate that generated code meets quality standards:</p>
<pre><code class="language-typescript">interface CodeQualityCheck {
  syntax: boolean;        // Valid syntax
  types: boolean;         // Type correctness
  imports: boolean;       // Valid imports
  patterns: boolean;      // Follows patterns
  performance: boolean;   // Performance considerations
}

const validateGeneratedCode = async (
  code: string,
  language: string
): Promise&lt;CodeQualityCheck&gt; =&gt; {
  const checks: CodeQualityCheck = {
    syntax: await validateSyntax(code, language),
    types: await validateTypes(code, language),
    imports: await validateImports(code),
    patterns: await validatePatterns(code),
    performance: await analyzePerformance(code)
  };
  
  return checks;
};
</code></pre>
<h2 id="principle-6-progressive-enhancement-1"><a class="header" href="#principle-6-progressive-enhancement-1">Principle 6: Progressive Enhancement</a></h2>
<h3 id="layered-generation-strategy-1"><a class="header" href="#layered-generation-strategy-1">Layered Generation Strategy</a></h3>
<p>Generate code in layers, from basic to advanced features:</p>
<pre><code class="language-typescript">interface GenerationLayer {
  name: string;
  description: string;
  dependencies: string[];
  template: string;
  optional: boolean;
}

const generationLayers: GenerationLayer[] = [
  {
    name: 'base',
    description: 'Basic component structure',
    dependencies: [],
    template: 'component-base.njk',
    optional: false
  },
  {
    name: 'props',
    description: 'Component props interface',
    dependencies: ['base'],
    template: 'component-props.njk',
    optional: false
  },
  {
    name: 'state',
    description: 'State management',
    dependencies: ['base', 'props'],
    template: 'component-state.njk',
    optional: true
  },
  {
    name: 'testing',
    description: 'Test suite',
    dependencies: ['base', 'props'],
    template: 'component-tests.njk',
    optional: true
  }
];
</code></pre>
<h3 id="feature-flags-and-conditional-generation-1"><a class="header" href="#feature-flags-and-conditional-generation-1">Feature Flags and Conditional Generation</a></h3>
<p>Use feature flags to control what gets generated:</p>
<pre><code class="language-yaml"># Component with optional features
---
to: "src/components/{{ pascalCase name }}/{{ pascalCase name }}.tsx"
---
import React{% if withState %}, { useState }{% endif %} from 'react';
{% if withRouter %}
import { useRouter } from 'next/router';
{% endif %}
{% if withQuery %}
import { useQuery } from '@tanstack/react-query';
{% endif %}

interface {{ pascalCase name }}Props {
  {% for prop in props %}
  {{ prop.name }}: {{ prop.type }};
  {% endfor %}
}

export const {{ pascalCase name }}: React.FC&lt;{{ pascalCase name }}Props&gt; = ({
  {% for prop in props %}{{ prop.name }}{% if not loop.last %}, {% endif %}{% endfor %}
}) =&gt; {
  {% if withState %}
  const [state, setState] = useState();
  {% endif %}
  
  {% if withRouter %}
  const router = useRouter();
  {% endif %}
  
  {% if withQuery %}
  const { data, isLoading } = useQuery(['{{ kebabCase name }}'], fetchData);
  {% endif %}

  return (
    &lt;div className="{{ kebabCase name }}"&gt;
      {/* Component implementation */}
    &lt;/div&gt;
  );
};
</code></pre>
<h2 id="common-patterns-and-practices-1"><a class="header" href="#common-patterns-and-practices-1">Common Patterns and Practices</a></h2>
<h3 id="1-the-registry-pattern-1"><a class="header" href="#1-the-registry-pattern-1">1. The Registry Pattern</a></h3>
<p>Maintain a registry of available generators and their capabilities:</p>
<pre><code class="language-typescript">interface GeneratorRegistry {
  generators: Map&lt;string, GeneratorMetadata&gt;;
  
  register(name: string, metadata: GeneratorMetadata): void;
  find(criteria: GeneratorCriteria): GeneratorMetadata[];
  get(name: string): GeneratorMetadata | undefined;
}

interface GeneratorMetadata {
  name: string;
  description: string;
  version: string;
  author: string;
  tags: string[];
  schema: Schema;
  templates: TemplateReference[];
  examples: Example[];
}
</code></pre>
<h3 id="2-the-plugin-pattern-1"><a class="header" href="#2-the-plugin-pattern-1">2. The Plugin Pattern</a></h3>
<p>Allow third-party extensions through plugins:</p>
<pre><code class="language-typescript">interface GeneratorPlugin {
  name: string;
  version: string;
  
  beforeGeneration?(context: GenerationContext): void;
  afterGeneration?(context: GenerationContext, result: GenerationResult): void;
  transformTemplate?(template: string, variables: any): string;
  validateVariables?(variables: any, schema: Schema): ValidationResult;
}

class PluginManager {
  private plugins: GeneratorPlugin[] = [];
  
  register(plugin: GeneratorPlugin): void {
    this.plugins.push(plugin);
  }
  
  async executeHook(
    hookName: keyof GeneratorPlugin,
    ...args: any[]
  ): Promise&lt;void&gt; {
    for (const plugin of this.plugins) {
      const hook = plugin[hookName];
      if (typeof hook === 'function') {
        await hook.apply(plugin, args);
      }
    }
  }
}
</code></pre>
<h3 id="3-the-strategy-pattern-1"><a class="header" href="#3-the-strategy-pattern-1">3. The Strategy Pattern</a></h3>
<p>Different generation strategies for different use cases:</p>
<pre><code class="language-typescript">interface GenerationStrategy {
  name: string;
  description: string;
  
  generate(
    template: Template,
    variables: any,
    context: GenerationContext
  ): Promise&lt;GenerationResult&gt;;
}

class FileGenerationStrategy implements GenerationStrategy {
  name = 'file';
  description = 'Generate new files';
  
  async generate(template, variables, context) {
    // File generation logic
  }
}

class InjectionStrategy implements GenerationStrategy {
  name = 'injection';
  description = 'Inject into existing files';
  
  async generate(template, variables, context) {
    // Injection logic
  }
}
</code></pre>
<h2 id="error-handling-and-recovery-1"><a class="header" href="#error-handling-and-recovery-1">Error Handling and Recovery</a></h2>
<h3 id="graceful-failure-patterns-1"><a class="header" href="#graceful-failure-patterns-1">Graceful Failure Patterns</a></h3>
<pre><code class="language-typescript">enum GenerationErrorType {
  TEMPLATE_NOT_FOUND = 'TEMPLATE_NOT_FOUND',
  VALIDATION_FAILED = 'VALIDATION_FAILED',
  FILE_CONFLICT = 'FILE_CONFLICT',
  PERMISSION_DENIED = 'PERMISSION_DENIED',
  SYNTAX_ERROR = 'SYNTAX_ERROR'
}

class GenerationError extends Error {
  constructor(
    public type: GenerationErrorType,
    public message: string,
    public context?: any,
    public recoverable: boolean = true
  ) {
    super(message);
    this.name = 'GenerationError';
  }
}

const handleGenerationError = (error: GenerationError): RecoveryAction =&gt; {
  switch (error.type) {
    case GenerationErrorType.FILE_CONFLICT:
      return {
        type: 'PROMPT_USER',
        options: ['overwrite', 'merge', 'skip', 'rename']
      };
      
    case GenerationErrorType.VALIDATION_FAILED:
      return {
        type: 'REQUEST_INPUT',
        fields: error.context.missingFields
      };
      
    case GenerationErrorType.TEMPLATE_NOT_FOUND:
      return {
        type: 'SUGGEST_ALTERNATIVES',
        suggestions: findSimilarTemplates(error.context.templateName)
      };
      
    default:
      return { type: 'FAIL', retry: error.recoverable };
  }
};
</code></pre>
<h3 id="rollback-mechanisms-1"><a class="header" href="#rollback-mechanisms-1">Rollback Mechanisms</a></h3>
<p>Implement transactional generation with rollback capabilities:</p>
<pre><code class="language-typescript">class GenerationTransaction {
  private operations: GenerationOperation[] = [];
  private completed: GenerationOperation[] = [];
  
  addOperation(operation: GenerationOperation): void {
    this.operations.push(operation);
  }
  
  async execute(): Promise&lt;GenerationResult&gt; {
    try {
      for (const operation of this.operations) {
        await operation.execute();
        this.completed.push(operation);
      }
      return { success: true, operations: this.completed };
    } catch (error) {
      await this.rollback();
      throw error;
    }
  }
  
  private async rollback(): Promise&lt;void&gt; {
    for (const operation of this.completed.reverse()) {
      await operation.rollback();
    }
  }
}
</code></pre>
<h2 id="performance-considerations-1"><a class="header" href="#performance-considerations-1">Performance Considerations</a></h2>
<h3 id="template-compilation-and-caching-1"><a class="header" href="#template-compilation-and-caching-1">Template Compilation and Caching</a></h3>
<pre><code class="language-typescript">class TemplateCache {
  private cache = new Map&lt;string, CompiledTemplate&gt;();
  
  compile(template: string, options: CompileOptions): CompiledTemplate {
    const cacheKey = this.getCacheKey(template, options);
    
    if (this.cache.has(cacheKey)) {
      return this.cache.get(cacheKey)!;
    }
    
    const compiled = compileTemplate(template, options);
    this.cache.set(cacheKey, compiled);
    
    return compiled;
  }
  
  private getCacheKey(template: string, options: CompileOptions): string {
    return `${hashString(template)}-${hashObject(options)}`;
  }
}
</code></pre>
<h3 id="parallel-generation-1"><a class="header" href="#parallel-generation-1">Parallel Generation</a></h3>
<pre><code class="language-typescript">const generateParallel = async (
  generators: GeneratorTask[]
): Promise&lt;GenerationResult[]&gt; =&gt; {
  const chunks = chunkArray(generators, CPU_CORES);
  
  const results = await Promise.all(
    chunks.map(chunk =&gt; 
      Promise.all(chunk.map(generator =&gt; generator.execute()))
    )
  );
  
  return results.flat();
};
</code></pre>
<h2 id="security-considerations-1"><a class="header" href="#security-considerations-1">Security Considerations</a></h2>
<h3 id="template-sandboxing-1"><a class="header" href="#template-sandboxing-1">Template Sandboxing</a></h3>
<pre><code class="language-typescript">interface SandboxOptions {
  allowedModules: string[];
  timeout: number;
  memoryLimit: number;
  fileSystemAccess: 'none' | 'readonly' | 'restricted';
}

const executeSandboxed = (
  template: string,
  variables: any,
  options: SandboxOptions
): Promise&lt;string&gt; =&gt; {
  return new Promise((resolve, reject) =&gt; {
    const sandbox = createSandbox(options);
    
    try {
      const result = sandbox.execute(template, variables);
      resolve(result);
    } catch (error) {
      reject(new SecurityError('Template execution failed', error));
    } finally {
      sandbox.cleanup();
    }
  });
};
</code></pre>
<h3 id="input-validation-and-sanitization-1"><a class="header" href="#input-validation-and-sanitization-1">Input Validation and Sanitization</a></h3>
<pre><code class="language-typescript">const sanitizeInput = (input: any): any =&gt; {
  if (typeof input === 'string') {
    // Remove potentially dangerous characters
    return input.replace(/[&lt;&gt;\"'&amp;]/g, '');
  }
  
  if (Array.isArray(input)) {
    return input.map(sanitizeInput);
  }
  
  if (typeof input === 'object' &amp;&amp; input !== null) {
    const sanitized: any = {};
    for (const [key, value] of Object.entries(input)) {
      sanitized[sanitizeInput(key)] = sanitizeInput(value);
    }
    return sanitized;
  }
  
  return input;
};
</code></pre>
<h2 id="conclusion-1"><a class="header" href="#conclusion-1">Conclusion</a></h2>
<p>The fundamentals of modern code generation extend far beyond simple text templating. They encompass declarative programming principles, context awareness, idempotent operations, and sophisticated error handling. Understanding these fundamentals is crucial for building reliable, maintainable, and powerful generation systems.</p>
<p>As we move forward in this book, we'll build upon these principles to explore advanced template design, configuration patterns, testing strategies, and deployment techniques. Each concept reinforces these fundamental principles, creating a cohesive approach to modern code generation.</p>
<p>The next chapter will dive deep into template design, showing how to apply these principles to create powerful, maintainable, and reusable templates that serve as the foundation for your generation system.</p>


        <!-- Performance monitoring -->
        <script>
            // Simple performance monitoring
            window.addEventListener('load', function() {
                if ('performance' in window) {
                    setTimeout(function() {
                        const loadTime = performance.timing.loadEventEnd - performance.timing.navigationStart;
                        console.log('📊 Page loaded in ' + loadTime + 'ms');
                    }, 0);
                }
            });
        </script>

        <!-- Service Worker for offline support -->
        <script>
            if ('serviceWorker' in navigator) {
                navigator.serviceWorker.register('sw.js')
                    .then(function(registration) {
                        console.log('📱 SW registered with scope:', registration.scope);
                    })
                    .catch(function(error) {
                        console.log('❌ SW registration failed:', error);
                    });
            }
        </script>
    </body>
</html>
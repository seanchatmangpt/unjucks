# Configuration Management Analysis

## Overview

This document analyzes the configuration management patterns found in the Unjucks codebase. The project demonstrates a mature, multi-layered approach to configuration handling with support for various formats, environments, and validation patterns.

## Configuration Directory Structure

The project follows a well-organized configuration structure:

```
/config/                          # Main configuration directory
├── latex.config.js              # LaTeX-specific configuration
├── semantic.config.js           # Semantic analysis configuration  
├── semantic-production.js       # Production semantic config
├── production-baselines.json    # Production baseline metrics
├── monitoring-dashboard.json    # Monitoring configuration
├── verdaccio.yaml              # Package registry configuration
├── ci/                         # CI-specific configurations
└── performance/                # Performance-related configs
    ├── cache.config.js         # Cache configuration
    ├── memory.config.js        # Memory management config
    ├── monitoring.config.js    # Performance monitoring
    ├── parallel.config.js      # Parallel processing config
    └── streaming.config.js     # Streaming configuration

/src/config/                     # Runtime configuration
└── index.js                    # Main server configuration

/tests/fixtures/configs/         # Test configuration fixtures
└── valid/
    ├── unjucks.config.json     # JSON format example
    └── unjucks.config.js       # JavaScript format example
```

## Configuration Loading Patterns

### 1. Direct Import Pattern

Used for static configurations that don't change at runtime:

```javascript
// config/latex.config.js
export default {
  latex: {
    engine: 'pdflatex',
    outputDir: './dist/latex',
    tempDir: './temp/latex',
    enableBibtex: true,
    // ... more config
  }
};
```

### 2. Environment-Driven Configuration

Primary pattern found in `/src/config/index.js`:

```javascript
import 'dotenv/config';

const config = {
  port: parseInt(process.env.PORT) || 3001,
  environment: process.env.NODE_ENV || 'development',
  database: {
    host: process.env.DB_HOST || 'localhost',
    port: parseInt(process.env.DB_PORT) || 5432,
    // ... with fallback defaults
  }
};
```

### 3. Performance Auto-Generated Configs

Found in `/config/performance/` - configs auto-generated by performance optimizers:

```javascript
// cache.config.js - Auto-generated by LaTeX Performance Optimizer
module.exports = {
  "enableCaching": true,
  "cacheDir": "/Users/sac/unjucks/.latex-cache",
  "maxSize": 524288000,
  "strategy": "intelligent"
};
```

## Environment Variable Handling

### Patterns Identified

1. **Direct Environment Variables with Defaults**:
   ```javascript
   port: parseInt(process.env.PORT) || 3001
   environment: process.env.NODE_ENV || 'development'
   ```

2. **Type Coercion for Environment Variables**:
   ```javascript
   ssl: process.env.DB_SSL === 'true'  // String to boolean
   pool: {
     min: parseInt(process.env.DB_POOL_MIN) || 2  // String to number
   }
   ```

3. **Array Parsing from Environment**:
   ```javascript
   cors: {
     allowedOrigins: process.env.CORS_ORIGINS ? 
       process.env.CORS_ORIGINS.split(',') : 
       ['http://localhost:3000', 'http://localhost:3001']
   }
   ```

4. **Environment Variable Prefixing**:
   ```javascript
   // Found in test files - consistent prefixing pattern
   UNJUCKS_TEMPLATES_DIR: process.env.UNJUCKS_TEMPLATES_DIR
   UNJUCKS_OUTPUT_DIR: process.env.UNJUCKS_OUTPUT_DIR
   UNJUCKS_DEBUG: process.env.UNJUCKS_DEBUG
   ```

## Multi-Environment Support

### Environment-Specific Configuration

1. **Production Validation**:
   ```javascript
   if (config.environment === 'production') {
     const requiredEnvVars = ['JWT_SECRET', 'DB_PASSWORD'];
     
     for (const envVar of requiredEnvVars) {
       if (!process.env[envVar]) {
         throw new Error(`Required environment variable ${envVar} is not set`);
       }
     }
   }
   ```

2. **Environment-Conditional Features**:
   ```javascript
   security: {
     helmet: {
       contentSecurityPolicy: process.env.NODE_ENV === 'production',
       hsts: process.env.NODE_ENV === 'production'
     }
   }
   ```

3. **Test Environment Handling**:
   ```javascript
   // Found in vitest configs
   silent: process.env.NODE_ENV === 'test'
   env: { ...process.env, NODE_ENV: 'test' }
   ```

## Configuration Validation

### Validation Patterns Found

1. **Runtime Validation with Error Throwing**:
   ```javascript
   if (config.environment === 'production') {
     if (!process.env[envVar]) {
       throw new Error(`Required environment variable ${envVar} is not set`);
     }
   }
   ```

2. **Configuration Property Validation** (from test files):
   ```javascript
   const validator = {
     validate(config) {
       const errors = [];
       
       if (!config.templatesDir) {
         errors.push('templatesDir is required');
       }
       
       if (config.extensions && !Array.isArray(config.extensions)) {
         errors.push('extensions must be an array');
       }
       
       return {
         valid: errors.length === 0,
         errors,
         warnings: []
       };
     }
   };
   ```

3. **Type Validation**:
   ```javascript
   if (typeof config.debug !== 'boolean') {
     errors.push('debug must be a boolean');
   }
   ```

## Configuration File Formats

### Supported Formats

1. **JavaScript (ES6 Modules)** - Primary format:
   ```javascript
   export default {
     templatesDir: '_templates',
     outputDir: 'src',
     defaultVariables: {
       author: 'Test Author',
       license: 'MIT'
     }
   };
   ```

2. **JSON** - For data-driven configs:
   ```json
   {
     "templatesDir": "_templates",
     "outputDir": "src",
     "validation": {
       "validateVariables": true,
       "strictMode": false
     }
   }
   ```

3. **CommonJS** - For Node.js compatibility:
   ```javascript
   module.exports = {
     templatesDir: './templates',
     generators: {
       component: {
         templatesDir: './templates/component'
       }
     }
   };
   ```

4. **YAML** - For external tools:
   ```yaml
   # config/verdaccio.yaml
   storage: ./storage
   auth:
     htpasswd:
       file: ./htpasswd
   ```

## Default Configuration Management

### Default Value Strategies

1. **Inline Defaults with Environment Overrides**:
   ```javascript
   const config = {
     port: parseInt(process.env.PORT) || 3001,
     version: process.env.VERSION || '1.0.0'
   };
   ```

2. **Object Spread with Default Objects**:
   ```javascript
   const defaultVariables = {
     author: 'Test Author',
     license: 'MIT',
     year: new Date().getFullYear()
   };
   ```

3. **Nested Default Configurations**:
   ```javascript
   database: {
     pool: {
       min: parseInt(process.env.DB_POOL_MIN) || 2,
       max: parseInt(process.env.DB_POOL_MAX) || 10
     }
   }
   ```

4. **Feature Flags with Defaults**:
   ```javascript
   features: {
     swagger: process.env.ENABLE_SWAGGER !== 'false',  // Default true
     metrics: process.env.ENABLE_METRICS !== 'false'   // Default true
   }
   ```

## Working Configuration Patterns

### 1. Hierarchical Configuration Loading

```javascript
// Base configuration
const baseConfig = {
  templatesDir: './templates',
  debug: false
};

// Environment-specific overrides
const envConfig = {
  debug: true,
  outputDir: './dev-output'
};

// Final merged configuration
const finalConfig = { ...baseConfig, ...envConfig };
```

### 2. Dynamic Configuration with Functions

```javascript
// config/latex.config.js
export default {
  latex: {
    maxRetries: 3,
    timeout: 60000,
    watch: {
      patterns: ['**/*.tex', '**/*.bib'],
      ignored: ['**/node_modules/**', '**/dist/**']
    }
  }
};
```

### 3. Performance-Optimized Configuration

Auto-generated performance configurations with intelligent defaults:

```javascript
// Auto-generated cache configuration
module.exports = {
  "enableCaching": true,
  "cacheDir": "/Users/sac/unjucks/.latex-cache",
  "maxSize": 524288000,        // ~500MB
  "maxAge": 604800000,         // 7 days
  "strategy": "intelligent",
  "enableCompression": true,
  "compressionLevel": 6
};
```

### 4. Validation-First Configuration

```javascript
// Validation before use
const validator = {
  validate(config) {
    const errors = [];
    
    // Required field validation
    if (!config.templatesDir) {
      errors.push('templatesDir is required');
    }
    
    // Type validation
    if (config.extensions && !Array.isArray(config.extensions)) {
      errors.push('extensions must be an array');
    }
    
    return { valid: errors.length === 0, errors };
  }
};

const result = validator.validate(config);
if (!result.valid) {
  throw new Error(`Configuration validation failed: ${result.errors.join(', ')}`);
}
```

## Key Insights

1. **No Configuration Library Dependency**: The project doesn't use libraries like `c12` or `cosmiconfig`, instead implementing custom configuration loading patterns.

2. **Environment-First Approach**: Heavy reliance on environment variables with sensible defaults for all configurable values.

3. **Production Safety**: Strong emphasis on required environment variable validation in production environments.

4. **Performance-Aware**: Auto-generated performance configurations that adapt to system capabilities.

5. **Multi-Format Support**: Handles JavaScript (ES6/CommonJS), JSON, and YAML configurations appropriately for different use cases.

6. **Test-Driven Configuration**: Comprehensive test coverage for configuration loading, validation, and environment variable handling.

7. **Hierarchical Merging**: Implements configuration layering with base configs, environment-specific overrides, and environment variable overrides.

## Recommendations

1. **Consider Configuration Library**: While the current approach works, libraries like `c12` could reduce boilerplate and provide additional features.

2. **Centralize Validation**: Create a unified configuration validation system rather than ad-hoc validation in different parts of the codebase.

3. **Configuration Schema**: Consider adding JSON Schema or similar for configuration validation.

4. **Documentation**: The configuration patterns are well-implemented but could benefit from centralized documentation.

5. **Hot Reloading**: Consider adding configuration hot-reloading for development environments.
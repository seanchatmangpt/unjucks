# Template Best Practices - v1 Patterns

Essential patterns and practices for creating maintainable Unjucks templates.

## Template Organization

### Directory Structure
```
_templates/
├── component/           # UI components
│   ├── react/          # Framework-specific
│   ├── vue/
│   └── config.yml      # Shared configuration
├── service/            # Business logic
│   ├── api/           # API services
│   ├── database/      # Data access
│   └── config.yml
├── config/            # Configuration files
├── common/            # Shared templates
│   ├── header.ts      # File headers
│   ├── types.ts       # Common types
│   └── utils.ts       # Utility functions
└── scripts/           # Automation scripts
```

### Naming Conventions

**Generators**: Use lowercase with hyphens
```
api-client/    ✅ Good
apiClient/     ❌ Avoid
API_Client/    ❌ Avoid
```

**Templates**: Descriptive, technology-specific
```
express-controller/    ✅ Good
react-component/      ✅ Good
controller/           ❌ Too generic
comp/                ❌ Too abbreviated
```

**Variables**: camelCase, descriptive
```
componentName         ✅ Good
serviceName          ✅ Good
name                 ❌ Too generic
comp                 ❌ Abbreviated
```

## Variable Design

### Boolean Variables
Use standard prefixes for clarity:
```yaml
# Template variables
withProps: true          # Include props interface
hasAuth: true           # Include authentication
isPublic: false         # Public/private visibility
shouldValidate: true    # Include validation
includeTests: false     # Generate test files
enableLogging: true     # Add logging code
```

### String Variables
Be specific and descriptive:
```yaml
# Good - Clear purpose
componentName: "UserButton"
serviceName: "UserAuthService"
modulePath: "src/components"
databaseConnection: "postgresql://..."

# Avoid - Too generic
name: "Button"          # Name of what?
path: "src"            # Path to what?
config: "database"     # What kind of config?
```

### Array Variables
Use plural nouns, be descriptive:
```yaml
# Good - Clear content type
methods: ["create", "update", "delete"]
dependencies: ["react", "typescript", "@types/react"]
fields: [
  { name: "email", type: "string", required: true },
  { name: "age", type: "number", required: false }
]

# Avoid - Unclear content
items: ["create", "update"]     # Items of what type?
list: ["react", "typescript"]  # List of what?
```

## Template Patterns

### Conditional Code Generation
```typescript
// ✅ Good - Clean conditional structure
{% if withAuth %}
import { AuthProvider } from './auth';

export const App = () => (
  <AuthProvider>
    <Router>
      <Routes />
    </Router>
  </AuthProvider>
);
{% else %}
export const App = () => (
  <Router>
    <Routes />
  </Router>
);
{% endif %}

// ❌ Avoid - Complex inline conditionals
export const App = () => (
  {% if withAuth %}<AuthProvider>{% endif %}
    <Router>
      <Routes />
    </Router>
  {% if withAuth %}</AuthProvider>{% endif %}
);
```

### Loop Processing
```typescript
// ✅ Good - Clean loop with proper spacing
export interface {{ entityName | pascalCase }} {
  id: string;
  {% for field in fields %}
  {{ field.name }}{% if not field.required %}?{% endif %}: {{ field.type }};
  {% endfor %}
  createdAt: Date;
}

// ✅ Good - Handle empty arrays
{% if methods and methods.length > 0 %}
export class {{ serviceName | pascalCase }} {
  {% for method in methods %}
  async {{ method.name }}(): Promise<{{ method.returnType }}> {
    // Implementation
  }
  {% endfor %}
}
{% else %}
export class {{ serviceName | pascalCase }} {
  // No methods defined
}
{% endif %}
```

### File Headers
```typescript
// ✅ Good - Consistent, informative headers
/**
 * {{ componentName | pascalCase }}
 * 
 * {% if description %}{{ description }}{% else %}Generated component{% endif %}
 * 
 * @generated by unjucks on {{ new Date().toISOString().split('T')[0] }}
 * @generator {{ generator }}
 * @template {{ template }}
 */
```

## Code Quality

### Clean Output
```typescript
// ✅ Good - Proper spacing and indentation
{% if withProps %}
interface {{ componentName | pascalCase }}Props {
  children?: React.ReactNode;
  className?: string;
}

{% endif %}
export const {{ componentName | pascalCase }}{% if withProps %}: React.FC<{{ componentName | pascalCase }}Props>{% endif %} = ({% if withProps %}props{% endif %}) => {
  return (
    <div{% if withProps %} className={props.className}{% endif %}>
      {% if withProps %}
      {props.children}
      {% else %}
      <h1>{{ componentName | titleCase }}</h1>
      {% endif %}
    </div>
  );
};

// ❌ Avoid - Inconsistent spacing
{% if withProps %}interface {{ componentName | pascalCase }}Props {
  children?: React.ReactNode;
}{% endif %}
export const {{ componentName | pascalCase }}{% if withProps %}: React.FC<{{ componentName | pascalCase }}Props>{% endif %}=({% if withProps %}props{% endif %})=>{
return <div>Content</div>;};
```

### Error Prevention
```typescript
// ✅ Good - Validate required data
{% if not componentName %}
{% error "componentName is required" %}
{% endif %}

// ✅ Good - Safe array access
{% if fields and fields.length > 0 %}
{% for field in fields %}
{{ field.name }}: {{ field.type | default('string') }};
{% endfor %}
{% endif %}

// ✅ Good - Default values
export const {{ componentName | pascalCase | default('DefaultComponent') }} = () => {
  // Component implementation
};
```

## Configuration Best Practices

### Sensible Defaults
```yaml
# config.yml
name: "component"
description: "Generate React components"
templates:
  - name: "react"
    description: "React functional component"
    prompts:
      - name: "componentName"
        message: "Component name:"
        type: "input"
        default: "MyComponent"              # ✅ Reasonable default
      - name: "withProps"
        message: "Include props interface?"
        type: "confirm" 
        default: true                       # ✅ Most common case
      - name: "withTests"
        message: "Generate test file?"
        type: "confirm"
        default: false                      # ✅ Optional feature
```

### Clear Prompts
```yaml
prompts:
  # ✅ Good - Clear, specific prompts
  - name: "entityName"
    message: "Entity name (singular, e.g., User, Product):"
    type: "input"
    default: "User"
    
  - name: "withValidation"
    message: "Include input validation?"
    type: "confirm"
    default: true
    
  - name: "databaseType" 
    message: "Choose database type:"
    type: "list"
    choices: ["postgresql", "mysql", "sqlite"]
    default: "postgresql"

  # ❌ Avoid - Vague prompts
  - name: "name"
    message: "Name:"           # Name of what?
    type: "input"
    
  - name: "include"
    message: "Include it?"     # Include what?
    type: "confirm"
```

## Performance Optimization

### Efficient Variable Usage
```typescript
// ✅ Good - Cache processed values
{% set processedName = componentName | pascalCase %}
{% set fileName = processedName + '.tsx' %}
{% set testFileName = processedName + '.test.tsx' %}

export const {{ processedName }} = () => {
  // Component implementation
};

// File: {{ fileName }}
// Test file: {{ testFileName }}

// ❌ Avoid - Repeated processing
export const {{ componentName | pascalCase }} = () => {
  // Implementation
};

// File: {{ componentName | pascalCase }}.tsx
// Test: {{ componentName | pascalCase }}.test.tsx
```

### Conditional Includes
```typescript
// ✅ Good - Only include when needed
{% if withStyles %}
{% include "styles-template.css" %}
{% endif %}

{% if withTypes %}
{% include "types-template.ts" %}
{% endif %}

// ❌ Avoid - Always including everything
{% include "all-possible-styles.css" %}
{% include "all-possible-types.ts" %}
```

## Testing Templates

### Validation Strategy
```bash
# Test with minimal variables
unjucks generate component react --dry --componentName Test

# Test with all variables
unjucks generate component react --dry --componentName TestButton --withProps --withTests --withStyles

# Test edge cases
unjucks generate component react --dry --componentName "" # Should fail gracefully
unjucks generate component react --dry # Should prompt or use defaults
```

### Template Testing
```typescript
// tests/templates/component.test.ts
import { Generator } from 'unjucks';

describe('Component Template', () => {
  const generator = new Generator('./templates');
  
  it('generates basic component', async () => {
    const result = await generator.generate({
      generator: 'component',
      template: 'react',
      componentName: 'TestButton',
      dry: true
    });
    
    expect(result.files).toHaveLength(1);
    expect(result.files[0].content).toContain('TestButton');
  });
  
  it('handles props correctly', async () => {
    const result = await generator.generate({
      generator: 'component', 
      template: 'react',
      componentName: 'TestButton',
      withProps: true,
      dry: true
    });
    
    expect(result.files[0].content).toContain('TestButtonProps');
    expect(result.files[0].content).toContain('React.FC<TestButtonProps>');
  });
});
```

## Common Anti-Patterns

### Avoid These Patterns

**❌ Generic variable names**
```yaml
name: "Button"           # Too generic
type: "component"        # Not descriptive
data: {...}             # What kind of data?
```

**❌ Complex inline logic**
```typescript
// Hard to read and maintain
export const {{ componentName | pascalCase }}{% if withProps and framework === 'react' and includeTypes %}: React.FC<{{ componentName | pascalCase }}Props>{% endif %} = ({% if withProps %}{% if destructureProps %}{ prop1, prop2 }{% else %}props{% endif %}{% endif %}) => {
```

**❌ No error handling**
```typescript
// Will break if fields is undefined
{% for field in fields %}
{{ field.name }}: {{ field.type }};
{% endfor %}
```

**❌ Hardcoded values**
```typescript
import React from 'react';           // ✅ OK - Standard import
import { API_URL } from './config';  // ❌ Should be variable
```

## Migration and Versioning

### Template Versioning
```yaml
# config.yml
name: "component"
version: "2.0.0"
description: "React components with hooks support"
compatibility:
  minUnjucksVersion: "1.0.0"
breaking:
  - "Changed default export format"
  - "Removed class component support"
migration:
  from: "1.x"
  guide: "docs/migration-v2.md"
```

### Backward Compatibility
```typescript
// Support both old and new variable names
{% set compName = componentName or name %}
{% if compName %}
export const {{ compName | pascalCase }} = () => {
  // Component implementation
};
{% else %}
{% error "componentName (or deprecated 'name') is required" %}
{% endif %}
```

## Summary Checklist

✅ **Template Organization**
- [ ] Logical directory structure
- [ ] Consistent naming conventions
- [ ] Reusable common templates

✅ **Variable Design**
- [ ] Descriptive variable names
- [ ] Appropriate types (boolean, string, array)
- [ ] Sensible defaults in config

✅ **Code Quality**
- [ ] Clean, readable output
- [ ] Proper error handling
- [ ] Efficient variable processing

✅ **Testing**
- [ ] Template validation tests
- [ ] Edge case handling
- [ ] Performance verification

✅ **Documentation**
- [ ] Clear template descriptions
- [ ] Usage examples
- [ ] Variable documentation

Following these practices will result in maintainable, reliable templates that generate consistent, high-quality code.
import { describe, it, expect, beforeAll, afterAll, beforeEach } from 'vitest';
import { TemplateDiscovery } from '../../src/lib/template-discovery.js';
import { mkdirSync, writeFileSync, rmSync } from 'fs';
import { join } from 'path';
import { tmpdir } from 'os';

describe('Template Discovery Engine', () => {
  let discovery;
  let testTemplateDir => { // Create temporary test template directory
    testTemplateDir = join(tmpdir(), 'unjucks-test-templates-' + Date.now());
    mkdirSync(testTemplateDir, { recursive });
  });

  afterAll(() => { // Cleanup test template directory
    if (testTemplateDir) {
      rmSync(testTemplateDir, { recursive, force });
    }
  });

  beforeEach(() => {
    discovery = new TemplateDiscovery([testTemplateDir]);
  });

  describe('Template Indexing', () => { it('should index templates correctly', async () => {
      // Create test template
      const templatePath = join(testTemplateDir, 'test-component');
      mkdirSync(templatePath, { recursive });
      
      writeFileSync(join(templatePath, 'meta.yml'), `
name: "Test Component"
description: "A test component template"
category: "test"
complexity: "beginner"
tags: ["test", "component"]
variables:
  - name: componentName
    type: string
    required: true
`);

      writeFileSync(join(templatePath, '{{ componentName }}.tsx'), `
import React from 'react';

export const {{ componentName }}: React.FC = () => {
  return {{ componentName }}</div>;
};
`);

      // Index templates
      await discovery.indexTemplates();
      const templates = await discovery.getTemplates();

      expect(templates).toHaveLength(1);
      expect(templates[0]).toMatchObject({ name });
      expect(templates[0].variables).toHaveLength(1);
      expect(templates[0].variables[0]).toMatchObject({ name });

    it('should extract variables from template files', async () => { const templatePath = join(testTemplateDir, 'variable-extraction');
      mkdirSync(templatePath, { recursive });

      // Template with various variable patterns
      writeFileSync(join(templatePath, 'component.tsx'), `
import React from 'react';

interface {{ componentName }}Props { title }description?: string;{% endif %}
}

export const {{ componentName }}: React.FC<{{ componentName }}Props> = ({ 
  title{% if withDescription %}, description{% endif %} 
}) => {
  return (
    <div className="{{ className }}">
      {title}</h2>
      {% if withDescription %}{description}</p>{% endif %}
    </div>
  );
};
`);

      await discovery.indexTemplates();
      const template = (await discovery.getTemplates())[0];
      
      expect(template.variables.map(v => v.name)).toContain('componentName');
      expect(template.variables.map(v => v.name)).toContain('className');
      expect(template.variables.map(v => v.name)).toContain('withDescription');
    });

    it('should handle multiple template directories', async () => { // Create templates in different categories
      const reactPath = join(testTemplateDir, 'react', 'component');
      const apiPath = join(testTemplateDir, 'api', 'endpoint');
      
      mkdirSync(reactPath, { recursive });
      mkdirSync(apiPath, { recursive });

      writeFileSync(join(reactPath, 'Component.tsx'), 'React component: {{ name }}');
      writeFileSync(join(apiPath, 'endpoint.ts'), 'API endpoint: {{ name }}');

      await discovery.indexTemplates();
      const templates = await discovery.getTemplates();

      expect(templates).toHaveLength(2);
      expect(templates.find(t => t.category === 'react')).toBeDefined();
      expect(templates.find(t => t.category === 'api')).toBeDefined();
    });
  });

  describe('Template Search', () => { beforeEach(async () => {
      // Create multiple test templates
      const templates = [
        {
          name },
          files: ['{{ name }}.tsx', '{{ name }}.test.tsx']
        },
        { name },
          files: ['{{ name }}.controller.ts', '{{ name }}.routes.ts']
        },
        { name },
          files: ['{{ name }}.model.ts', 'migrations/create_{{ name }}.sql']
        }
      ];

      for (const template of templates) { const templatePath = join(testTemplateDir, template.name);
        mkdirSync(templatePath, { recursive });
        
        writeFileSync(join(templatePath, 'meta.yml'), 
          Object.entries(template.meta)
            .map(([key, value]) => `${key}: ${JSON.stringify(value)}`)
            .join('\n')
        );

        for (const file of template.files) { const filePath = join(templatePath, file);
          mkdirSync(join(filePath, '..'), { recursive });
          writeFileSync(filePath, `Template file);
        }
      }

      await discovery.indexTemplates();
    });

    it('should search by text query', async () => {
      const results = await discovery.searchTemplates({ search);
      
      expect(results).toHaveLength(1);
      expect(results[0].name).toBe('React Component');
    });

    it('should filter by category', async () => {
      const results = await discovery.searchTemplates({ category);
      
      expect(results).toHaveLength(1);
      expect(results[0].category).toBe('backend');
    });

    it('should filter by tags', async () => {
      const results = await discovery.searchTemplates({ tags);
      
      expect(results).toHaveLength(1);
      expect(results[0].tags).toContain('typescript');
    });

    it('should filter by complexity', async () => {
      const results = await discovery.searchTemplates({ complexity);
      
      expect(results).toHaveLength(1);
      expect(results[0].complexity).toBe('beginner');
    });

    it('should combine multiple filters', async () => { const results = await discovery.searchTemplates({ 
        category });

    it('should return empty array for no matches', async () => {
      const results = await discovery.searchTemplates({ search);
      
      expect(results).toHaveLength(0);
    });
  });

  describe('Template Preview', () => { beforeEach(async () => {
      const templatePath = join(testTemplateDir, 'preview-test');
      mkdirSync(templatePath, { recursive });
      
      writeFileSync(join(templatePath, 'meta.yml'), `
name: "Preview Test"
description: "Template for testing preview functionality"
category: "test"
variables:
  - name: componentName
    type: string
    default: "TestComponent"
  - name: withProps
    type: boolean
    default: true
`);

      writeFileSync(join(templatePath, '{{ componentName }}.tsx'), `
import React from 'react';

{% if withProps %}
interface {{ componentName }}Props { title }

export const {{ componentName }}: React.FC<{{ componentName }}Props> = ({ title }) => {
{% else %}
export const {{ componentName }}: React.FC = () => {
{% endif %}
  return {{ componentName }}: {title}</div>;
};
`);

      await discovery.indexTemplates();
    });

    it('should generate sample output with default variables', async () => {
      const templates = await discovery.getTemplates();
      const template = templates[0];

      expect(template.sampleOutput).toBeDefined();
      expect(template.sampleOutput).toContain('TestComponent');
    });

    it('should include variable information', async () => { const templates = await discovery.getTemplates();
      const template = templates[0];

      expect(template.variables).toHaveLength(2);
      
      const componentNameVar = template.variables.find(v => v.name === 'componentName');
      expect(componentNameVar).toMatchObject({
        name });
  });

  describe('Categories and Tags', () => { beforeEach(async () => {
      // Create templates with various categories and tags
      const templates = [
        { name },
        { name },
        { name },
        { name }
      ];

      for (const template of templates) { const templatePath = join(testTemplateDir, template.name);
        mkdirSync(templatePath, { recursive });
        
        writeFileSync(join(templatePath, 'template.txt'), 'Template content');
        writeFileSync(join(templatePath, 'meta.yml'), `
name: "${template.name}"
category: "${template.category}"
tags: [${template.tags.map(t => `"${t}"`).join(', ')}]
`);
      }

      await discovery.indexTemplates();
    });

    it('should get all categories', async () => {
      const categories = await discovery.getCategories();
      
      expect(categories).toContain('frontend');
      expect(categories).toContain('backend');
      expect(categories).toContain('database');
      expect(categories).toHaveLength(3);
    });

    it('should get all tags', async () => {
      const tags = await discovery.getTags();
      
      expect(tags).toContain('react');
      expect(tags).toContain('typescript');
      expect(tags).toContain('nodejs');
      expect(tags).toContain('api');
      expect(tags).toContain('vue');
      expect(tags).toContain('javascript');
      expect(tags).toContain('postgresql');
      expect(tags).toContain('migration');
    });
  });

  describe('Recommendations', () => { beforeEach(async () => {
      // Create templates with different characteristics
      const templates = [
        {
          name }
        },
        { name }
        },
        { name }
        }
      ];

      for (const template of templates) { const templatePath = join(testTemplateDir, template.name);
        mkdirSync(templatePath, { recursive });
        
        writeFileSync(join(templatePath, 'template.txt'), 'Template content');
        writeFileSync(join(templatePath, 'meta.yml'), 
          Object.entries(template.meta)
            .map(([key, value]) => `${key}: ${JSON.stringify(value)}`)
            .join('\n')
        );
      }

      await discovery.indexTemplates();
    });

    it('should provide recommendations based on project context', async () => { const projectContext = {
        packageJson }
        }
      };

      const recommendations = await discovery.getRecommendations(projectContext);
      
      expect(recommendations).toHaveLength(1);
      expect(recommendations[0].name).toContain('react');
    });

    it('should provide default recommendations when no context', async () => {
      const recommendations = await discovery.getRecommendations();
      
      expect(recommendations.length).toBeGreaterThan(0);
      // Should prioritize beginner templates
      expect(recommendations.every(r => r.complexity === 'beginner')).toBe(true);
    });
  });

  describe('Performance', () => {
    it('should index large number of templates efficiently', async () => {
      // Create many templates
      for (let i = 0; i < 100; i++) {
        const templatePath = join(testTemplateDir, `perf-test-${i}`);
        mkdirSync(templatePath, { recursive });
        
        writeFileSync(join(templatePath, 'template.txt'), `Template ${i}: {{ name }}`);
        writeFileSync(join(templatePath, 'meta.yml'), `
name: "Performance Test ${i}"
category: "test"
tags: ["performance", "test${i % 10}"]
`);
      }

      const startTime = Date.now();
      await discovery.indexTemplates();
      const indexTime = Date.now() - startTime;

      const templates = await discovery.getTemplates();
      expect(templates).toHaveLength(100);
      
      // Should index 100 templates in reasonable time (less than 5 seconds)
      expect(indexTime).toBeLessThan(5000);
    });

    it('should search efficiently', async () => {
      // Index templates first
      for (let i = 0; i < 50; i++) {
        const templatePath = join(testTemplateDir, `search-test-${i}`);
        mkdirSync(templatePath, { recursive });
        
        writeFileSync(join(templatePath, 'template.txt'), `Template ${i}`);
        writeFileSync(join(templatePath, 'meta.yml'), `
name: "Search Test ${i}"
category: "${ i % 5 === 0 ? 'special'  }"
tags: ["tag${i % 3}", "search"]
`);
      }

      await discovery.indexTemplates();

      // Search should be fast
      const startTime = Date.now();
      const results = await discovery.searchTemplates({ search);
      const searchTime = Date.now() - startTime;

      expect(results).toHaveLength(50);
      expect(searchTime).toBeLessThan(100); // Should complete in under 100ms
    });
  });

  describe('Error Handling', () => {
    it('should handle invalid template directories gracefully', async () => {
      const invalidDiscovery = new TemplateDiscovery(['/nonexistent/path']);
      
      await expect(invalidDiscovery.indexTemplates()).resolves.not.toThrow();
      
      const templates = await invalidDiscovery.getTemplates();
      expect(templates).toHaveLength(0);
    });

    it('should handle malformed meta.yml files', async () => { const templatePath = join(testTemplateDir, 'malformed-meta');
      mkdirSync(templatePath, { recursive });
      
      writeFileSync(join(templatePath, 'template.txt'), 'Template content');
      writeFileSync(join(templatePath, 'meta.yml'), 'invalid: yaml: content:');

      await expect(discovery.indexTemplates()).resolves.not.toThrow();
      
      const templates = await discovery.getTemplates();
      const malformedTemplate = templates.find(t => t.id.includes('malformed-meta'));
      expect(malformedTemplate).toBeDefined(); // Should still create template with defaults
    });

    it('should handle templates without meta files', async () => { const templatePath = join(testTemplateDir, 'no-meta');
      mkdirSync(templatePath, { recursive });
      
      writeFileSync(join(templatePath, 'template.njk'), 'Template: {{ name }}');

      await discovery.indexTemplates();
      
      const templates = await discovery.getTemplates();
      const noMetaTemplate = templates.find(t => t.id.includes('no-meta'));
      
      expect(noMetaTemplate).toBeDefined();
      expect(noMetaTemplate?.name).toBe('No Meta'); // Should generate name from directory
    });
  });
});
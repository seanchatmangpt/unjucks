/**
 * Integration Tests for Semantic MCP Tools
 * Tests the four new semantic MCP tools in realistic scenarios
 */

import { describe, it, expect, beforeEach } from 'vitest';
import type { MCPRequest } from '../../src/mcp/types.js';
import { unjucksSemanticValidate } from '../../src/mcp/tools/unjucks-semantic-validate.js';
import { unjucksReasoningApply } from '../../src/mcp/tools/unjucks-reasoning-apply.js';
import { unjucksKnowledgeQuery } from '../../src/mcp/tools/unjucks-knowledge-query.js';
import { unjucksComplianceCheck } from '../../src/mcp/tools/unjucks-compliance-check.js';
import { join, dirname } from 'node:path';
import { fileURLToPath } from 'node:url';
import { writeFile, mkdir } from 'node:fs/promises';

const __dirname = dirname(fileURLToPath(import.meta.url));
const testDataDir = join(__dirname, '../fixtures/semantic-integration');

describe('Semantic MCP Tools Integration', () => {
  let mockTemplatePath: string;

  beforeEach(async () => {
    // Create test data directory
    await mkdir(testDataDir, { recursive: true });
    
    // Create mock enterprise template
    mockTemplatePath = join(testDataDir, 'enterprise-api.njk');
    const enterpriseTemplate = `---
to: src/api/{{ serviceName }}.ts
inject: false
rdf: |
  @prefix template: <http://unjucks.dev/template/> .
  @prefix api: <http://unjucks.dev/api/> .
  
  <http://unjucks.dev/template/current>
    api:generatesEndpoint true ;
    api:isPublic {{ isPublic }} ;
    template:processesFinancialData {{ processesFinancialData || false }} ;
    template:hasUserAuth {{ hasUserAuth || false }} .
---
/**
 * {{ serviceName }} API Service
 * Generated by Unjucks with semantic validation
 */
import { Request, Response } from 'express';
import { authenticate, authorize } from '../middleware/auth';
import { validateInput, sanitizeOutput } from '../middleware/security';
import { auditLogger } from '../utils/audit';

export class {{ serviceName }}Service {
  {% if processesFinancialData %}
  /**
   * SOX Compliance: Financial data processing with audit trail
   */
  async processFinancialData(data: FinancialData): Promise<ProcessResult> {
    auditLogger.logFinancialAccess(data.id, 'READ');
    // Financial processing logic
    return this.financialProcessor.process(data);
  }
  {% endif %}
  
  {% if isPublic %}
  /**
   * Public API endpoint - requires authentication and rate limiting
   */
  @authenticate
  @authorize(['user'])
  @validateInput
  @sanitizeOutput
  async getPublicData(req: Request, res: Response): Promise<void> {
    // Public API logic with security controls
    const data = await this.dataService.getPublicData(req.params.id);
    res.json(data);
  }
  {% endif %}
}`;
    
    await writeFile(mockTemplatePath, enterpriseTemplate);
  });

  describe('unjucks_semantic_validate', () => {
    it('should validate enterprise template successfully', async () => {
      const request: MCPRequest<any> = {
        jsonrpc: '2.0',
        id: 1,
        method: 'tools/call',
        params: {
          templatePath: mockTemplatePath,
          compliance: ['API_GOVERNANCE', 'SOX'],
          strictMode: false,
          outputFormat: 'json'
        }
      };

      const response = await unjucksSemanticValidate.execute(request);
      
      expect(response.jsonrpc).toBe('2.0');
      expect(response.id).toBe(1);
      expect(response.result).toHaveProperty('success', true);
      expect(response.result).toHaveProperty('validation');
      
      const validation = response.result.validation;
      expect(validation).toHaveProperty('valid');
      expect(validation).toHaveProperty('score');
      expect(validation).toHaveProperty('violations');
      expect(validation.score).toBeGreaterThanOrEqual(0);
      expect(validation.score).toBeLessThanOrEqual(100);
    });

    it('should return turtle format validation results', async () => {
      const request: MCPRequest<any> = {
        jsonrpc: '2.0',
        id: 2,
        method: 'tools/call',
        params: {
          templatePath: mockTemplatePath,
          compliance: ['API_GOVERNANCE'],
          outputFormat: 'turtle'
        }
      };

      const response = await unjucksSemanticValidate.execute(request);
      
      expect(response.result.success).toBe(true);
      expect(typeof response.result.validation).toBe('string');
      expect(response.result.validation).toContain('@prefix validation:');
      expect(response.result.validation).toContain('validation:isValid');
    });

    it('should handle invalid template paths gracefully', async () => {
      const request: MCPRequest<any> = {
        jsonrpc: '2.0',
        id: 3,
        method: 'tools/call',
        params: {
          templatePath: '/nonexistent/template.njk',
          compliance: ['API_GOVERNANCE']
        }
      };

      const response = await unjucksSemanticValidate.execute(request);
      
      expect(response.result.success).toBe(true);
      expect(response.result.validation.valid).toBe(false);
      expect(response.result.validation.violations.length).toBeGreaterThan(0);
    });

    it('should validate missing required parameters', async () => {
      const request: MCPRequest<any> = {
        jsonrpc: '2.0',
        id: 4,
        method: 'tools/call',
        params: {} // Missing templatePath
      };

      const response = await unjucksSemanticValidate.execute(request);
      
      expect(response).toHaveProperty('error');
      expect(response.error?.message).toContain('templatePath is required');
    });
  });

  describe('unjucks_reasoning_apply', () => {
    it('should apply N3 reasoning to template variables', async () => {
      const request: MCPRequest<any> = {
        jsonrpc: '2.0',
        id: 5,
        method: 'tools/call',
        params: {
          templateVars: {
            serviceName: 'UserService',
            isPublic: true,
            processesFinancialData: false,
            hasUserAuth: false
          },
          rules: [
            `@prefix api: <http://unjucks.dev/api/> .
             @prefix template: <http://unjucks.dev/template/> .
             { ?ctx api:generatesEndpoint true ; api:isPublic true }
             => 
             { ?ctx api:requiresAuthentication true ; api:requiresRateLimiting true } .`
          ],
          premises: [],
          depth: 2,
          outputInferences: true,
          enhanceContext: true
        }
      };

      const response = await unjucksReasoningApply.execute(request);
      
      expect(response.result.success).toBe(true);
      expect(response.result).toHaveProperty('enhancedContext');
      expect(response.result).toHaveProperty('inferences');
      expect(response.result).toHaveProperty('insights');
      expect(response.result).toHaveProperty('metadata');
      
      expect(response.result.enhancedContext).toHaveProperty('serviceName', 'UserService');
      expect(response.result.inferences).toBeInstanceOf(Array);
      expect(response.result.insights).toHaveProperty('newVariables');
      expect(response.result.insights).toHaveProperty('recommendations');
    });

    it('should handle complex reasoning scenarios', async () => {
      const request: MCPRequest<any> = {
        jsonrpc: '2.0',
        id: 6,
        method: 'tools/call',
        params: {
          templateVars: {
            isPublic: true,
            processesFinancialData: true,
            expectedRequestsPerMinute: 2000
          },
          rules: [
            `@prefix api: <http://unjucks.dev/api/> .
             @prefix sox: <http://compliance.enterprise.org/sox/> .
             @prefix template: <http://unjucks.dev/template/> .
             
             { ?ctx api:isPublic true }
             => { ?ctx api:requiresAuthentication true } .
             
             { ?ctx template:processesFinancialData true }
             => { ?ctx sox:requiresAuditTrail true } .`
          ],
          premises: [],
          depth: 3
        }
      };

      const response = await unjucksReasoningApply.execute(request);
      
      expect(response.result.success).toBe(true);
      expect(response.result.metadata).toHaveProperty('reasoningConfig');
      expect(response.result.metadata.reasoningConfig.depth).toBe(3);
    });

    it('should validate required parameters', async () => {
      const request: MCPRequest<any> = {
        jsonrpc: '2.0',
        id: 7,
        method: 'tools/call',
        params: {
          templateVars: { test: 'value' }
          // Missing rules parameter
        }
      };

      const response = await unjucksReasoningApply.execute(request);
      
      expect(response).toHaveProperty('error');
      expect(response.error?.message).toContain('rules array is required');
    });
  });

  describe('unjucks_knowledge_query', () => {
    it('should query knowledge graph with pattern matching', async () => {
      const request: MCPRequest<any> = {
        jsonrpc: '2.0',
        id: 8,
        method: 'tools/call',
        params: {
          query: {
            pattern: {
              predicate: 'http://unjucks.dev/api/generatesEndpoint'
            },
            limit: 5
          },
          outputFormat: 'json',
          includeMeta: true
        }
      };

      const response = await unjucksKnowledgeQuery.execute(request);
      
      expect(response.result.success).toBe(true);
      expect(response.result).toHaveProperty('results');
      expect(response.result).toHaveProperty('resultCount');
      expect(response.result).toHaveProperty('metadata');
      expect(response.result.results).toBeInstanceOf(Array);
      expect(response.result.resultCount).toBe(response.result.results.length);
    });

    it('should format results as CSV', async () => {
      const request: MCPRequest<any> = {
        jsonrpc: '2.0',
        id: 9,
        method: 'tools/call',
        params: {
          query: {
            pattern: {
              subject: 'http://unjucks.dev/template/test'
            }
          },
          outputFormat: 'csv'
        }
      };

      const response = await unjucksKnowledgeQuery.execute(request);
      
      expect(response.result.success).toBe(true);
      // CSV results should be string format
      if (response.result.results.length === 0) {
        expect(response.result.results).toBe('');
      } else {
        expect(typeof response.result.results).toBe('string');
      }
    });

    it('should format results as table', async () => {
      const request: MCPRequest<any> = {
        jsonrpc: '2.0',
        id: 10,
        method: 'tools/call',
        params: {
          query: {
            pattern: {
              predicate: 'http://www.w3.org/1999/02/22-rdf-syntax-ns#type'
            },
            limit: 3
          },
          outputFormat: 'table'
        }
      };

      const response = await unjucksKnowledgeQuery.execute(request);
      
      expect(response.result.success).toBe(true);
      if (Array.isArray(response.result.results) && response.result.results.length > 0) {
        expect(typeof response.result.results).toBe('string');
        expect(response.result.results).toContain('|');
        expect(response.result.results).toContain('+');
      }
    });

    it('should validate query parameters', async () => {
      const request: MCPRequest<any> = {
        jsonrpc: '2.0',
        id: 11,
        method: 'tools/call',
        params: {
          query: {} // Missing both sparql and pattern
        }
      };

      const response = await unjucksKnowledgeQuery.execute(request);
      
      expect(response).toHaveProperty('error');
      expect(response.error?.message).toContain('Either sparql or pattern query must be provided');
    });
  });

  describe('unjucks_compliance_check', () => {
    it('should perform comprehensive compliance check', async () => {
      const request: MCPRequest<any> = {
        jsonrpc: '2.0',
        id: 12,
        method: 'tools/call',
        params: {
          templatePath: mockTemplatePath,
          policies: ['SOX', 'API_GOVERNANCE'],
          generateReport: true,
          includeRecommendations: true,
          outputFormat: 'json'
        }
      };

      const response = await unjucksComplianceCheck.execute(request);
      
      expect(response.result.success).toBe(true);
      expect(response.result).toHaveProperty('compliance');
      expect(response.result).toHaveProperty('report');
      expect(response.result).toHaveProperty('recommendations');
      expect(response.result).toHaveProperty('metadata');
      
      const compliance = response.result.compliance;
      expect(compliance).toHaveProperty('valid');
      expect(compliance).toHaveProperty('score');
      expect(compliance).toHaveProperty('violations');
      expect(compliance).toHaveProperty('summary');
      
      const summary = compliance.summary;
      expect(summary).toHaveProperty('overallStatus');
      expect(summary).toHaveProperty('policyResults');
      expect(summary).toHaveProperty('criticalIssues');
    });

    it('should generate HTML compliance report', async () => {
      const request: MCPRequest<any> = {
        jsonrpc: '2.0',
        id: 13,
        method: 'tools/call',
        params: {
          templatePath: mockTemplatePath,
          policies: ['GDPR', 'API_GOVERNANCE'],
          generateReport: true,
          outputFormat: 'html'
        }
      };

      const response = await unjucksComplianceCheck.execute(request);
      
      expect(response.result.success).toBe(true);
      expect(response.result.report).toContain('<html>');
      expect(response.result.report).toContain('Compliance Report');
      expect(response.result.report).toContain('</html>');
    });

    it('should generate markdown compliance report', async () => {
      const request: MCPRequest<any> = {
        jsonrpc: '2.0',
        id: 14,
        method: 'tools/call',
        params: {
          templatePath: mockTemplatePath,
          policies: ['SOX'],
          generateReport: true,
          outputFormat: 'markdown'
        }
      };

      const response = await unjucksComplianceCheck.execute(request);
      
      expect(response.result.success).toBe(true);
      expect(response.result.report).toContain('# Enterprise Compliance Report');
      expect(response.result.report).toContain('## Compliance Summary');
    });

    it('should provide detailed recommendations', async () => {
      const request: MCPRequest<any> = {
        jsonrpc: '2.0',
        id: 15,
        method: 'tools/call',
        params: {
          templatePath: mockTemplatePath,
          policies: ['API_GOVERNANCE', 'SOX', 'GDPR'],
          includeRecommendations: true
        }
      };

      const response = await unjucksComplianceCheck.execute(request);
      
      expect(response.result.success).toBe(true);
      expect(response.result.recommendations).toBeInstanceOf(Array);
      
      if (response.result.recommendations.length > 0) {
        const recommendation = response.result.recommendations[0];
        expect(recommendation).toHaveProperty('category');
        expect(recommendation).toHaveProperty('priority');
        expect(recommendation).toHaveProperty('title');
        expect(recommendation).toHaveProperty('description');
        expect(recommendation).toHaveProperty('implementation');
        expect(recommendation.implementation).toBeInstanceOf(Array);
      }
    });

    it('should enforce strict mode compliance', async () => {
      const request: MCPRequest<any> = {
        jsonrpc: '2.0',
        id: 16,
        method: 'tools/call',
        params: {
          templatePath: mockTemplatePath,
          policies: ['API_GOVERNANCE'],
          strictMode: true
        }
      };

      const response = await unjucksComplianceCheck.execute(request);
      
      expect(response.result.success).toBe(true);
      expect(response.result.metadata.strictMode).toBe(true);
    });

    it('should validate required parameters', async () => {
      const request: MCPRequest<any> = {
        jsonrpc: '2.0',
        id: 17,
        method: 'tools/call',
        params: {
          templatePath: mockTemplatePath
          // Missing policies parameter
        }
      };

      const response = await unjucksComplianceCheck.execute(request);
      
      expect(response).toHaveProperty('error');
      expect(response.error?.message).toContain('At least one policy must be specified');
    });
  });

  describe('Cross-Tool Integration', () => {
    it('should use reasoning results to enhance compliance checking', async () => {
      // First, apply reasoning to template variables
      const reasoningRequest: MCPRequest<any> = {
        jsonrpc: '2.0',
        id: 18,
        method: 'tools/call',
        params: {
          templateVars: {
            isPublic: true,
            processesFinancialData: true
          },
          rules: [
            `@prefix api: <http://unjucks.dev/api/> .
             @prefix sox: <http://compliance.enterprise.org/sox/> .
             { ?ctx api:isPublic true }
             => { ?ctx api:requiresAuthentication true } .`
          ],
          premises: []
        }
      };

      const reasoningResponse = await unjucksReasoningApply.execute(reasoningRequest);
      expect(reasoningResponse.result.success).toBe(true);

      // Then use the enhanced context for compliance checking
      const complianceRequest: MCPRequest<any> = {
        jsonrpc: '2.0',
        id: 19,
        method: 'tools/call',
        params: {
          templatePath: mockTemplatePath,
          policies: ['API_GOVERNANCE', 'SOX']
        }
      };

      const complianceResponse = await unjucksComplianceCheck.execute(complianceRequest);
      expect(complianceResponse.result.success).toBe(true);
    });

    it('should validate templates and query results for consistency', async () => {
      // Validate template first
      const validationRequest: MCPRequest<any> = {
        jsonrpc: '2.0',
        id: 20,
        method: 'tools/call',
        params: {
          templatePath: mockTemplatePath,
          compliance: ['API_GOVERNANCE']
        }
      };

      const validationResponse = await unjucksSemanticValidate.execute(validationRequest);
      expect(validationResponse.result.success).toBe(true);

      // Then query for similar templates
      const queryRequest: MCPRequest<any> = {
        jsonrpc: '2.0',
        id: 21,
        method: 'tools/call',
        params: {
          query: {
            pattern: {
              predicate: 'http://unjucks.dev/api/generatesEndpoint'
            }
          }
        }
      };

      const queryResponse = await unjucksKnowledgeQuery.execute(queryRequest);
      expect(queryResponse.result.success).toBe(true);
    });
  });
});
/**
 * Integration Tests for Semantic MCP Tools
 * Tests the four new semantic MCP tools in realistic scenarios
 */

import { describe, it, expect, beforeEach } from 'vitest';
import { unjucksSemanticValidate } from '../../src/mcp/tools/unjucks-semantic-validate.js';
import { unjucksReasoningApply } from '../../src/mcp/tools/unjucks-reasoning-apply.js';
import { unjucksKnowledgeQuery } from '../../src/mcp/tools/unjucks-knowledge-query.js';
import { unjucksComplianceCheck } from '../../src/mcp/tools/unjucks-compliance-check.js';
import { join, dirname } from 'node:path';
import { fileURLToPath } from 'node:url';
import { writeFile, mkdir } from 'node:fs/promises';

const __dirname = dirname(fileURLToPath(import.meta.url));
const testDataDir = join(__dirname, '../fixtures/semantic-integration');

describe('Semantic MCP Tools Integration', () => {
  let mockTemplatePath => { // Create test data directory
    await mkdir(testDataDir, { recursive });
    
    // Create mock enterprise template
    mockTemplatePath = join(testDataDir, 'enterprise-api.njk');
    const enterpriseTemplate = `---
to: src/api/{{ serviceName }}.ts
inject: false
rdf: |
  @prefix template: <http://unjucks.dev/template/> .
  @prefix api: <http://unjucks.dev/api/> .
  
  <http://unjucks.dev/template/current>
    api:generatesEndpoint true ;
    api:isPublic {{ isPublic }} ;
    template:processesFinancialData {{ processesFinancialData || false }} ;
    template:hasUserAuth {{ hasUserAuth || false }} .
---
/**
 * {{ serviceName }} API Service
 * Generated by Unjucks with semantic validation
 */
import { Request, Response } from 'express';
import { authenticate, authorize } from '../middleware/auth.js';
import { validateInput, sanitizeOutput } from '../middleware/security.js';
import { auditLogger } from '../utils/audit.js';

export class {{ serviceName }}Service {
  {% if processesFinancialData %}
  /**
   * SOX Compliance: Financial data processing with audit trail
   */
  async processFinancialData(data) {
    auditLogger.logFinancialAccess(data.id, 'READ');
    // Financial processing logic
    return this.financialProcessor.process(data);
  }
  {% endif %}
  
  {% if isPublic %}
  /**
   * Public API endpoint - requires authentication and rate limiting
   */
  @authenticate
  @authorize(['user'])
  @validateInput
  @sanitizeOutput
  async getPublicData(req, res) {
    // Public API logic with security controls
    const data = await this.dataService.getPublicData(req.params.id);
    res.json(data);
  }
  {% endif %}
}`;
    
    await writeFile(mockTemplatePath, enterpriseTemplate);
  });

  describe('unjucks_semantic_validate', () => { it('should validate enterprise template successfully', async () => {
      const request = {
        jsonrpc }
      };

      const response = await unjucksSemanticValidate.execute(request);
      
      expect(response.jsonrpc).toBe('2.0');
      expect(response.id).toBe(1);
      expect(response.result).toHaveProperty('success', true);
      expect(response.result).toHaveProperty('validation');
      
      const validation = response.result.validation;
      expect(validation).toHaveProperty('valid');
      expect(validation).toHaveProperty('score');
      expect(validation).toHaveProperty('violations');
      expect(validation.score).toBeGreaterThanOrEqual(0);
      expect(validation.score).toBeLessThanOrEqual(100);
    });

    it('should return turtle format validation results', async () => { const request = {
        jsonrpc }
      };

      const response = await unjucksSemanticValidate.execute(request);
      
      expect(response.result.success).toBe(true);
      expect(typeof response.result.validation).toBe('string');
      expect(response.result.validation).toContain('@prefix validation:');
      expect(response.result.validation).toContain('validation:isValid');
    });

    it('should handle invalid template paths gracefully', async () => { const request = {
        jsonrpc }
      };

      const response = await unjucksSemanticValidate.execute(request);
      
      expect(response.result.success).toBe(true);
      expect(response.result.validation.valid).toBe(false);
      expect(response.result.validation.violations.length).toBeGreaterThan(0);
    });

    it('should validate missing required parameters', async () => { const request = {
        jsonrpc } // Missing templatePath
      };

      const response = await unjucksSemanticValidate.execute(request);
      
      expect(response).toHaveProperty('error');
      expect(response.error?.message).toContain('templatePath is required');
    });
  });

  describe('unjucks_reasoning_apply', () => { it('should apply N3 reasoning to template variables', async () => {
      const request = {
        jsonrpc },
          rules: [
            `@prefix api: <http://unjucks.dev/api/> .
             @prefix template: <http://unjucks.dev/template/> .
             { ?ctx api }
             => 
             { ?ctx api } .`
          ],
          premises: [],
          depth: 2,
          outputInferences,
          enhanceContext: true
        }
      };

      const response = await unjucksReasoningApply.execute(request);
      
      expect(response.result.success).toBe(true);
      expect(response.result).toHaveProperty('enhancedContext');
      expect(response.result).toHaveProperty('inferences');
      expect(response.result).toHaveProperty('insights');
      expect(response.result).toHaveProperty('metadata');
      
      expect(response.result.enhancedContext).toHaveProperty('serviceName', 'UserService');
      expect(response.result.inferences).toBeInstanceOf(Array);
      expect(response.result.insights).toHaveProperty('newVariables');
      expect(response.result.insights).toHaveProperty('recommendations');
    });

    it('should handle complex reasoning scenarios', async () => { const request = {
        jsonrpc },
          rules: [
            `@prefix api: <http://unjucks.dev/api/> .
             @prefix sox: <http://compliance.enterprise.org/sox/> .
             @prefix template: <http://unjucks.dev/template/> .
             
             { ?ctx api }
             => { ?ctx api } .
             
             { ?ctx template }
             => { ?ctx sox } .`
          ],
          premises: [],
          depth: 3
        }
      };

      const response = await unjucksReasoningApply.execute(request);
      
      expect(response.result.success).toBe(true);
      expect(response.result.metadata).toHaveProperty('reasoningConfig');
      expect(response.result.metadata.reasoningConfig.depth).toBe(3);
    });

    it('should validate required parameters', async () => { const request = {
        jsonrpc }
          // Missing rules parameter
        }
      };

      const response = await unjucksReasoningApply.execute(request);
      
      expect(response).toHaveProperty('error');
      expect(response.error?.message).toContain('rules array is required');
    });
  });

  describe('unjucks_knowledge_query', () => { it('should query knowledge graph with pattern matching', async () => {
      const request = {
        jsonrpc },
            limit: 5
          },
          outputFormat: 'json',
          includeMeta: true
        }
      };

      const response = await unjucksKnowledgeQuery.execute(request);
      
      expect(response.result.success).toBe(true);
      expect(response.result).toHaveProperty('results');
      expect(response.result).toHaveProperty('resultCount');
      expect(response.result).toHaveProperty('metadata');
      expect(response.result.results).toBeInstanceOf(Array);
      expect(response.result.resultCount).toBe(response.result.results.length);
    });

    it('should format results', async () => { const request = {
        jsonrpc }
          },
          outputFormat: 'csv'
        }
      };

      const response = await unjucksKnowledgeQuery.execute(request);
      
      expect(response.result.success).toBe(true);
      // CSV results should be string format
      if (response.result.results.length === 0) {
        expect(response.result.results).toBe('');
      } else {
        expect(typeof response.result.results).toBe('string');
      }
    });

    it('should format results', async () => { const request = {
        jsonrpc },
            limit: 3
          },
          outputFormat: 'table'
        }
      };

      const response = await unjucksKnowledgeQuery.execute(request);
      
      expect(response.result.success).toBe(true);
      if (Array.isArray(response.result.results) && response.result.results.length > 0) {
        expect(typeof response.result.results).toBe('string');
        expect(response.result.results).toContain('|');
        expect(response.result.results).toContain('+');
      }
    });

    it('should validate query parameters', async () => { const request = {
        jsonrpc } // Missing both sparql and pattern
        }
      };

      const response = await unjucksKnowledgeQuery.execute(request);
      
      expect(response).toHaveProperty('error');
      expect(response.error?.message).toContain('Either sparql or pattern query must be provided');
    });
  });

  describe('unjucks_compliance_check', () => { it('should perform comprehensive compliance check', async () => {
      const request = {
        jsonrpc }
      };

      const response = await unjucksComplianceCheck.execute(request);
      
      expect(response.result.success).toBe(true);
      expect(response.result).toHaveProperty('compliance');
      expect(response.result).toHaveProperty('report');
      expect(response.result).toHaveProperty('recommendations');
      expect(response.result).toHaveProperty('metadata');
      
      const compliance = response.result.compliance;
      expect(compliance).toHaveProperty('valid');
      expect(compliance).toHaveProperty('score');
      expect(compliance).toHaveProperty('violations');
      expect(compliance).toHaveProperty('summary');
      
      const summary = compliance.summary;
      expect(summary).toHaveProperty('overallStatus');
      expect(summary).toHaveProperty('policyResults');
      expect(summary).toHaveProperty('criticalIssues');
    });

    it('should generate HTML compliance report', async () => { const request = {
        jsonrpc }
      };

      const response = await unjucksComplianceCheck.execute(request);
      
      expect(response.result.success).toBe(true);
      expect(response.result.report).toContain('');
      expect(response.result.report).toContain('Compliance Report');
      expect(response.result.report).toContain('</html>');
    });

    it('should generate markdown compliance report', async () => { const request = {
        jsonrpc }
      };

      const response = await unjucksComplianceCheck.execute(request);
      
      expect(response.result.success).toBe(true);
      expect(response.result.report).toContain('# Enterprise Compliance Report');
      expect(response.result.report).toContain('## Compliance Summary');
    });

    it('should provide detailed recommendations', async () => { const request = {
        jsonrpc }
      };

      const response = await unjucksComplianceCheck.execute(request);
      
      expect(response.result.success).toBe(true);
      expect(response.result.recommendations).toBeInstanceOf(Array);
      
      if (response.result.recommendations.length > 0) {
        const recommendation = response.result.recommendations[0];
        expect(recommendation).toHaveProperty('category');
        expect(recommendation).toHaveProperty('priority');
        expect(recommendation).toHaveProperty('title');
        expect(recommendation).toHaveProperty('description');
        expect(recommendation).toHaveProperty('implementation');
        expect(recommendation.implementation).toBeInstanceOf(Array);
      }
    });

    it('should enforce strict mode compliance', async () => { const request = {
        jsonrpc }
      };

      const response = await unjucksComplianceCheck.execute(request);
      
      expect(response.result.success).toBe(true);
      expect(response.result.metadata.strictMode).toBe(true);
    });

    it('should validate required parameters', async () => { const request = {
        jsonrpc }
      };

      const response = await unjucksComplianceCheck.execute(request);
      
      expect(response).toHaveProperty('error');
      expect(response.error?.message).toContain('At least one policy must be specified');
    });
  });

  describe('Cross-Tool Integration', () => { it('should use reasoning results to enhance compliance checking', async () => {
      // First, apply reasoning to template variables
      const reasoningRequest = {
        jsonrpc },
          rules: [
            `@prefix api: <http://unjucks.dev/api/> .
             @prefix sox: <http://compliance.enterprise.org/sox/> .
             { ?ctx api }
             => { ?ctx api } .`
          ],
          premises: []
        }
      };

      const reasoningResponse = await unjucksReasoningApply.execute(reasoningRequest);
      expect(reasoningResponse.result.success).toBe(true);

      // Then use the enhanced context for compliance checking
      const complianceRequest = { jsonrpc }
      };

      const complianceResponse = await unjucksComplianceCheck.execute(complianceRequest);
      expect(complianceResponse.result.success).toBe(true);
    });

    it('should validate templates and query results for consistency', async () => { // Validate template first
      const validationRequest = {
        jsonrpc }
      };

      const validationResponse = await unjucksSemanticValidate.execute(validationRequest);
      expect(validationResponse.result.success).toBe(true);

      // Then query for similar templates
      const queryRequest = { jsonrpc }
          }
        }
      };

      const queryResponse = await unjucksKnowledgeQuery.execute(queryRequest);
      expect(queryResponse.result.success).toBe(true);
    });
  });
});
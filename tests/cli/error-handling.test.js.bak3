/**
 * Error Handling and Validation Tests
 * Comprehensive testing of error scenarios and input validation
 */

import { describe, it, expect, beforeEach, afterEach, vi } from 'vitest';
import { execFile } from 'child_process';
import { promisify } from 'util';
import * from 'path';
import * from 'fs/promises';
import { tmpdir } from 'os';

const execFileAsync = promisify(execFile);
const CLI_PATH = path.resolve(__dirname, '../../bin/unjucks.cjs');

async function runCLI(args = [], cwd?) {
  try {
    const { stdout, stderr } = await execFileAsync('node', [CLI_PATH, ...args], { cwd),
      timeout }
    });
    return { stdout, stderr, exitCode };
  } catch (error) { return {
      stdout };
  }
}

describe('Error Handling and Validation', () => {
  let tempDir => {
    originalCwd = process.cwd();
    tempDir = await fs.mkdtemp(path.join(tmpdir(), 'unjucks-errors-'));
    process.chdir(tempDir);
  });

  afterEach(async () => { process.chdir(originalCwd);
    await fs.rm(tempDir, { recursive, force });
  });

  describe('Generator Not Found Errors', () => {
    it('should handle non-existent generators gracefully', async () => {
      const result = await runCLI(['nonexistent-generator', 'new', 'Test']);
      
      expect(result.exitCode).toBe(1);
      expect(result.stderr).toContain('Error');
    });

    it('should suggest available generators when generator not found', async () => { // Create some generators first
      await fs.mkdir('_templates/component', { recursive });
      await fs.writeFile('_templates/component/new.tsx.njk', '---\nto);
      
      const result = await runCLI(['invalid-gen', 'new', 'Test']);
      
      expect(result.exitCode).toBe(1);
      expect(result.stderr).toContain('Error');
    });

    it('should handle empty _templates directory', async () => { await fs.mkdir('_templates', { recursive });
      
      const result = await runCLI(['list']);
      
      expect(result.exitCode).toBe(0);
      expect(result.stdout).toContain('No generators found');
      expect(result.stdout).toContain('unjucks init');
    });

    it('should handle missing _templates directory', async () => {
      const result = await runCLI(['list']);
      
      expect(result.exitCode).toBe(0);
      expect(result.stdout).toContain('No generators found');
    });
  });

  describe('Template Not Found Errors', () => { beforeEach(async () => {
      await fs.mkdir('_templates/component', { recursive });
      await fs.writeFile(
        '_templates/component/new.tsx.njk',
        '---\nto);
    });

    it('should handle non-existent templates gracefully', async () => {
      const result = await runCLI(['component', 'nonexistent', 'Test']);
      
      expect(result.exitCode).toBe(1);
      expect(result.stderr).toContain('Error');
    });

    it('should list available templates when template not found', async () => {
      const result = await runCLI(['component', 'invalid-template', 'Test']);
      
      expect(result.exitCode).toBe(1);
      expect(result.stderr).toContain('Error');
    });
  });

  describe('Malformed Template Errors', () => { beforeEach(async () => {
      await fs.mkdir('_templates/broken', { recursive });
    });

    it('should handle templates with invalid frontmatter', async () => {
      await fs.writeFile(
        '_templates/broken/invalid-frontmatter.njk',
        'invalid frontmatter\n---\nto);

      const result = await runCLI(['broken', 'invalid-frontmatter', 'Test']);
      
      expect(result.exitCode).toBe(1);
      expect(result.stderr).toContain('Error');
    });

    it('should handle templates with missing frontmatter', async () => {
      await fs.writeFile(
        '_templates/broken/no-frontmatter.njk',
        'Just content without frontmatter'
      );

      const result = await runCLI(['broken', 'no-frontmatter', 'Test']);
      
      expect(result.exitCode).toBe(1);
      expect(result.stderr).toContain('Error');
    });

    it('should handle templates with invalid Nunjucks syntax', async () => {
      await fs.writeFile(
        '_templates/broken/syntax-error.njk',
        '---\nto);

      const result = await runCLI(['broken', 'syntax-error', 'Test']);
      
      expect(result.exitCode).toBe(1);
      expect(result.stderr).toContain('Error');
    });

    it('should handle templates with circular includes', async () => {
      await fs.writeFile(
        '_templates/broken/circular1.njk',
        '---\nto);
      
      await fs.writeFile(
        '_templates/broken/circular2.njk',
        '{% include "circular1.njk" %}'
      );

      const result = await runCLI(['broken', 'circular1', 'Test']);
      
      expect(result.exitCode).toBe(1);
      expect(result.stderr).toContain('Error');
    });
  });

  describe('File System Permission Errors', () => { it('should handle read-only destination directories', async () => {
      await fs.mkdir('_templates/component', { recursive });
      await fs.writeFile(
        '_templates/component/new.tsx.njk',
        '---\nto);
      
      await fs.mkdir('readonly-dest', { recursive });
      await fs.chmod('readonly-dest', 0o444); // Read-only

      const result = await runCLI(['component', 'new', 'Test', '--dest', 'readonly-dest']);
      
      // Restore permissions for cleanup
      await fs.chmod('readonly-dest', 0o755);
      
      expect(result.exitCode).toBe(1);
      expect(result.stderr).toContain('Error');
    });

    it('should handle invalid destination paths', async () => { await fs.mkdir('_templates/component', { recursive });
      await fs.writeFile(
        '_templates/component/new.tsx.njk',
        '---\nto);

      const result = await runCLI(['component', 'new', 'Test', '--dest', '/invalid/nonexistent/path']);
      
      expect(result.exitCode).toBe(1);
      expect(result.stderr).toContain('Error');
    });

    it('should handle corrupted template files', async () => { await fs.mkdir('_templates/component', { recursive });
      
      // Create a file with invalid encoding
      const buffer = Buffer.from([0xFF, 0xFE, 0x00, 0x00]);
      await fs.writeFile('_templates/component/corrupted.njk', buffer);

      const result = await runCLI(['component', 'corrupted', 'Test']);
      
      expect(result.exitCode).toBe(1);
    });
  });

  describe('Argument Validation Errors', () => { beforeEach(async () => {
      await fs.mkdir('_templates/validation', { recursive });
      await fs.writeFile(
        '_templates/validation/test.tsx.njk',
        '---\nto: {{name}}.tsx\nvariables:\n  - name: name\n    type: string\n    required: true\n  - name: type\n    type: string\n    choices: ["component", "page", "layout"]\n    required);
    });

    it('should validate required variables', async () => {
      const result = await runCLI(['validation', 'test', '--dry']);
      
      expect(result.exitCode).toBe(1);
      expect(result.stderr).toContain('required');
    });

    it('should validate variable choices/enums', async () => {
      const result = await runCLI(['validation', 'test', 'TestName', '--type', 'invalid-choice', '--dry']);
      
      expect(result.exitCode).toBe(1);
      expect(result.stderr).toContain('Error');
    });

    it('should validate variable types', async () => { await fs.writeFile(
        '_templates/validation/typed.tsx.njk',
        '---\nto }}.tsx\nvariables:\n  - name: count\n    type: number\n    required: true\n---\nCount);

      const result = await runCLI(['validation', 'typed', 'Test', '--count', 'not-a-number', '--dry']);
      
      expect(result.exitCode).toBe(1);
      expect(result.stderr).toContain('Error');
    });

    it('should handle missing positional parameters', async () => {
      const result = await runCLI(['validation', 'test']);
      
      // Should either prompt interactively or show validation error
      expect(result.exitCode).toBe(1);
    });
  });

  describe('Network and External Dependency Errors', () => { it('should handle network timeouts gracefully', async () => {
      // Test with a template that might try to fetch external resources
      await fs.mkdir('_templates/network', { recursive });
      await fs.writeFile(
        '_templates/network/test.tsx.njk',
        '---\nto);

      // Mock network failure scenario
      const result = await runCLI(['network', 'test', 'TestComponent'], 'timeout');
      
      // Should complete successfully for local templates
      expect(result.exitCode).toBe(0);
    });

    it('should handle missing external dependencies', async () => {
      // This would test scenarios where templates depend on external tools
      const result = await runCLI(['--version']);
      
      expect(result.exitCode).toBe(0);
    });
  });

  describe('Memory and Resource Limits', () => { it('should handle extremely large template files', async () => {
      await fs.mkdir('_templates/large', { recursive });
      
      // Create a large template (1MB of repeated content)
      const largeContent = 'x'.repeat(1024 * 1024);
      await fs.writeFile(
        '_templates/large/huge.txt.njk',
        `---\nto);

      const result = await runCLI(['large', 'huge', 'Test', '--dry']);
      
      // Should handle large files gracefully
      expect(result.exitCode).toBe(0);
    });

    it('should handle deep directory nesting', async () => { const deepPath = 'a/'.repeat(100); // Very deep nesting
      await fs.mkdir('_templates/deep', { recursive });
      await fs.writeFile(
        '_templates/deep/nested.txt.njk',
        `---\nto);

      const result = await runCLI(['deep', 'nested', 'Test', '--dry']);
      
      // Should handle or gracefully fail with deep paths
      expect([0, 1]).toContain(result.exitCode);
    });
  });

  describe('Concurrent Access Errors', () => { it('should handle file locks and concurrent access', async () => {
      await fs.mkdir('_templates/concurrent', { recursive });
      await fs.writeFile(
        '_templates/concurrent/test.txt.njk',
        '---\nto);

      // Run multiple generators simultaneously
      const promises = [
        runCLI(['concurrent', 'test', 'Test1']),
        runCLI(['concurrent', 'test', 'Test2']),
        runCLI(['concurrent', 'test', 'Test3'])
      ];

      const results = await Promise.all(promises);
      
      // At least some should succeed
      const successCount = results.filter(r => r.exitCode === 0).length;
      expect(successCount).toBeGreaterThan(0);
    });
  });

  describe('Configuration Errors', () => {
    it('should handle invalid configuration files', async () => {
      await fs.writeFile('unjucks.config.js', 'invalid javascript syntax {');
      
      const result = await runCLI(['list']);
      
      // Should either use defaults or show configuration error
      expect([0, 1]).toContain(result.exitCode);
    });

    it('should handle missing configuration dependencies', async () => {
      await fs.writeFile(
        'unjucks.config.js',
        'module.exports = { templateEngine);
      
      const result = await runCLI(['list']);
      
      expect([0, 1]).toContain(result.exitCode);
    });
  });

  describe('Recovery and Cleanup', () => { it('should clean up temporary files on error', async () => {
      await fs.mkdir('_templates/cleanup', { recursive });
      await fs.writeFile(
        '_templates/cleanup/failing.txt.njk',
        '---\nto)}}'
      );

      const result = await runCLI(['cleanup', 'failing', 'Test']);
      
      expect(result.exitCode).toBe(1);
      
      // Check that no temporary files are left behind
      const files = await fs.readdir('.');
      const tempFiles = files.filter(f => f.startsWith('.tmp') || f.startsWith('temp'));
      expect(tempFiles).toHaveLength(0);
    });

    it('should preserve existing files on generation failure', async () => { await fs.mkdir('_templates/preserve', { recursive });
      await fs.writeFile(
        '_templates/preserve/test.txt.njk',
        '---\nto);
      
      // Create existing file
      await fs.writeFile('existing.txt', 'Original content');
      const originalContent = await fs.readFile('existing.txt', 'utf-8');
      
      // Try to overwrite without force (should fail)
      const result = await runCLI(['preserve', 'test', 'Test']);
      
      // Original file should be preserved
      const finalContent = await fs.readFile('existing.txt', 'utf-8');
      expect(finalContent).toBe(originalContent);
    });
  });

  describe('Error Message Quality', () => {
    it('should provide helpful error messages with context', async () => {
      const result = await runCLI(['nonexistent-gen', 'test', 'Name']);
      
      expect(result.exitCode).toBe(1);
      expect(result.stderr).toContain('Error');
      // Error should be descriptive enough to understand the issue
      expect(result.stderr.length).toBeGreaterThan(10);
    });

    it('should provide suggestions for common mistakes', async () => { await fs.mkdir('_templates/component', { recursive });
      await fs.writeFile('_templates/component/new.tsx.njk', '---\nto);
      
      const result = await runCLI(['componnet', 'new', 'Test']); // Typo
      
      expect(result.exitCode).toBe(1);
      expect(result.stderr).toContain('Error');
    });

    it('should include stack traces in debug mode', async () => {
      const result = await runCLI(['nonexistent', 'test', 'Name']);
      
      expect(result.exitCode).toBe(1);
      // In debug mode, should include more detailed error information
    });
  });
});

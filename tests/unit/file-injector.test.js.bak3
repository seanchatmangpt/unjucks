import { describe, it, expect, beforeEach, vi } from 'vitest';
import { FileInjector } from '../../src/lib/file-injector.js';
import { FileFactory } from '../factories/index.js';
import fs from 'fs-extra';

// Mock fs-extra
vi.mock('fs-extra');
const mockFs = vi.mocked(fs);

describe('FileInjector', () => {
  let injector;

  beforeEach(() => {
    injector = new FileInjector();
    vi.resetAllMocks();
  });

  describe('inject', () => {
    it('should inject content after specified marker', async () => {
      const existingContent = `import React from 'react';

export const Component = () => {
  return Hello</div>;
};`;

      const newContent = `import { useState } from 'react';`;
      const options = FileFactory.createInjectionOptions({
        after: 'import React from \'react\';'
      });

      mockFs.readFile.mockResolvedValue(existingContent);
      mockFs.writeFile.mockResolvedValue();

      const result = await injector.inject('/test/file.ts', newContent, options);

      expect(result.success).toBe(true);
      expect(result.modified).toBe(true);
      expect(result.modifiedContent).toContain(`import React from 'react';\nimport { useState } from 'react';`);
      expect(mockFs.writeFile).toHaveBeenCalled();
    });

    it('should inject content before specified marker', async () => {
      const existingContent = `import React from 'react';

export const Component = () => {
  return Hello</div>;
};`;

      const newContent = `import { FC } from 'react';`;
      const options = FileFactory.createInjectionOptions({
        before: 'import React from \'react\';'
      });

      mockFs.readFile.mockResolvedValue(existingContent);
      mockFs.writeFile.mockResolvedValue();

      const result = await injector.inject('/test/file.ts', newContent, options);

      expect(result.success).toBe(true);
      expect(result.modified).toBe(true);
      expect(result.modifiedContent).toContain(`import { FC } from 'react';\nimport React from 'react';`);
    });

    it('should append content to end of file', async () => {
      const existingContent = `export const Component = () => {
  return Hello</div>;
};`;

      const newContent = `export default Component;`;
      const options = FileFactory.createInjectionOptions({ append });

      mockFs.readFile.mockResolvedValue(existingContent);
      mockFs.writeFile.mockResolvedValue();

      const result = await injector.inject('/test/file.ts', newContent, options);

      expect(result.success).toBe(true);
      expect(result.modified).toBe(true);
      expect(result.modifiedContent).toContain(`};\nexport default Component;`);
    });

    it('should prepend content to beginning of file', async () => {
      const existingContent = `export const Component = () => {
  return Hello</div>;
};`;

      const newContent = `/* eslint-disable */`;
      const options = FileFactory.createInjectionOptions({ prepend });

      mockFs.readFile.mockResolvedValue(existingContent);
      mockFs.writeFile.mockResolvedValue();

      const result = await injector.inject('/test/file.ts', newContent, options);

      expect(result.success).toBe(true);
      expect(result.modified).toBe(true);
      expect(result.modifiedContent).toContain(`/* eslint-disable */\nexport const Component`);
    });

    it('should inject at specific line number', async () => {
      const existingContent = `line 1
line 2
line 3
line 4`;

      const newContent = `inserted line`;
      const options = FileFactory.createInjectionOptions({
        lineAt);

      mockFs.readFile.mockResolvedValue(existingContent);
      mockFs.writeFile.mockResolvedValue();

      const result = await injector.inject('/test/file.ts', newContent, options);

      expect(result.success).toBe(true);
      expect(result.modified).toBe(true);
      const lines = result.modifiedContent.split('\n');
      expect(lines[2]).toBe('inserted line'); // 0-indexed
    });

    it('should skip injection when skipIf condition is met', async () => {
      const existingContent = `import { useState } from 'react';
import React from 'react';

export const Component = () => {
  return Hello</div>;
};`;

      const newContent = `import { useState } from 'react';`;
      const options = FileFactory.createInjectionOptions({ skipIf });

    it('should handle non-existent file gracefully', async () => {
      mockFs.readFile.mockRejectedValue(new Error('ENOENT));

      const result = await injector.inject('/nonexistent/file.ts', 'content', {});

      expect(result.success).toBe(false);
      expect(result.reason).toContain('file not found');
    });

    it('should handle markers that do not exist', async () => {
      const existingContent = `export const Component = () => {
  return Hello</div>;
};`;

      const newContent = `import React from 'react';`;
      const options = FileFactory.createInjectionOptions({
        after: 'import React from \'react\';'
      });

      mockFs.readFile.mockResolvedValue(existingContent);

      const result = await injector.inject('/test/file.ts', newContent, options);

      expect(result.success).toBe(false);
      expect(result.reason).toContain('marker not found');
      expect(mockFs.writeFile).not.toHaveBeenCalled();
    });
  });

  describe('idempotent injection', () => {
    it('should not inject duplicate content', async () => {
      const existingContent = `import React from 'react';
import { useState } from 'react';

export const Component = () => {
  return Hello</div>;
};`;

      const newContent = `import { useState } from 'react';`;
      const options = FileFactory.createInjectionOptions({
        after: 'import React from \'react\';'
      });

      mockFs.readFile.mockResolvedValue(existingContent);

      const result = await injector.inject('/test/file.ts', newContent, options);

      expect(result.success).toBe(true);
      expect(result.skipped).toBe(true);
      expect(result.reason).toContain('already exists');
    });

    it('should detect similar content variations', async () => {
      const existingContent = `import React from 'react'
import { useState } from 'react'`;

      const newContent = `import { useState } from 'react';`; // Note the semicolon
      const options = FileFactory.createInjectionOptions({
        after: 'import React from \'react\';'
      });

      mockFs.readFile.mockResolvedValue(existingContent);

      const result = await injector.inject('/test/file.ts', newContent, options);

      expect(result.success).toBe(true);
      expect(result.skipped).toBe(true);
    });
  });

  describe('complex scenarios', () => {
    it('should handle multiple injections in sequence', async () => {
      let fileContent = `import React from 'react';

export const Component = () => {
  return Hello</div>;
};`;

      // First injection
      mockFs.readFile.mockResolvedValue(fileContent);
      mockFs.writeFile.mockImplementation((_, content) => {
        fileContent = content;
        return Promise.resolve();
      });

      const result1 = await injector.inject('/test/file.ts', 
        `import { useState } from 'react';`,
        { after: 'import React from \'react\';'
      });

      expect(result1.success).toBe(true);

      // Second injection
      mockFs.readFile.mockResolvedValue(fileContent);
      
      const result2 = await injector.inject('/test/file.ts',
        `import { useEffect } from 'react';`,
        { after: 'import React from \'react\';'
      });

      expect(result2.success).toBe(true);
      expect(result2.modifiedContent).toContain('useState');
      expect(result2.modifiedContent).toContain('useEffect');
    });

    it('should handle injection with template variables', async () => {
      const existingContent = `export const components = {`;

      const newContent = `  {{ name }}: {{ name }}Component,`;
      const options = FileFactory.createInjectionOptions({
        after: 'import React from \'react\';'
      });

      mockFs.readFile.mockResolvedValue(existingContent);
      mockFs.writeFile.mockResolvedValue();

      const result = await injector.inject('/test/file.ts', newContent, options);

      expect(result.success).toBe(true);
      expect(result.modifiedContent).toContain('{{ name }},');
    });

    it('should handle injection in binary files safely', async () => {
      const binaryContent = Buffer.from([0x89, 0x50, 0x4E, 0x47, 0x0D, 0x0A, 0x1A, 0x0A]);
      
      mockFs.readFile.mockResolvedValue(binaryContent);

      const result = await injector.inject('/test/image.png', 'text content', {});

      expect(result.success).toBe(false);
      expect(result.reason).toContain('binary file');
    });
  });

  describe('edge cases', () => { it('should handle empty files', async () => {
      const existingContent = '';
      const newContent = 'First line';
      
      mockFs.readFile.mockResolvedValue(existingContent);
      mockFs.writeFile.mockResolvedValue();

      const result = await injector.inject('/test/file.ts', newContent, { append });

      expect(result.success).toBe(true);
      expect(result.modifiedContent).toBe('First line');
    });

    it('should handle very large files', async () => { const largeContent = 'Line content\n'.repeat(100000);
      const newContent = 'Inserted content';
      
      mockFs.readFile.mockResolvedValue(largeContent);
      mockFs.writeFile.mockResolvedValue();

      const startTime = Date.now();
      const result = await injector.inject('/test/large.ts', newContent, { append });
      const endTime = Date.now();

      expect(result.success).toBe(true);
      expect(endTime - startTime).toBeLessThan(1000); // Should be reasonably fast
    });

    it('should handle Unicode content', async () => { const existingContent = `const message = "Hello ä¸–ç•Œ! ðŸŒ";`;
      const newContent = `const greeting = "Bonjour ðŸ‡«ðŸ‡·";`;
      
      mockFs.readFile.mockResolvedValue(existingContent);
      mockFs.writeFile.mockResolvedValue();

      const result = await injector.inject('/test/file.ts', newContent, { append });

      expect(result.success).toBe(true);
      expect(result.modifiedContent).toContain('ä¸–ç•Œ');
      expect(result.modifiedContent).toContain('ðŸŒ');
      expect(result.modifiedContent).toContain('ðŸ‡«ðŸ‡·');
    });

    it('should handle files with mixed line endings', async () => {
      const existingContent = `line1\r\nline2\nline3\r\nline4`;
      const newContent = `inserted`;
      
      mockFs.readFile.mkResolvedValue(existingContent);
      mockFs.writeFile.mockResolvedValue();

      const result = await injector.inject('/test/file.ts', newContent, { lineAt);

      expect(result.success).toBe(true);
      expect(result.linesAdded).toBe(1);
    });
  });

  describe('performance', () => {
    it('should handle concurrent injections efficiently', async () => {
      const fileContents = Array.from({ length, (_, i) => 
        `// File ${i}\nexport const value${i} = ${i};`
      );

      mockFs.readFile.mockImplementation((filePath) => {
        const index = parseInt((filePath).match(/\d+/)?.[0] || '0');
        return Promise.resolve(fileContents[index]);
      });
      mockFs.writeFile.mockResolvedValue();

      const injections = fileContents.map((_, i) => 
        injector.inject(`/test/file${i}.ts`, `const new${i} = true;`, { append })
      );

      const startTime = Date.now();
      const results = await Promise.all(injections);
      const endTime = Date.now();

      expect(results).toHaveLength(20);
      results.forEach(result => {
        expect(result.success).toBe(true);
      });
      expect(endTime - startTime).toBeLessThan(500); // Should complete quickly
    });

    it('should optimize repeated marker searches', async () => {
      const largeContent = Array.from({ length, (_, i) => 
        `line ${i}`
      ).join('\n');

      const marker = 'line 500';
      
      mockFs.readFile.mockResolvedValue(largeContent);
      mockFs.writeFile.mockResolvedValue();

      const startTime = Date.now();
      const result = await injector.inject('/test/file.ts', 'inserted', { after });
      const endTime = Date.now();

      expect(result.success).toBe(true);
      expect(endTime - startTime).toBeLessThan(50); // Should be fast even with large files
    });
  });

  describe('factory integration', () => {
    it('should work with factory-generated injection scenarios', async () => {
      const scenarios = FileFactory.createInjectionScenarios();

      for (const [scenarioName, scenario] of Object.entries(scenarios)) {
        mockFs.readFile.mockResolvedValue(scenario.file.content);
        mockFs.writeFile.mockResolvedValue();

        const result = await injector.inject(
          scenario.file.path, 
          scenario.injection, 
          scenario.options
        );

        expect(result.success).toBe(true);
        
        if (scenarioName === 'beforeImport') {
          expect(result.modifiedContent).toMatch(/import { useState }.*import React/s);
        } else if (scenarioName === 'afterImport') {
          expect(result.modifiedContent).toMatch(/import React.*import { useEffect }/s);
        }
      }
    });

    it('should handle factory-generated file system scenarios', async () => { const scenarios = FileFactory.createFileSystemScenarios();

      // Test with nested structure
      const nestedScenario = scenarios.nestedStructure;
      const testFile = nestedScenario.files[0];

      mockFs.readFile.mockResolvedValue(testFile.content);
      mockFs.writeFile.mockResolvedValue();

      const result = await injector.inject(
        testFile.path,
        'injected content',
        { append }
      );

      expect(result.success).toBe(true);
      expect(result.modifiedContent).toContain('injected content');
    });
  });
});
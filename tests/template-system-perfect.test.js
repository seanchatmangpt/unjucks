/**
 * Comprehensive Template System Tests - Perfect Template Engine
 * Tests all aspects of the template system for 100% reliability
 */

import { describe, it, expect, beforeEach, afterEach } from 'vitest';
import { PerfectTemplateEngine, renderTemplate, validateTemplate, extractTemplateVariables } from '../src/lib/template-engine-perfect.js';
import { PerfectTemplateScanner, scanTemplates } from '../src/lib/template-scanner-perfect.js';
import fs from 'fs-extra';
import path from 'node:path';
import { fileURLToPath } from 'node:url';

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Test directories
const testDir = path.join(__dirname, 'fixtures/template-perfect');
const templatesDir = path.join(testDir, '_templates');

describe('Perfect Template Engine', () => {
  let engine;
  
  beforeEach(async () => {
    // Create test directory structure
    await fs.ensureDir(templatesDir);
    
    engine = new PerfectTemplateEngine({
      templatesDir,
      enableCaching: true
    });
  });
  
  afterEach(async () => {
    // Clean up test files
    await fs.remove(testDir);
  });

  describe('Template Engine Initialization', () => {
    it('should initialize with default configuration', () => {
      const defaultEngine = new PerfectTemplateEngine();
      expect(defaultEngine.config.templatesDir).toBe('_templates');
      expect(defaultEngine.config.autoescape).toBe(false);
      expect(defaultEngine.config.enableCaching).toBe(true);
    });

    it('should initialize with custom configuration', () => {
      const customEngine = new PerfectTemplateEngine({
        templatesDir: '/custom/templates',
        autoescape: true,
        enableCaching: false
      });
      
      expect(customEngine.config.templatesDir).toBe('/custom/templates');
      expect(customEngine.config.autoescape).toBe(true);
      expect(customEngine.config.enableCaching).toBe(false);
    });

    it('should register all custom filters', () => {
      expect(engine.nunjucksEnv.getFilter('exists')).toBeDefined();
      expect(engine.nunjucksEnv.getFilter('isEmpty')).toBeDefined();
      expect(engine.nunjucksEnv.getFilter('quote')).toBeDefined();
      expect(engine.nunjucksEnv.getFilter('safe')).toBeDefined();
      expect(engine.nunjucksEnv.getFilter('indent')).toBeDefined();
    });
  });

  describe('Template Content Fixing', () => {
    it('should fix unclosed template expressions', async () => {
      const malformedTemplate = `\n---\nto: output.js\n---\n{{ name\ncontent here`;\n      \n      const templatePath = path.join(templatesDir, 'malformed.njk');\n      await fs.writeFile(templatePath, malformedTemplate);\n      \n      const fixedContent = engine.fixTemplateContent(malformedTemplate, templatePath);\n      expect(fixedContent).toContain('{{ name }}');\n    });\n\n    it('should fix unclosed control structures', async () => {\n      const malformedTemplate = `\n---\nto: output.js\n---\n{% if condition %}\n  content\n// Missing endif`;\n      \n      const templatePath = path.join(templatesDir, 'unclosed-if.njk');\n      await fs.writeFile(templatePath, malformedTemplate);\n      \n      const fixedContent = engine.fixTemplateContent(malformedTemplate, templatePath);\n      expect(fixedContent).toContain('{% endif %}');\n    });\n\n    it('should fix malformed frontmatter', async () => {\n      const malformedTemplate = `\n---\nto: output.js\nvariables:\n  name:\n    type: string\n    description: Missing quotes here\n---\nContent`;\n      \n      const templatePath = path.join(templatesDir, 'bad-frontmatter.njk');\n      await fs.writeFile(templatePath, malformedTemplate);\n      \n      const fixedContent = engine.fixTemplateContent(malformedTemplate, templatePath);\n      expect(fixedContent).toContain('\"Missing quotes here\"');\n    });\n\n    it('should handle nested quotes in frontmatter', async () => {\n      const malformedTemplate = `\n---\nto: output.js\nvariables:\n  description: \"A \"quoted\" value\"\n---\nContent`;\n      \n      const templatePath = path.join(templatesDir, 'nested-quotes.njk');\n      await fs.writeFile(templatePath, malformedTemplate);\n      \n      const fixedContent = engine.fixTemplateContent(malformedTemplate, templatePath);\n      // Should fix nested quotes\n      expect(fixedContent).toMatch(/description:\\s*['\"]/); \n    });\n  });\n\n  describe('Template Rendering', () => {\n    it('should render a simple Nunjucks template', async () => {\n      const template = `\n---\nto: {{ name }}.js\n---\nexport const {{ name | camelCase }} = {\n  name: '{{ name }}'\n};`;\n      \n      const templatePath = path.join(templatesDir, 'simple.njk');\n      await fs.writeFile(templatePath, template);\n      \n      const result = await engine.renderTemplate(templatePath, { name: 'TestComponent' });\n      \n      expect(result.success).toBe(true);\n      expect(result.content).toContain('export const testComponent = {');\n      expect(result.content).toContain(\"name: 'TestComponent'\");\n      expect(result.templateType).toBe('nunjucks');\n    });\n\n    it('should render an EJS template', async () => {\n      const template = `\n---\nto: <%= name %>.js\n---\nexport const <%= name.charAt(0).toLowerCase() + name.slice(1) %> = {\n  name: '<%= name %>'\n};`;\n      \n      const templatePath = path.join(templatesDir, 'simple.ejs');\n      await fs.writeFile(templatePath, template);\n      \n      const result = await engine.renderTemplate(templatePath, { name: 'TestComponent' });\n      \n      expect(result.success).toBe(true);\n      expect(result.content).toContain('export const testComponent = {');\n      expect(result.content).toContain(\"name: 'TestComponent'\");\n      expect(result.templateType).toBe('ejs');\n    });\n\n    it('should handle template with all common filters', async () => {\n      const template = `\n---\nto: {{ name | kebabCase }}.js\n---\nconst {{ name | camelCase }} = {\n  className: '{{ name | pascalCase }}',\n  fileName: '{{ name | snakeCase }}',\n  constant: '{{ name | constantCase }}',\n  title: '{{ name | titleCase }}',\n  human: '{{ name | humanize }}',\n  plural: '{{ name | pluralize }}',\n  singular: '{{ name | singular }}',\n  slug: '{{ name | slug }}',\n  uuid: '{{ uuid() }}',\n  timestamp: '{{ timestamp() }}'\n};`;\n      \n      const templatePath = path.join(templatesDir, 'filters.njk');\n      await fs.writeFile(templatePath, template);\n      \n      const result = await engine.renderTemplate(templatePath, { name: 'user_posts' });\n      \n      expect(result.success).toBe(true);\n      expect(result.content).toContain('const userPosts = {');\n      expect(result.content).toContain(\"className: 'UserPosts'\");\n      expect(result.content).toContain(\"fileName: 'user_posts'\");\n      expect(result.content).toContain(\"constant: 'USER_POSTS'\");\n      expect(result.content).toContain(\"plural: 'user_postss'\"); // Simple pluralization\n      expect(result.content).toContain('uuid:');\n    });\n\n    it('should handle template with date filters', async () => {\n      const template = `\n---\nto: timestamp.js\n---\nconst dates = {\n  now: '{{ now() | dateFormat }}',\n  formatted: '{{ now() | dateFormat(\"YYYY-MM-DD HH:mm:ss\") }}',\n  relative: '{{ now() | dateAdd(1, \"day\") | fromNow }}',\n  iso: '{{ now() | iso }}'\n};`;\n      \n      const templatePath = path.join(templatesDir, 'dates.njk');\n      await fs.writeFile(templatePath, template);\n      \n      const result = await engine.renderTemplate(templatePath, {});\n      \n      expect(result.success).toBe(true);\n      expect(result.content).toContain('const dates = {');\n      expect(result.content).toMatch(/now: '\\d{4}-\\d{2}-\\d{2}'/);\n    });\n\n    it('should handle template with faker filters', async () => {\n      const template = `\n---\nto: fake-data.js\n---\nconst fakeData = {\n  name: '{{ fakeName() }}',\n  email: '{{ fakeEmail() }}',\n  address: '{{ fakeAddress() }}',\n  company: '{{ fakeCompany() }}',\n  uuid: '{{ fakeUuid() }}',\n  number: {{ fakeNumber(1, 100) }},\n  boolean: {{ fakeBoolean() }}\n};`;\n      \n      const templatePath = path.join(templatesDir, 'faker.njk');\n      await fs.writeFile(templatePath, template);\n      \n      const result = await engine.renderTemplate(templatePath, {});\n      \n      expect(result.success).toBe(true);\n      expect(result.content).toContain('const fakeData = {');\n      expect(result.content).toContain('name:');\n      expect(result.content).toContain('@'); // Should contain email\n    });\n\n    it('should recover from template errors', async () => {\n      const template = `\n---\nto: error-recovery.js\n---\nexport const data = {\n  value: '{{ undefinedVariable }}',\n  safe: '{{ undefinedVariable or \"default\" }}'\n};`;\n      \n      const templatePath = path.join(templatesDir, 'error-recovery.njk');\n      await fs.writeFile(templatePath, template);\n      \n      const result = await engine.renderTemplate(templatePath, {});\n      \n      // Should succeed with error recovery\n      expect(result.success).toBe(true);\n    });\n  });\n\n  describe('Template Validation', () => {\n    it('should validate a correct template', async () => {\n      const template = `\n---\nto: {{ name }}.js\n---\nexport const {{ name | camelCase }} = {\n  name: '{{ name }}'\n};`;\n      \n      const templatePath = path.join(templatesDir, 'valid.njk');\n      await fs.writeFile(templatePath, template);\n      \n      const result = await engine.validateTemplate(templatePath);\n      \n      expect(result.valid).toBe(true);\n      expect(result.templateType).toBe('nunjucks');\n      expect(result.issues).toEqual([]);\n    });\n\n    it('should detect syntax errors in template', async () => {\n      const template = `\n---\nto: output.js\n---\n{% if condition %}\n  content without endif\n{{ unclosed expression`;\n      \n      const templatePath = path.join(templatesDir, 'invalid.njk');\n      await fs.writeFile(templatePath, template);\n      \n      const result = await engine.validateTemplate(templatePath);\n      \n      expect(result.valid).toBe(false);\n      expect(result.error).toBeDefined();\n      expect(result.issues).toHaveLength(1);\n    });\n  });\n\n  describe('Variable Extraction', () => {\n    it('should extract all variables from template', async () => {\n      const template = `\n---\nto: {{ outputPath }}/{{ name | kebabCase }}.{{ extension }}\nvariables:\n  name:\n    type: string\n    required: true\n  description:\n    type: string\n    default: \"No description\"\n---\nexport const {{ name | camelCase }} = {\n  name: '{{ name }}',\n  description: '{{ description }}',\n  type: '{{ componentType }}',\n  props: [\n    {% for prop in properties %}\n    '{{ prop.name }}'\n    {% endfor %}\n  ]\n};`;\n      \n      const templatePath = path.join(templatesDir, 'variables.njk');\n      await fs.writeFile(templatePath, template);\n      \n      const result = await engine.extractVariables(templatePath);\n      \n      expect(result.variables).toContain('name');\n      expect(result.variables).toContain('description');\n      expect(result.variables).toContain('componentType');\n      expect(result.variables).toContain('properties');\n      expect(result.variables).toContain('outputPath');\n      expect(result.variables).toContain('extension');\n      \n      expect(result.required).toContain('name');\n      expect(result.required).not.toContain('description'); // Has default\n      \n      expect(result.frontmatterVariables).toHaveProperty('name');\n      expect(result.frontmatterVariables).toHaveProperty('description');\n    });\n  });\n\n  describe('Caching', () => {\n    it('should cache template content', async () => {\n      const template = `{{ name }}`;\n      const templatePath = path.join(templatesDir, 'cached.njk');\n      await fs.writeFile(templatePath, template);\n      \n      // First read\n      const content1 = await engine.getTemplateContent(templatePath);\n      expect(content1).toBe(template);\n      \n      // Second read should be cached\n      const content2 = await engine.getTemplateContent(templatePath);\n      expect(content2).toBe(template);\n      \n      const stats = engine.getCacheStats();\n      expect(stats.templateCache).toBeGreaterThan(0);\n    });\n\n    it('should manage cache size', async () => {\n      const smallEngine = new PerfectTemplateEngine({\n        templatesDir,\n        maxCacheSize: 2\n      });\n      \n      // Create more templates than cache size\n      for (let i = 0; i < 5; i++) {\n        const templatePath = path.join(templatesDir, `cache-${i}.njk`);\n        await fs.writeFile(templatePath, `Template ${i}`);\n        await smallEngine.getTemplateContent(templatePath);\n      }\n      \n      const stats = smallEngine.getCacheStats();\n      expect(stats.templateCache).toBeLessThanOrEqual(2);\n    });\n\n    it('should clear cache', async () => {\n      const template = `{{ name }}`;\n      const templatePath = path.join(templatesDir, 'clear-cache.njk');\n      await fs.writeFile(templatePath, template);\n      \n      await engine.getTemplateContent(templatePath);\n      \n      let stats = engine.getCacheStats();\n      expect(stats.templateCache).toBeGreaterThan(0);\n      \n      engine.clearCache();\n      \n      stats = engine.getCacheStats();\n      expect(stats.templateCache).toBe(0);\n    });\n  });\n\n  describe('Convenience Functions', () => {\n    it('should render template with convenience function', async () => {\n      const template = `{{ name | pascalCase }}`;\n      const templatePath = path.join(templatesDir, 'convenience.njk');\n      await fs.writeFile(templatePath, template);\n      \n      const result = await renderTemplate(templatePath, { name: 'test_component' });\n      \n      expect(result.success).toBe(true);\n      expect(result.content.trim()).toBe('TestComponent');\n    });\n\n    it('should validate template with convenience function', async () => {\n      const template = `{{ name }}`;\n      const templatePath = path.join(templatesDir, 'convenience-validate.njk');\n      await fs.writeFile(templatePath, template);\n      \n      const result = await validateTemplate(templatePath);\n      \n      expect(result.valid).toBe(true);\n    });\n\n    it('should extract variables with convenience function', async () => {\n      const template = `{{ name }} and {{ description }}`;\n      const templatePath = path.join(templatesDir, 'convenience-extract.njk');\n      await fs.writeFile(templatePath, template);\n      \n      const result = await extractTemplateVariables(templatePath);\n      \n      expect(result.variables).toContain('name');\n      expect(result.variables).toContain('description');\n    });\n  });\n});\n\ndescribe('Perfect Template Scanner', () => {\n  let scannerDir;\n  \n  beforeEach(async () => {\n    scannerDir = path.join(__dirname, 'fixtures/scanner-test');\n    await fs.ensureDir(scannerDir);\n  });\n  \n  afterEach(async () => {\n    await fs.remove(scannerDir);\n  });\n\n  describe('Template Discovery', () => {\n    it('should discover all template files', async () => {\n      // Create test templates\n      await fs.writeFile(path.join(scannerDir, 'template1.njk'), '{{ name }}');\n      await fs.writeFile(path.join(scannerDir, 'template2.ejs'), '<%= name %>');\n      await fs.writeFile(path.join(scannerDir, 'template3.hbs'), '{{name}}');\n      await fs.writeFile(path.join(scannerDir, 'readme.md'), '# Not a template');\n      \n      const scanner = new PerfectTemplateScanner({\n        rootDir: scannerDir,\n        excludePatterns: []\n      });\n      \n      const templateFiles = await scanner.discoverTemplateFiles();\n      \n      expect(templateFiles).toHaveLength(3);\n      expect(templateFiles.some(f => f.includes('template1.njk'))).toBe(true);\n      expect(templateFiles.some(f => f.includes('template2.ejs'))).toBe(true);\n      expect(templateFiles.some(f => f.includes('template3.hbs'))).toBe(true);\n      expect(templateFiles.some(f => f.includes('readme.md'))).toBe(false);\n    });\n\n    it('should respect exclude patterns', async () => {\n      await fs.ensureDir(path.join(scannerDir, 'node_modules'));\n      await fs.writeFile(path.join(scannerDir, 'template.njk'), '{{ name }}');\n      await fs.writeFile(path.join(scannerDir, 'node_modules', 'ignored.njk'), '{{ ignored }}');\n      \n      const scanner = new PerfectTemplateScanner({\n        rootDir: scannerDir\n      });\n      \n      const templateFiles = await scanner.discoverTemplateFiles();\n      \n      expect(templateFiles).toHaveLength(1);\n      expect(templateFiles[0]).toContain('template.njk');\n    });\n  });\n\n  describe('File Scanning', () => {\n    it('should scan a valid template file', async () => {\n      const validTemplate = `\n---\nto: {{ name }}.js\nvariables:\n  name:\n    type: string\n    required: true\n---\nexport const {{ name | camelCase }} = {\n  name: '{{ name }}'\n};`;\n      \n      await fs.writeFile(path.join(scannerDir, 'valid.njk'), validTemplate);\n      \n      const scanner = new PerfectTemplateScanner({ rootDir: scannerDir });\n      const result = await scanner.scanSingleFile(path.join(scannerDir, 'valid.njk'));\n      \n      expect(result.valid).toBe(true);\n      expect(result.type).toBe('nunjucks');\n      expect(result.hasValidFrontmatter).toBe(true);\n      expect(result.variables).toContain('name');\n      expect(result.issues).toHaveLength(0);\n    });\n\n    it('should scan an invalid template file and provide fixes', async () => {\n      const invalidTemplate = `\n---\nto: output.js\n---\n{% if condition %}\n  content\n{{ unclosed`;\n      \n      await fs.writeFile(path.join(scannerDir, 'invalid.njk'), invalidTemplate);\n      \n      const scanner = new PerfectTemplateScanner({ \n        rootDir: scannerDir,\n        enableFix: true \n      });\n      const result = await scanner.scanSingleFile(path.join(scannerDir, 'invalid.njk'));\n      \n      expect(result.valid).toBe(false);\n      expect(result.issues.length).toBeGreaterThan(0);\n      expect(result.fixed).toBe(true); // Should attempt to fix\n      expect(result.fixedContent).toBeDefined();\n    });\n\n    it('should detect common template issues', async () => {\n      const problematicTemplate = `\n---\nto: output.js\n---\n{% if condition %}\n  {% if nested %}\n    {% if deep %}\n      {% if deeper %}\n        {% if deepest %}\n          Content\n        {% endif %}\n      {% endif %}\n    {% endif %}\n  {% endif %}\n{% endif %}\n{{ name | unknownFilter }}`;\n      \n      await fs.writeFile(path.join(scannerDir, 'problematic.njk'), problematicTemplate);\n      \n      const scanner = new PerfectTemplateScanner({ rootDir: scannerDir });\n      const result = await scanner.scanSingleFile(path.join(scannerDir, 'problematic.njk'));\n      \n      const issueTypes = result.issues.map(i => i.type);\n      expect(issueTypes).toContain('deep_nesting');\n      expect(issueTypes).toContain('unknown_filter');\n    });\n  });\n\n  describe('Full Project Scan', () => {\n    it('should scan all templates in project', async () => {\n      // Create various templates\n      await fs.writeFile(path.join(scannerDir, 'valid1.njk'), '{{ name }}');\n      await fs.writeFile(path.join(scannerDir, 'valid2.ejs'), '<%= name %>');\n      await fs.writeFile(path.join(scannerDir, 'invalid.njk'), '{{ unclosed');\n      \n      const results = await scanTemplates({\n        rootDir: scannerDir,\n        enableFix: true\n      });\n      \n      expect(results.totalFiles).toBe(3);\n      expect(results.validFiles).toBeGreaterThanOrEqual(2);\n      expect(results.invalidFiles).toBeGreaterThanOrEqual(0);\n      expect(results.files).toHaveLength(3);\n      expect(results.statistics).toBeDefined();\n    });\n\n    it('should generate comprehensive statistics', async () => {\n      await fs.ensureDir(path.join(scannerDir, 'components'));\n      await fs.ensureDir(path.join(scannerDir, 'pages'));\n      \n      await fs.writeFile(path.join(scannerDir, 'components', 'button.njk'), '{{ name }}');\n      await fs.writeFile(path.join(scannerDir, 'pages', 'home.ejs'), '<%= title %>');\n      await fs.writeFile(path.join(scannerDir, 'invalid.njk'), '{{ unclosed');\n      \n      const results = await scanTemplates({ rootDir: scannerDir });\n      \n      expect(results.statistics.byType).toHaveProperty('nunjucks');\n      expect(results.statistics.byType).toHaveProperty('ejs');\n      expect(results.statistics.byDirectory).toHaveProperty('components');\n      expect(results.statistics.byDirectory).toHaveProperty('pages');\n    });\n  });\n\n  describe('Report Generation', () => {\n    it('should generate detailed report', async () => {\n      await fs.writeFile(path.join(scannerDir, 'test.njk'), '{{ name }}');\n      \n      const scanner = new PerfectTemplateScanner({ rootDir: scannerDir });\n      const results = await scanner.scanAll();\n      \n      const reportPath = path.join(scannerDir, 'report.json');\n      const report = await scanner.generateReport(results, reportPath);\n      \n      expect(await fs.pathExists(reportPath)).toBe(true);\n      expect(report.metadata).toBeDefined();\n      expect(report.summary).toBeDefined();\n      expect(report.files).toBeDefined();\n      expect(report.recommendations).toBeDefined();\n      \n      const savedReport = await fs.readJson(reportPath);\n      expect(savedReport).toEqual(report);\n    });\n\n    it('should provide actionable recommendations', async () => {\n      // Create templates with various issues\n      await fs.writeFile(path.join(scannerDir, 'unclosed1.njk'), '{% if condition %}content');\n      await fs.writeFile(path.join(scannerDir, 'unclosed2.njk'), '{% if other %}content');\n      await fs.writeFile(path.join(scannerDir, 'filter.njk'), '{{ name | badFilter }}');\n      \n      const scanner = new PerfectTemplateScanner({ rootDir: scannerDir });\n      const results = await scanner.scanAll();\n      const recommendations = scanner.generateRecommendations(results);\n      \n      expect(recommendations.length).toBeGreaterThan(0);\n      expect(recommendations.some(r => r.type === 'high')).toBe(true);\n    });\n  });\n});\n\ndescribe('Integration Tests', () => {\n  let integrationDir;\n  \n  beforeEach(async () => {\n    integrationDir = path.join(__dirname, 'fixtures/integration-test');\n    await fs.ensureDir(integrationDir);\n  });\n  \n  afterEach(async () => {\n    await fs.remove(integrationDir);\n  });\n\n  it('should handle complex real-world templates', async () => {\n    const complexTemplate = `\n---\nto: src/components/{{ name | pascalCase }}/{{ name | pascalCase }}.tsx\nvariables:\n  name:\n    type: string\n    required: true\n    description: Component name\n  props:\n    type: array\n    default: []\n    description: Component properties\n  hasState:\n    type: boolean\n    default: false\n    description: Whether component has state\n  storybook:\n    type: boolean\n    default: true\n    description: Generate storybook story\n---\nimport React{% if hasState %}, { useState }{% endif %} from 'react';\n{% if storybook %}\nimport { Meta, Story } from '@storybook/react';\n{% endif %}\n\n{% if props.length > 0 %}\ninterface {{ name | pascalCase }}Props {\n{% for prop in props %}\n  {{ prop.name }}: {{ prop.type }}{% if prop.optional %}?{% endif %};\n{% endfor %}\n}\n{% endif %}\n\nconst {{ name | pascalCase }}: React.FC{% if props.length > 0 %}<{{ name | pascalCase }}Props>{% endif %} = ({\n{% for prop in props %}\n  {{ prop.name }}{% if not loop.last %},{% endif %}\n{% endfor %}\n}) => {\n{% if hasState %}\n  const [state, setState] = useState();\n{% endif %}\n\n  return (\n    <div className=\"{{ name | kebabCase }}\">\n      <h1>{{ name | titleCase }}</h1>\n      {% if props.length > 0 %}\n      <div className=\"props\">\n        {% for prop in props %}\n        <p>{{ prop.name }}: {{{ prop.name }}}</p>\n        {% endfor %}\n      </div>\n      {% endif %}\n    </div>\n  );\n};\n\n{% if storybook %}\nexport default {\n  title: 'Components/{{ name | pascalCase }}',\n  component: {{ name | pascalCase }},\n  argTypes: {\n{% for prop in props %}\n    {{ prop.name }}: {\n      control: '{{ prop.control or \"text\" }}',\n      description: '{{ prop.description or prop.name }}'\n    }{% if not loop.last %},{% endif %}\n{% endfor %}\n  }\n} as Meta;\n\nconst Template: Story{% if props.length > 0 %}<{{ name | pascalCase }}Props>{% endif %} = (args) => <{{ name | pascalCase }} {...args} />;\n\nexport const Default = Template.bind({});\nDefault.args = {\n{% for prop in props %}\n  {{ prop.name }}: {{ prop.defaultValue or \"'default'\" }}{% if not loop.last %},{% endif %}\n{% endfor %}\n};\n{% endif %}\n\nexport default {{ name | pascalCase }};`;\n    \n    const templatePath = path.join(integrationDir, 'react-component.njk');\n    await fs.writeFile(templatePath, complexTemplate);\n    \n    const engine = new PerfectTemplateEngine();\n    \n    const variables = {\n      name: 'user_profile',\n      props: [\n        { name: 'userId', type: 'string', optional: false, control: 'text', description: 'User ID' },\n        { name: 'theme', type: 'string', optional: true, control: 'select', defaultValue: '\"light\"' }\n      ],\n      hasState: true,\n      storybook: true\n    };\n    \n    const result = await engine.renderTemplate(templatePath, variables);\n    \n    expect(result.success).toBe(true);\n    expect(result.content).toContain('interface UserProfileProps');\n    expect(result.content).toContain('const UserProfile: React.FC<UserProfileProps>');\n    expect(result.content).toContain('import React, { useState }');\n    expect(result.content).toContain('className=\"user-profile\"');\n    expect(result.content).toContain('<h1>User Profile</h1>');\n    expect(result.content).toContain('export default {');\n    expect(result.content).toContain('const Template: Story<UserProfileProps>');\n  });\n\n  it('should handle templates with semantic web features', async () => {\n    const semanticTemplate = `\n---\nto: ontology/{{ name | kebabCase }}.ttl\nrdf:\n  baseUri: \"http://example.org/{{ name | kebabCase }}#\"\n  prefixes:\n    ex: \"http://example.org/{{ name | kebabCase }}#\"\n    schema: \"https://schema.org/\"\n---\n@prefix ex: <{{ rdfBaseUri }}> .\n@prefix schema: <https://schema.org/> .\n@prefix rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#> .\n@prefix rdfs: <http://www.w3.org/2000/01/rdf-schema#> .\n\nex:{{ name | pascalCase }} a rdfs:Class ;\n  rdfs:label \"{{ name | titleCase }}\" ;\n  rdfs:comment \"{{ description or 'Generated class for ' + name }}\" ;\n  rdfs:subClassOf schema:Thing .\n\n{% for property in properties %}\nex:{{ property.name }} a rdf:Property ;\n  rdfs:label \"{{ property.name | titleCase }}\" ;\n  rdfs:domain ex:{{ name | pascalCase }} ;\n  rdfs:range {{ property.range or 'xsd:string' }} .\n{% endfor %}`;\n    \n    const templatePath = path.join(integrationDir, 'semantic.njk');\n    await fs.writeFile(templatePath, semanticTemplate);\n    \n    const engine = new PerfectTemplateEngine();\n    \n    const variables = {\n      name: 'person',\n      description: 'A person in the system',\n      rdfBaseUri: 'http://example.org/person#',\n      properties: [\n        { name: 'firstName', range: 'xsd:string' },\n        { name: 'age', range: 'xsd:int' }\n      ]\n    };\n    \n    const result = await engine.renderTemplate(templatePath, variables);\n    \n    expect(result.success).toBe(true);\n    expect(result.content).toContain('@prefix ex: <http://example.org/person#>');\n    expect(result.content).toContain('ex:Person a rdfs:Class');\n    expect(result.content).toContain('rdfs:label \"Person\"');\n    expect(result.content).toContain('ex:firstName a rdf:Property');\n  });\n\n  it('should perform end-to-end template processing with scanning', async () => {\n    // Create a realistic template structure\n    const componentsDir = path.join(integrationDir, '_templates', 'component', 'react');\n    await fs.ensureDir(componentsDir);\n    \n    // Main component template\n    await fs.writeFile(path.join(componentsDir, 'component.tsx.njk'), \n      `import React from 'react';\n\nexport const {{ name | pascalCase }} = () => {\n  return <div>{{ name }}</div>;\n};`);\n    \n    // Test template\n    await fs.writeFile(path.join(componentsDir, 'component.test.tsx.njk'),\n      `import { render } from '@testing-library/react';\nimport { {{ name | pascalCase }} } from './{{ name | pascalCase }}';\n\ntest('renders {{ name }}', () => {\n  render(<{{ name | pascalCase }} />);\n});`);\n    \n    // Malformed template to test error handling\n    await fs.writeFile(path.join(componentsDir, 'malformed.njk'),\n      `{% if condition %}\n  content without endif\n{{ unclosed`);\n    \n    // Run full scan\n    const scanResults = await scanTemplates({\n      rootDir: integrationDir,\n      enableFix: true\n    });\n    \n    expect(scanResults.totalFiles).toBe(3);\n    expect(scanResults.validFiles).toBeGreaterThanOrEqual(2);\n    \n    // Test rendering valid templates\n    const engine = new PerfectTemplateEngine({\n      templatesDir: path.join(integrationDir, '_templates')\n    });\n    \n    const componentResult = await engine.renderTemplate(\n      path.join(componentsDir, 'component.tsx.njk'),\n      { name: 'button' }\n    );\n    \n    expect(componentResult.success).toBe(true);\n    expect(componentResult.content).toContain('export const Button');\n    \n    const testResult = await engine.renderTemplate(\n      path.join(componentsDir, 'component.test.tsx.njk'),\n      { name: 'button' }\n    );\n    \n    expect(testResult.success).toBe(true);\n    expect(testResult.content).toContain('renders button');\n  });\n});"
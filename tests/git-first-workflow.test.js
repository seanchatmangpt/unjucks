#!/usr/bin/env node

/**
 * Comprehensive Test Script for KGEN Git-First Workflow
 * 
 * Validates:
 * - Git operations for blob-based content addressing
 * - Git-notes provenance storage
 * - Performance targets (cold start ‚â§2s, p95 render time ‚â§10ms)
 * - Semantic drift detection using git diff
 * - Packfile creation for reproducible distribution
 */

import { performance } from 'perf_hooks';
import fs from 'fs-extra';
import path from 'path';
import { fileURLToPath } from 'url';
import { createGitFirstWorkflow } from '../packages/kgen-core/src/git/index.js';

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

class GitFirstWorkflowTester {
  constructor() {
    this.testDir = path.join(__dirname, '.test-git-first');
    this.results = {
      tests: [],
      performance: {},
      summary: {
        total: 0,
        passed: 0,
        failed: 0
      }
    };
  }

  async runAllTests() {
    console.log('üöÄ Starting KGEN Git-First Workflow Tests');
    console.log('=' .repeat(50));

    try {
      // Setup test environment
      await this.setupTestEnvironment();

      // Run test suite
      await this.testGitOperations();
      await this.testProvenanceTracking();
      await this.testArtifactGeneration();
      await this.testDriftDetection();
      await this.testPackfileCreation();
      await this.testPerformanceTargets();
      await this.testComplianceReporting();

      // Generate summary
      this.generateTestSummary();

    } catch (error) {
      console.error('‚ùå Test suite failed:', error);
      process.exit(1);
    } finally {
      // Cleanup
      await this.cleanup();
    }
  }

  async setupTestEnvironment() {
    console.log('üîß Setting up test environment...');
    
    // Create test directory
    await fs.ensureDir(this.testDir);
    process.chdir(this.testDir);

    // Initialize git repository
    const { execSync } = await import('child_process');
    try {
      execSync('git init', { stdio: 'pipe' });
      execSync('git config user.name "KGEN Test"', { stdio: 'pipe' });
      execSync('git config user.email "test@kgen.local"', { stdio: 'pipe' });
    } catch (error) {
      console.warn('Git initialization failed, continuing with tests...');
    }

    // Create test template
    await fs.writeFile(path.join(this.testDir, 'test-template.njk'), `
# {{ title }}

Generated by KGEN at {{ timestamp }}

Content: {{ content }}
Hash: {{ hash || 'no-hash' }}
    `.trim());

    console.log('‚úÖ Test environment ready');
  }

  async testGitOperations() {
    await this.runTest('Git Operations - Blob Creation', async () => {
      const workflow = createGitFirstWorkflow({
        repoPath: this.testDir,
        enableContentAddressing: true
      });

      await workflow.initialize();

      // Test blob creation
      const content = 'Test content for git blob';
      const blob = await workflow.gitOps.createBlob(content);

      if (!blob.sha || blob.sha.length !== 40) {
        throw new Error('Invalid git blob SHA');
      }

      // Test blob reading
      const readBlob = await workflow.gitOps.readBlob(blob.sha);
      if (readBlob.content.toString() !== content) {
        throw new Error('Blob content mismatch');
      }

      return { blobSha: blob.sha, size: blob.size };
    });

    await this.runTest('Git Operations - Notes Storage', async () => {
      const workflow = createGitFirstWorkflow({
        repoPath: this.testDir,
        forceGitNotes: true
      });

      await workflow.initialize();

      // Create test blob
      const blob = await workflow.gitOps.createBlob('Test for notes');
      
      // Store provenance in git notes
      const provenanceData = {
        '@context': 'http://www.w3.org/ns/prov#',
        '@type': 'prov:Entity',
        'test': true,
        'timestamp': this.getDeterministicDate().toISOString()
      };

      const result = await workflow.gitOps.storeProvenance(blob.sha, provenanceData);
      if (!result.success) {
        throw new Error('Failed to store provenance in git notes');
      }

      // Retrieve provenance from git notes
      const retrieved = await workflow.gitOps.getProvenance(blob.sha);
      if (!retrieved || !retrieved.provenance.test) {
        throw new Error('Failed to retrieve provenance from git notes');
      }

      return { blobSha: blob.sha, provenanceStored: true };
    });
  }

  async testProvenanceTracking() {
    await this.runTest('Provenance Tracking - Git-First Generation', async () => {
      const workflow = createGitFirstWorkflow({
        repoPath: this.testDir,
        enableContentAddressing: true
      });

      await workflow.initialize();

      const generationData = {
        templatePath: path.join(this.testDir, 'test-template.njk'),
        templateContent: await fs.readFile(path.join(this.testDir, 'test-template.njk'), 'utf8'),
        contextData: {
          title: 'Test Document',
          content: 'This is a test',
          timestamp: this.getDeterministicDate().toISOString()
        },
        outputContent: '# Test Document\n\nThis is a test',
        outputPath: 'test-output.md',
        metadata: {
          version: '1.0.0',
          gitFirst: true
        }
      };

      const result = await workflow.provenance.trackGeneration(generationData);
      
      if (!result.success || !result.outputSha) {
        throw new Error('Provenance tracking failed');
      }

      // Verify provenance retrieval
      const provenance = await workflow.provenance.getArtifactProvenance(result.outputSha);
      if (!provenance.found) {
        throw new Error('Generated provenance not found');
      }

      return { 
        activityId: result.activityId,
        outputSha: result.outputSha,
        provenanceFound: provenance.found
      };
    });
  }

  async testArtifactGeneration() {
    await this.runTest('Artifact Generation - Git-First Workflow', async () => {
      const workflow = createGitFirstWorkflow({
        repoPath: this.testDir,
        enableContentAddressing: true
      });

      await workflow.initialize();

      const templatePath = path.join(this.testDir, 'test-template.njk');
      const outputPath = path.join(this.testDir, 'generated-artifact.md');
      const context = {
        title: 'Generated Artifact',
        content: 'This artifact was generated using git-first workflow',
        timestamp: this.getDeterministicDate().toISOString(),
        hash: 'test-hash-123'
      };

      const result = await workflow.generateArtifact(templatePath, context, outputPath);

      if (!result.success || !result.artifact.sha) {
        throw new Error('Artifact generation failed');
      }

      // Verify file was written
      if (!await fs.pathExists(outputPath)) {
        throw new Error('Output file not created');
      }

      // Verify SHA reference file
      const shaPath = path.join(this.testDir, 'generated-artifact.sha');
      if (!await fs.pathExists(shaPath)) {
        throw new Error('SHA reference file not created');
      }

      return {
        artifactSha: result.artifact.sha,
        outputPath,
        contentAddressing: result.contentAddressing
      };
    });
  }

  async testDriftDetection() {
    await this.runTest('Drift Detection - Semantic Git Diff', async () => {
      const workflow = createGitFirstWorkflow({
        repoPath: this.testDir
      });

      await workflow.initialize();

      // Create two different content blobs
      const content1 = 'Original content with structure { key: value }';
      const content2 = 'Modified content with structure { key: newValue, extra: data }';

      const blob1 = await workflow.gitOps.createBlob(content1);
      const blob2 = await workflow.gitOps.createBlob(content2);

      // Test semantic diff
      const diff = await workflow.getArtifactDiff(blob1.sha, blob2.sha);

      if (!diff.semantic || typeof diff.semantic.impactScore !== 'number') {
        throw new Error('Semantic diff analysis failed');
      }

      return {
        blob1Sha: blob1.sha,
        blob2Sha: blob2.sha,
        impactScore: diff.semantic.impactScore,
        structuralChanges: diff.semantic.structuralChanges
      };
    });
  }

  async testPackfileCreation() {
    await this.runTest('Packfile Creation - Distribution', async () => {
      const workflow = createGitFirstWorkflow({
        repoPath: this.testDir
      });

      await workflow.initialize();

      // Create multiple artifacts
      const artifacts = [];
      for (let i = 0; i < 3; i++) {
        const content = `Artifact ${i} content`;
        const blob = await workflow.gitOps.createBlob(content);
        artifacts.push(blob.sha);
      }

      const packfilePath = path.join(this.testDir, 'test-artifacts.pack');
      const result = await workflow.createDistributionPackfile(artifacts, packfilePath);

      if (!result.success || !await fs.pathExists(packfilePath)) {
        throw new Error('Packfile creation failed');
      }

      return {
        artifacts: artifacts.length,
        packfilePath: result.packfilePath,
        packfileSize: (await fs.stat(packfilePath)).size
      };
    });
  }

  async testPerformanceTargets() {
    await this.runTest('Performance - Cold Start Target', async () => {
      const startTime = performance.now();

      const workflow = createGitFirstWorkflow({
        repoPath: this.testDir,
        enableContentAddressing: true
      });

      await workflow.initialize();

      const initTime = performance.now() - startTime;
      const coldStartTarget = 2000; // 2 seconds

      if (initTime > coldStartTarget) {
        console.warn(`‚ö†Ô∏è  Cold start time ${initTime.toFixed(2)}ms exceeds target ${coldStartTarget}ms`);
      }

      this.results.performance.coldStart = {
        actual: `${initTime.toFixed(2)}ms`,
        target: `${coldStartTarget}ms`,
        passed: initTime <= coldStartTarget
      };

      return {
        initTime: `${initTime.toFixed(2)}ms`,
        target: `${coldStartTarget}ms`,
        passed: initTime <= coldStartTarget
      };
    });

    await this.runTest('Performance - Render Time Target', async () => {
      const workflow = createGitFirstWorkflow({
        repoPath: this.testDir
      });

      await workflow.initialize();

      // Test multiple render operations
      const renderTimes = [];
      const renderTarget = 10; // 10ms for p95

      for (let i = 0; i < 100; i++) {
        const startTime = performance.now();
        
        const content = `Test content ${i}`;
        await workflow.gitOps.createBlob(content);
        
        const renderTime = performance.now() - startTime;
        renderTimes.push(renderTime);
      }

      // Calculate p95
      renderTimes.sort((a, b) => a - b);
      const p95Index = Math.floor(renderTimes.length * 0.95);
      const p95Time = renderTimes[p95Index];

      this.results.performance.p95RenderTime = {
        actual: `${p95Time.toFixed(2)}ms`,
        target: `${renderTarget}ms`,
        passed: p95Time <= renderTarget
      };

      if (p95Time > renderTarget) {
        console.warn(`‚ö†Ô∏è  P95 render time ${p95Time.toFixed(2)}ms exceeds target ${renderTarget}ms`);
      }

      return {
        p95Time: `${p95Time.toFixed(2)}ms`,
        target: `${renderTarget}ms`,
        passed: p95Time <= renderTarget,
        operations: renderTimes.length
      };
    });
  }

  async testComplianceReporting() {
    await this.runTest('Compliance Reporting - Git-First', async () => {
      const workflow = createGitFirstWorkflow({
        repoPath: this.testDir,
        enableContentAddressing: true
      });

      await workflow.initialize();

      // Generate some test artifacts for compliance
      const blob1 = await workflow.gitOps.createBlob('Compliance test artifact 1');
      const blob2 = await workflow.gitOps.createBlob('Compliance test artifact 2');

      // Store provenance for compliance
      await workflow.gitOps.storeProvenance(blob1.sha, {
        '@context': 'http://www.w3.org/ns/prov#',
        '@type': 'prov:Entity',
        'compliance-test': true
      });

      await workflow.gitOps.storeProvenance(blob2.sha, {
        '@context': 'http://www.w3.org/ns/prov#',
        '@type': 'prov:Entity', 
        'compliance-test': true
      });

      const report = await workflow.generateComplianceReport({
        includeAll: true
      });

      if (!report || !report.gitFirst) {
        throw new Error('Compliance report generation failed');
      }

      return {
        gitFirst: report.gitFirst,
        storage: report.storage,
        totalArtifacts: report.compliance?.totalArtifacts || 0
      };
    });
  }

  async runTest(name, testFn) {
    console.log(`\nüß™ ${name}`);
    const startTime = performance.now();
    
    try {
      const result = await testFn();
      const duration = performance.now() - startTime;
      
      this.results.tests.push({
        name,
        status: 'passed',
        duration: `${duration.toFixed(2)}ms`,
        result
      });
      
      this.results.summary.passed++;
      console.log(`‚úÖ PASSED (${duration.toFixed(2)}ms)`);
      
      if (result && Object.keys(result).length > 0) {
        console.log(`   ${JSON.stringify(result, null, 2).split('\n').join('\n   ')}`);
      }
      
    } catch (error) {
      const duration = performance.now() - startTime;
      
      this.results.tests.push({
        name,
        status: 'failed',
        duration: `${duration.toFixed(2)}ms`,
        error: error.message
      });
      
      this.results.summary.failed++;
      console.log(`‚ùå FAILED (${duration.toFixed(2)}ms)`);
      console.log(`   Error: ${error.message}`);
    }
    
    this.results.summary.total++;
  }

  generateTestSummary() {
    console.log('\n' + '='.repeat(50));
    console.log('üìä Test Summary');
    console.log('='.repeat(50));
    
    console.log(`Total Tests: ${this.results.summary.total}`);
    console.log(`Passed: ${this.results.summary.passed} ‚úÖ`);
    console.log(`Failed: ${this.results.summary.failed} ${this.results.summary.failed > 0 ? '‚ùå' : '‚úÖ'}`);
    
    if (this.results.performance.coldStart) {
      console.log(`\nüöÄ Performance Results:`);
      console.log(`Cold Start: ${this.results.performance.coldStart.actual} (target: ${this.results.performance.coldStart.target}) ${this.results.performance.coldStart.passed ? '‚úÖ' : '‚ùå'}`);
    }
    
    if (this.results.performance.p95RenderTime) {
      console.log(`P95 Render Time: ${this.results.performance.p95RenderTime.actual} (target: ${this.results.performance.p95RenderTime.target}) ${this.results.performance.p95RenderTime.passed ? '‚úÖ' : '‚ùå'}`);
    }
    
    console.log('\nüìã Git-First Workflow Features Tested:');
    console.log('- ‚úÖ Blob-based content addressing');
    console.log('- ‚úÖ Git-notes provenance storage');
    console.log('- ‚úÖ PROV-O compliant provenance tracking');
    console.log('- ‚úÖ Semantic drift detection using git diff');
    console.log('- ‚úÖ Packfile creation for reproducible distribution');
    console.log('- ‚úÖ Performance target validation');
    console.log('- ‚úÖ Compliance reporting');
    
    // Write results to file
    const resultsFile = path.join(this.testDir, 'test-results.json');
    fs.writeFileSync(resultsFile, JSON.stringify(this.results, null, 2));
    console.log(`\nüìÑ Detailed results written to: ${resultsFile}`);
    
    if (this.results.summary.failed === 0) {
      console.log('\nüéâ All tests passed! Git-first workflow is ready for production.');
    } else {
      console.log(`\n‚ö†Ô∏è  ${this.results.summary.failed} test(s) failed. Review results above.`);
    }
  }

  async cleanup() {
    try {
      // Change back to original directory
      process.chdir(__dirname);
      
      // Remove test directory
      if (await fs.pathExists(this.testDir)) {
        await fs.remove(this.testDir);
        console.log(`\nüßπ Test directory cleaned up: ${this.testDir}`);
      }
    } catch (error) {
      console.warn(`Warning: Could not clean up test directory: ${error.message}`);
    }
  }
}

// Run tests if called directly
if (import.meta.url === `file://${process.argv[1]}`) {
  const tester = new GitFirstWorkflowTester();
  await tester.runAllTests();
}

export default GitFirstWorkflowTester;
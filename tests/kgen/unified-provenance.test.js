/**
 * Unified Provenance System Test Suite
 * 
 * Comprehensive tests for the dark-matter provenance integration:
 * - .attest.json sidecar generation and verification
 * - Git-notes provenance storage and retrieval
 * - Content addressing and integrity verification
 * - Supply chain tracing and visualization
 * - Migration from existing formats
 */

import { describe, it, expect, beforeEach, afterEach, vi } from 'vitest';
import { UnifiedProvenanceSystem } from '../../packages/kgen-core/src/provenance/unified-provenance.js';
import { promises as fs } from 'fs';
import path from 'path';
import crypto from 'crypto';
import { fileURLToPath } from 'url';

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

describe('UnifiedProvenanceSystem', () => {
  let provenance;
  let testDir;
  let testArtifactPath;
  let testTemplatePath;

  beforeEach(async () => {
    // Create test directory
    testDir = path.join(__dirname, 'test-unified-provenance');
    await fs.mkdir(testDir, { recursive: true });

    // Create test artifacts
    testArtifactPath = path.join(testDir, 'test-artifact.js');
    testTemplatePath = path.join(testDir, 'test-template.njk');
    
    await fs.writeFile(testArtifactPath, 'console.log("Generated by unified provenance");');
    await fs.writeFile(testTemplatePath, 'console.log("{{ message }}");');

    // Initialize provenance system
    provenance = new UnifiedProvenanceSystem({
      gitRepoPath: testDir,
      enableGitFirst: true,
      noCentralDatabase: true,
      requireSidecars: true,
      enableContentAddressing: true
    });
    
    await provenance.initialize();
  });

  afterEach(async () => {
    // Cleanup test directory
    try {
      await fs.rm(testDir, { recursive: true, force: true });
    } catch (error) {
      // Ignore cleanup errors
    }
  });

  describe('initialization', () => {
    it('should initialize with dark-matter principles', async () => {
      const result = await provenance.initialize();
      
      expect(result.success).toBe(true);
      expect(result.version).toBe('2.0.0');
      expect(result.gitFirst).toBe(true);
      expect(result.darkMatter).toBe(true);
      expect(result.components.gitTracker).toBe(true);
      expect(result.components.attestationGenerator).toBe(true);
    });

    it('should enforce dark-matter compliance', async () => {
      const nonCompliantProvenance = new UnifiedProvenanceSystem({
        noCentralDatabase: false,
        enableGitFirst: false,
        requireSidecars: false
      });
      
      const result = await nonCompliantProvenance.initialize();
      expect(result.success).toBe(true);
      // Should still initialize but with warnings
    });

    it('should validate git repository setup', async () => {
      const result = await provenance.initialize();
      expect(result.components.gitOperations).toBe(true);
    });
  });

  describe('unified .attest.json sidecar generation', () => {
    it('should create unified format sidecar', async () => {
      const generationData = {
        artifactPath: testArtifactPath,
        templatePath: testTemplatePath,
        templateContent: await fs.readFile(testTemplatePath, 'utf8'),
        contextData: { message: 'test message' },
        metadata: {
          operationId: 'test-operation-123',
          agent: 'test-agent'
        }
      };

      const result = await provenance.trackGeneration(generationData);
      
      expect(result.success).toBe(true);
      expect(result.unified).toBe(true);
      expect(result.sidecar).toBeDefined();
      expect(result.artifactPath).toBe(testArtifactPath);
      
      // Verify sidecar file exists
      const sidecarPath = testArtifactPath + '.attest.json';
      expect(await fileExists(sidecarPath)).toBe(true);
      
      // Verify sidecar format
      const sidecarContent = JSON.parse(await fs.readFile(sidecarPath, 'utf8'));
      expect(sidecarContent.$schema).toBe('https://kgen.org/schemas/attestation-v1.1.json');
      expect(sidecarContent.version).toBe('1.1.0');
      expect(sidecarContent.unified).toBe(true);
      expect(sidecarContent.darkMatter).toBe(true);
      expect(sidecarContent.artifact).toBeDefined();
      expect(sidecarContent.generation).toBeDefined();
      expect(sidecarContent.environment).toBeDefined();
      expect(sidecarContent.verification).toBeDefined();
      expect(sidecarContent.signature).toBeDefined();
    });

    it('should include content addressing information', async () => {
      const generationData = {
        artifactPath: testArtifactPath,
        templatePath: testTemplatePath,
        templateContent: await fs.readFile(testTemplatePath, 'utf8'),
        contextData: { message: 'test' }
      };

      await provenance.trackGeneration(generationData);
      
      const sidecarPath = testArtifactPath + '.attest.json';
      const sidecar = JSON.parse(await fs.readFile(sidecarPath, 'utf8'));
      
      expect(sidecar.artifact.contentAddressing).toBeDefined();
      expect(sidecar.artifact.contentAddressing.enabled).toBe(true);
      expect(sidecar.artifact.contentAddressing.gitSha).toMatch(/^[a-f0-9]{40}$/);
    });

    it('should include PROV-O compliance section', async () => {
      const generationData = {
        artifactPath: testArtifactPath,
        templatePath: testTemplatePath,
        templateContent: 'template content',
        contextData: { test: 'data' }
      };

      await provenance.trackGeneration(generationData);
      
      const sidecarPath = testArtifactPath + '.attest.json';
      const sidecar = JSON.parse(await fs.readFile(sidecarPath, 'utf8'));
      
      expect(sidecar.provO).toBeDefined();
      expect(sidecar.provO['@context']).toBeDefined();
      expect(sidecar.provO['@type']).toBe('prov:Activity');
      expect(sidecar.provO['prov:used']).toBeDefined();
      expect(sidecar.provO['prov:generated']).toBeDefined();
    });

    it('should generate valid signatures', async () => {
      const generationData = {
        artifactPath: testArtifactPath,
        templatePath: testTemplatePath,
        templateContent: 'test template',
        contextData: { key: 'value' }
      };

      await provenance.trackGeneration(generationData);
      
      const sidecarPath = testArtifactPath + '.attest.json';
      const sidecar = JSON.parse(await fs.readFile(sidecarPath, 'utf8'));
      
      // Verify signature
      const dataForSigning = { ...sidecar };
      delete dataForSigning.signature;
      const expectedSignature = crypto.createHash('sha256')
        .update(JSON.stringify(dataForSigning, Object.keys(dataForSigning).sort()))
        .digest('hex');
      
      expect(sidecar.signature.value).toBe(expectedSignature);
    });
  });

  describe('git-notes provenance integration', () => {
    it('should store provenance in git notes', async () => {
      const generationData = {
        artifactPath: testArtifactPath,
        templatePath: testTemplatePath,
        templateContent: 'template content',
        contextData: { test: 'data' },
        metadata: { operationId: 'git-notes-test' }
      };

      const result = await provenance.trackGeneration(generationData);
      
      expect(result.gitProvenance).toBeDefined();
      expect(result.gitProvenance.success).toBe(true);
      expect(result.gitProvenance.outputSha).toMatch(/^[a-f0-9]{40}$/);
      expect(result.gitProvenance.provenanceStored).toBe(true);
      expect(result.gitProvenance.gitNotes).toBe(true);
    });

    it('should retrieve provenance from git notes', async () => {
      // First, store provenance
      const generationData = {
        artifactPath: testArtifactPath,
        templatePath: testTemplatePath,
        templateContent: 'template',
        contextData: { key: 'value' }
      };

      const trackResult = await provenance.trackGeneration(generationData);
      const artifactSha = trackResult.gitProvenance.outputSha;
      
      // Then retrieve it
      const retrievedProvenance = await provenance.gitTracker.getArtifactProvenance(artifactSha);
      
      expect(retrievedProvenance.found).toBe(true);
      expect(retrievedProvenance.provenance).toBeDefined();
      expect(retrievedProvenance.source).toBe('git-notes');
      expect(retrievedProvenance.provenance['@type']).toBe('prov:Activity');
    });

    it('should verify git-based integrity', async () => {
      const generationData = {
        artifactPath: testArtifactPath,
        templatePath: testTemplatePath,
        templateContent: 'template',
        contextData: {}
      };

      const trackResult = await provenance.trackGeneration(generationData);
      
      // Verify integrity
      const verification = await provenance.gitTracker.verifyArtifactIntegrity(
        trackResult.gitProvenance.outputSha
      );
      
      expect(verification.verified).toBe(true);
      expect(verification.blobExists).toBe(true);
      expect(verification.integrityVerified).toBe(true);
    });
  });

  describe('unified verification', () => {
    beforeEach(async () => {
      // Create test artifact with provenance
      const generationData = {
        artifactPath: testArtifactPath,
        templatePath: testTemplatePath,
        templateContent: 'template {{ value }}',
        contextData: { value: 'test' }
      };
      await provenance.trackGeneration(generationData);
    });

    it('should verify using unified approach', async () => {
      const verification = await provenance.verifyArtifact(testArtifactPath);
      
      expect(verification.unified).toBe(true);
      expect(verification.overall.verified).toBe(true);
      expect(verification.overall.confidence).toBe(1.0);
      expect(verification.results.sidecar.verified).toBe(true);
      expect(verification.results.gitProvenance.verified).toBe(true);
      expect(verification.results.contentAddressing.verified).toBe(true);
    });

    it('should detect tampered artifacts', async () => {
      // Tamper with artifact
      await fs.writeFile(testArtifactPath, 'TAMPERED CONTENT');
      
      const verification = await provenance.verifyArtifact(testArtifactPath);
      
      expect(verification.overall.verified).toBe(false);
      expect(verification.results.sidecar.verified).toBe(false);
      expect(verification.results.contentAddressing.verified).toBe(false);
      expect(verification.overall.issues.length).toBeGreaterThan(0);
    });

    it('should handle missing sidecars', async () => {
      // Remove sidecar file
      const sidecarPath = testArtifactPath + '.attest.json';
      await fs.unlink(sidecarPath);
      
      const verification = await provenance.verifyArtifact(testArtifactPath);
      
      expect(verification.overall.verified).toBe(false);
      expect(verification.results.sidecar.verified).toBe(false);
      expect(verification.results.sidecar.reason).toBe('No .attest.json sidecar found');
    });

    it('should calculate confidence scores', async () => {
      // Remove git provenance to test partial verification
      const testArtifact2 = path.join(testDir, 'artifact2.js');
      await fs.writeFile(testArtifact2, 'test content');
      
      // Create only sidecar, no git provenance
      const sidecarGenerator = new (await import('../../packages/kgen-core/src/attestation/generator.js')).AttestationGenerator();
      await sidecarGenerator.initialize();
      await sidecarGenerator.generateAttestation(testArtifact2, {
        templatePath: testTemplatePath
      });
      
      const verification = await provenance.verifyArtifact(testArtifact2);
      
      // Should have partial verification (sidecar only)
      expect(verification.overall.confidence).toBeLessThan(1.0);
      expect(verification.overall.confidence).toBeGreaterThan(0.0);
    });
  });

  describe('provenance retrieval and combination', () => {
    beforeEach(async () => {
      const generationData = {
        artifactPath: testArtifactPath,
        templatePath: testTemplatePath,
        templateContent: 'template content',
        contextData: { key: 'value' },
        metadata: { agent: 'test-agent' }
      };
      await provenance.trackGeneration(generationData);
    });

    it('should combine multiple provenance sources', async () => {
      const provenanceData = await provenance.getProvenance(testArtifactPath);
      
      expect(provenanceData.unified).toBe(true);
      expect(provenanceData.sources.sidecar).toBeDefined();
      expect(provenanceData.sources.gitNotes).toBeDefined();
      expect(provenanceData.sources.registry).toBeDefined();
      expect(provenanceData.combined).toBeDefined();
      
      // Combined data should include information from all sources
      expect(provenanceData.combined.artifact).toBeDefined();
      expect(provenanceData.combined.generation).toBeDefined();
      expect(provenanceData.combined.gitProvenance).toBeDefined();
    });

    it('should prioritize sidecar as primary source', async () => {
      const provenanceData = await provenance.getProvenance(testArtifactPath);
      
      // Primary data should come from sidecar
      expect(provenanceData.combined.unified).toBe(true);
      expect(provenanceData.combined.darkMatter).toBe(true);
      expect(provenanceData.combined.artifact.path).toBe(testArtifactPath);
    });
  });

  describe('supply chain graph building', () => {
    it('should update supply chain graph on generation', async () => {
      const generationData = {
        artifactPath: testArtifactPath,
        templatePath: testTemplatePath,
        templateContent: 'template',
        contextData: {},
        dependencies: ['/path/to/dependency1', '/path/to/dependency2']
      };

      const result = await provenance.trackGeneration(generationData);
      
      expect(result.supplyChainUpdated).toBe(true);
      
      // Check supply chain graph was updated
      expect(provenance.supplyChainGraph.has(testArtifactPath)).toBe(true);
      
      const chainEntry = provenance.supplyChainGraph.get(testArtifactPath);
      expect(chainEntry.templatePath).toBe(testTemplatePath);
      expect(chainEntry.dependencies).toEqual(['/path/to/dependency1', '/path/to/dependency2']);
    });

    it('should generate supply chain visualization data', async () => {
      // Create multiple artifacts with dependencies
      const artifacts = [];
      for (let i = 0; i < 3; i++) {
        const artifactPath = path.join(testDir, `artifact${i}.js`);
        await fs.writeFile(artifactPath, `console.log("artifact ${i}");`);
        
        await provenance.trackGeneration({
          artifactPath,
          templatePath: testTemplatePath,
          templateContent: 'template',
          contextData: { index: i },
          metadata: { templateFamily: 'test-family' }
        });
        
        artifacts.push(artifactPath);
      }
      
      const visualization = await provenance.generateSupplyChainVisualization();
      
      expect(visualization.unified).toBe(true);
      expect(visualization.graph.nodes.length).toBeGreaterThan(0);
      expect(visualization.graph.edges.length).toBeGreaterThan(0);
      expect(visualization.statistics.totalArtifacts).toBe(artifacts.length + 1); // +1 for original test artifact
      expect(visualization.statistics.templateFamilies).toContain('test-family');
    });
  });

  describe('verification commands generation', () => {
    beforeEach(async () => {
      const generationData = {
        artifactPath: testArtifactPath,
        templatePath: testTemplatePath,
        templateContent: 'template',
        contextData: {}
      };
      await provenance.trackGeneration(generationData);
    });

    it('should generate git show commands', async () => {
      const commandResult = await provenance.createVerificationCommand(testArtifactPath);
      
      expect(commandResult.command).toBe('git show + verify');
      expect(commandResult.verification).toBeDefined();
      expect(commandResult.provenance).toBeDefined();
      expect(commandResult.commands.gitShow).toBeDefined();
      expect(commandResult.commands.localVerify).toBeDefined();
      expect(commandResult.commands.supplyChain).toBeDefined();
      
      // Should have git show commands for content addressing
      expect(commandResult.commands.gitShow.length).toBeGreaterThan(0);
      expect(commandResult.commands.gitShow[0]).toContain('git notes');
    });

    it('should generate local verification commands', async () => {
      const commandResult = await provenance.createVerificationCommand(testArtifactPath);
      
      const localCommands = commandResult.commands.localVerify;
      expect(localCommands).toContain(`cat ${testArtifactPath}.attest.json | jq .`);
      expect(localCommands).toContain(`sha256sum ${testArtifactPath}`);
      expect(localCommands).toContain(`kgen verify ${testArtifactPath}`);
    });
  });

  describe('migration from existing formats', () => {
    it('should find existing .attest.json files', async () => {
      // Create old format attestation files
      const oldAttest1 = {
        version: '1.0.0',
        artifact: { path: testArtifactPath, hash: 'old-hash' },
        provenance: { templatePath: testTemplatePath }
      };
      
      const oldPath = testArtifactPath + '.attest.json';
      await fs.writeFile(oldPath, JSON.stringify(oldAttest1));
      
      const migration = await provenance.migrateExistingAttestations({
        dryRun: true
      });
      
      expect(migration.totalFiles).toBe(1);
      expect(migration.migratedFiles).toBe(0); // Dry run
    });

    it('should migrate old format to unified format', async () => {
      // Create old format attestation
      const oldAttest = {
        version: '1.0.0',
        artifact: { 
          path: testArtifactPath, 
          hash: 'old-hash',
          size: 100
        },
        provenance: { 
          templatePath: testTemplatePath,
          sourceGraph: { key: 'value' },
          generatedAt: this.getDeterministicDate().toISOString()
        },
        timestamp: this.getDeterministicDate().toISOString()
      };
      
      const sidecarPath = testArtifactPath + '.attest.json';
      await fs.writeFile(sidecarPath, JSON.stringify(oldAttest));
      
      const migration = await provenance.migrateExistingAttestations({
        createBackups: true
      });
      
      expect(migration.success).toBe(true);
      expect(migration.migratedFiles).toBe(1);
      expect(migration.backups.length).toBe(1);
      
      // Verify migrated format
      const migratedAttest = JSON.parse(await fs.readFile(sidecarPath, 'utf8'));
      expect(migratedAttest.$schema).toBe('https://kgen.org/schemas/attestation-v1.1.json');
      expect(migratedAttest.version).toBe('1.1.0');
      expect(migratedAttest.unified).toBe(true);
      expect(migratedAttest.darkMatter).toBe(true);
      expect(migratedAttest.migrated).toBeDefined();
    });

    it('should create git notes during migration', async () => {
      const oldAttest = {
        version: '1.0.0',
        artifact: { path: testArtifactPath, hash: 'old-hash' },
        provenance: { templatePath: testTemplatePath }
      };
      
      const sidecarPath = testArtifactPath + '.attest.json';
      await fs.writeFile(sidecarPath, JSON.stringify(oldAttest));
      
      const migration = await provenance.migrateExistingAttestations();
      
      expect(migration.gitNotesCreated).toBe(1);
    });
  });

  describe('error handling and edge cases', () => {
    it('should handle missing template files gracefully', async () => {
      const generationData = {
        artifactPath: testArtifactPath,
        templatePath: '/non/existent/template.njk',
        templateContent: 'fallback template',
        contextData: {}
      };

      const result = await provenance.trackGeneration(generationData);
      
      expect(result.success).toBe(true);
      // Should still create attestation even with missing template file
    });

    it('should handle corrupted sidecar files', async () => {
      // Create corrupted sidecar
      const sidecarPath = testArtifactPath + '.attest.json';
      await fs.writeFile(sidecarPath, '{ invalid json');
      
      const verification = await provenance.verifyArtifact(testArtifactPath);
      
      expect(verification.overall.verified).toBe(false);
      expect(verification.results.sidecar.verified).toBe(false);
      expect(verification.results.sidecar.reason).toContain('verification error');
    });

    it('should handle git repository issues', async () => {
      // Create provenance system without proper git setup
      const badGitProvenance = new UnifiedProvenanceSystem({
        gitRepoPath: '/tmp/non-existent-repo',
        enableGitFirst: true
      });
      
      // Should handle initialization gracefully
      await expect(badGitProvenance.initialize()).rejects.toThrow();
    });

    it('should handle partial verification scenarios', async () => {
      // Create artifact with only sidecar, no git provenance
      const partialArtifact = path.join(testDir, 'partial.js');
      await fs.writeFile(partialArtifact, 'partial content');
      
      // Generate only sidecar (not through unified system)
      const sidecar = {
        "$schema": "https://kgen.org/schemas/attestation-v1.1.json",
        "version": "1.1.0",
        "unified": true,
        "artifact": {
          "path": partialArtifact,
          "contentHash": crypto.createHash('sha256').update('partial content').digest('hex')
        },
        "signature": { "value": "dummy-signature" }
      };
      
      await fs.writeFile(partialArtifact + '.attest.json', JSON.stringify(sidecar));
      
      const verification = await provenance.verifyArtifact(partialArtifact);
      
      // Should have partial verification
      expect(verification.overall.confidence).toBeLessThan(1.0);
      expect(verification.results.sidecar.verified).toBe(false); // Invalid signature
    });
  });

  describe('performance and caching', () => {
    it('should cache verification results', async () => {
      const generationData = {
        artifactPath: testArtifactPath,
        templatePath: testTemplatePath,
        templateContent: 'template',
        contextData: {}
      };
      await provenance.trackGeneration(generationData);
      
      // First verification
      const start1 = this.getDeterministicTimestamp();
      const verification1 = await provenance.verifyArtifact(testArtifactPath);
      const time1 = this.getDeterministicTimestamp() - start1;
      
      // Second verification (should be cached)
      const start2 = this.getDeterministicTimestamp();
      const verification2 = await provenance.verifyArtifact(testArtifactPath);
      const time2 = this.getDeterministicTimestamp() - start2;
      
      expect(verification1.overall.verified).toBe(verification2.overall.verified);
      expect(provenance.verificationCache.has(testArtifactPath)).toBe(true);
      // Second call should generally be faster due to caching
      // Note: This is a performance hint, not a strict requirement
    });

    it('should handle large supply chain graphs efficiently', async () => {
      // Create a larger number of artifacts
      const artifacts = [];
      for (let i = 0; i < 50; i++) {
        const artifactPath = path.join(testDir, `large-test-${i}.js`);
        await fs.writeFile(artifactPath, `console.log("large test ${i}");`);
        
        // Create minimal provenance data
        const generationData = {
          artifactPath,
          templatePath: testTemplatePath,
          templateContent: 'template',
          contextData: { index: i }
        };
        
        await provenance.trackGeneration(generationData);
        artifacts.push(artifactPath);
      }
      
      // Generate visualization (should complete without timeout)
      const visualization = await provenance.generateSupplyChainVisualization();
      
      expect(visualization.statistics.totalArtifacts).toBe(artifacts.length);
      expect(visualization.graph.nodes.length).toBeGreaterThan(artifacts.length);
    });
  });
});

// Helper functions

async function fileExists(filePath) {
  try {
    await fs.access(filePath);
    return true;
  } catch {
    return false;
  }
}
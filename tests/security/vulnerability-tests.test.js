/**
 * Security and Vulnerability Tests
 * Comprehensive security testing for the CLI system
 */

import { describe, it, expect, beforeEach, afterEach } from 'vitest';
import { spawn } from 'child_process';
import fs from 'fs-extra';
import path from 'path';
import { fileURLToPath } from 'url';
import os from 'os';
import crypto from 'crypto';

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);
const projectRoot = path.resolve(__dirname, '../..');
const cliPath = path.join(projectRoot, 'bin/unjucks.cjs');

describe('Security and Vulnerability Tests', () => {
  let tempDir;
  let originalCwd;

  beforeEach(async () => {
    originalCwd = process.cwd();
    tempDir = await fs.mkdtemp(path.join(os.tmpdir(), 'unjucks-security-'));
    process.chdir(tempDir);
    await fs.ensureDir('_templates');
  });

  afterEach(async () => {
    process.chdir(originalCwd);
    await fs.remove(tempDir);
  });

  describe('Input Validation Security', () => {
    it('should prevent command injection through template names', async () => {
      const maliciousInput = 'test; rm -rf /; echo "pwned"';
      const result = await execCLI(['generate', 'component', maliciousInput]);
      
      // Should not execute the malicious command
      expect(result.stderr || result.stdout).not.toContain('pwned');
      expect(result.exitCode).toBeOneOf([0, 1]); // Graceful failure
    });

    it('should prevent path traversal in template names', async () => {
      const pathTraversalAttempts = [
        '../../../etc/passwd',
        '..\\..\\..\\windows\\system32\\config\\sam',
        '/etc/shadow',
        'C:\\Windows\\System32\\drivers\\etc\\hosts'
      ];

      for (const maliciousPath of pathTraversalAttempts) {
        const result = await execCLI(['generate', 'test', maliciousPath]);
        expect(result.exitCode).toBeOneOf([0, 1]);
        
        // Should not create files outside the intended directory
        expect(await fs.pathExists('/etc/passwd')).toBe(false);
      }
    });

    it('should sanitize special characters in inputs', async () => {
      const specialChars = ['<script>', '${command}', '`whoami`', '$(ls)', '|cat /etc/passwd'];
      
      for (const specialChar of specialChars) {
        const result = await execCLI(['generate', 'test', 'component', specialChar]);
        expect(result.exitCode).toBeOneOf([0, 1]);
      }
    });

    it('should handle extremely long input strings safely', async () => {
      const longString = 'A'.repeat(10000);
      const result = await execCLI(['generate', 'test', 'component', longString]);
      
      expect(result.exitCode).toBeOneOf([0, 1]);
      // Should not crash or consume excessive memory
    });
  });

  describe('Template Security', () => {
    it('should prevent code injection through template content', async () => {
      await fs.ensureDir('_templates/malicious/test');
      const maliciousTemplate = `
        {{ name }}
        {% raw %}
        <script>alert('XSS')</script>
        {{ process.env.HOME }}
        {{ require('fs').readFileSync('/etc/passwd', 'utf8') }}
        {% endraw %}
      `;
      
      await fs.writeFile('_templates/malicious/test/file.txt.njk', maliciousTemplate);
      
      const result = await execCLI(['malicious', 'test', 'TestName']);
      expect(result.exitCode).toBeOneOf([0, 1]);
      
      // Check if output file exists and doesn't contain dangerous content
      if (await fs.pathExists('file.txt')) {
        const content = await fs.readFile('file.txt', 'utf8');
        expect(content).not.toContain('<script>');
      }
    });

    it('should prevent server-side template injection', async () => {
      await fs.ensureDir('_templates/ssti/test');
      const sstiPayload = `
        {{ name }}
        {{ ''.__class__.__mro__[2].__subclasses__() }}
        {{ config.items() }}
        {{ self.__init__.__globals__.__builtins__.__import__('os').system('id') }}
      `;
      
      await fs.writeFile('_templates/ssti/test/payload.txt.njk', sstiPayload);
      
      const result = await execCLI(['ssti', 'test', 'TestPayload']);
      expect(result.exitCode).toBeOneOf([0, 1]);
    });

    it('should handle malformed template syntax safely', async () => {
      await fs.ensureDir('_templates/malformed/test');
      const malformedTemplate = `
        {{ unclosed
        {% if condition %}
        {% endfor %}
        {{ undefined.property.access }}
      `;
      
      await fs.writeFile('_templates/malformed/test/broken.txt.njk', malformedTemplate);
      
      const result = await execCLI(['malformed', 'test', 'TestName']);
      expect(result.exitCode).toBeOneOf([0, 1]);
      // Should not crash the application
    });
  });

  describe('File System Security', () => {
    it('should prevent writing files outside intended directories', async () => {
      await fs.ensureDir('_templates/pathtraversal/test');
      const traversalTemplate = `
---
to: ../../../etc/malicious-file
---
This should not be written outside the project
      `;
      
      await fs.writeFile('_templates/pathtraversal/test/file.txt.njk', traversalTemplate);
      
      const result = await execCLI(['pathtraversal', 'test', 'TestName']);
      expect(result.exitCode).toBeOneOf([0, 1]);
      
      // File should not exist in /etc/
      expect(await fs.pathExists('/etc/malicious-file')).toBe(false);
    });

    it('should handle symlink attacks safely', async () => {
      if (process.platform !== 'win32') {
        // Create a symlink to a sensitive file
        const sensitiveFile = '/etc/passwd';
        const symlinkPath = path.join(tempDir, 'malicious-link');
        
        try {
          await fs.symlink(sensitiveFile, symlinkPath);
          
          const result = await execCLI(['generate', 'test', 'component', '--output', symlinkPath]);
          expect(result.exitCode).toBeOneOf([0, 1]);
          
          // Should not overwrite the sensitive file
          const passwdContent = await fs.readFile(sensitiveFile, 'utf8').catch(() => '');
          expect(passwdContent).not.toContain('TestComponent');
        } catch (error) {
          // If symlink creation fails, test passes
          expect(true).toBe(true);
        }
      }
    });

    it('should validate file permissions before writing', async () => {
      const readOnlyFile = path.join(tempDir, 'readonly.txt');
      await fs.writeFile(readOnlyFile, 'read only');
      await fs.chmod(readOnlyFile, 0o444);
      
      const result = await execCLI(['generate', 'test', 'component', '--output', readOnlyFile]);
      expect(result.exitCode).toBeOneOf([0, 1]);
    });
  });

  describe('Environment Variable Security', () => {
    it('should not expose sensitive environment variables', async () => {
      process.env.SENSITIVE_KEY = 'secret-api-key-12345';
      process.env.PASSWORD = 'super-secret-password';
      
      const result = await execCLI(['--help']);
      expect(result.stdout).not.toContain('secret-api-key-12345');
      expect(result.stdout).not.toContain('super-secret-password');
      
      delete process.env.SENSITIVE_KEY;
      delete process.env.PASSWORD;
    });

    it('should handle malicious environment variables', async () => {
      process.env.UNJUCKS_MALICIOUS = '`rm -rf /`';
      process.env.NODE_OPTIONS = '--inspect=0.0.0.0:9229';
      
      const result = await execCLI(['--version']);
      expect(result.exitCode).toBe(0);
      
      delete process.env.UNJUCKS_MALICIOUS;
      delete process.env.NODE_OPTIONS;
    });
  });

  describe('Process Security', () => {
    it('should not spawn unauthorized child processes', async () => {
      // Monitor for child process spawning
      const originalSpawn = spawn;
      let spawnCalls = [];
      
      // This is a simplified test - in reality, the CLI should not spawn arbitrary processes
      const result = await execCLI(['--version']);
      expect(result.exitCode).toBe(0);
    });

    it('should handle resource exhaustion attacks', async () => {
      // Test with many concurrent requests
      const concurrentRequests = Array(50).fill().map(() => 
        execCLI(['--version'])
      );
      
      const results = await Promise.all(concurrentRequests);
      results.forEach(result => {
        expect(result.exitCode).toBe(0);
      });
    });

    it('should timeout on hanging operations', async () => {
      // This test ensures operations don't hang indefinitely
      const start = this.getDeterministicTimestamp();
      const result = await execCLI(['--help']);
      const duration = this.getDeterministicTimestamp() - start;
      
      expect(result.exitCode).toBe(0);
      expect(duration).toBeLessThan(30000); // 30 second timeout
    });
  });

  describe('Cryptographic Security', () => {
    it('should not expose cryptographic secrets in error messages', async () => {
      const result = await execCLI(['generate', 'nonexistent', 'template']);
      
      // Error messages should not contain sensitive information
      const output = result.stdout + result.stderr;
      expect(output).not.toMatch(/[a-f0-9]{32,}/); // No hex strings that might be keys
      expect(output).not.toMatch(/[A-Za-z0-9+/]{20,}={0,2}/); // No base64 that might be keys
    });

    it('should handle random data safely', async () => {
      const randomData = crypto.randomBytes(1000).toString('hex');
      const result = await execCLI(['generate', 'test', randomData]);
      
      expect(result.exitCode).toBeOneOf([0, 1]);
    });
  });

  describe('Denial of Service Prevention', () => {
    it('should handle zip bomb style template expansion', async () => {
      await fs.ensureDir('_templates/zipbomb/test');
      const zipBombTemplate = `
{% for i in range(0, 10000) -%}
{% for j in range(0, 10000) -%}
Data: {{ i }}-{{ j }}
{% endfor %}
{% endfor %}
      `;
      
      await fs.writeFile('_templates/zipbomb/test/bomb.txt.njk', zipBombTemplate);
      
      const start = this.getDeterministicTimestamp();
      const result = await execCLI(['zipbomb', 'test', 'TestBomb']);
      const duration = this.getDeterministicTimestamp() - start;
      
      // Should either complete quickly or fail gracefully
      expect(duration).toBeLessThan(30000); // 30 second max
      expect(result.exitCode).toBeOneOf([0, 1]);
    });

    it('should limit memory usage during template processing', async () => {
      const initialMemory = process.memoryUsage().heapUsed;
      
      await execCLI(['--version']); // Simple operation
      
      const finalMemory = process.memoryUsage().heapUsed;
      const memoryIncrease = finalMemory - initialMemory;
      
      // Should not use excessive memory
      expect(memoryIncrease).toBeLessThan(100 * 1024 * 1024); // 100MB limit
    });
  });

  describe('Information Disclosure Prevention', () => {
    it('should not leak internal file paths in errors', async () => {
      const result = await execCLI(['generate', 'nonexistent', 'template']);
      const output = result.stdout + result.stderr;
      
      // Should not expose internal system paths
      expect(output).not.toMatch(/\/home\/[^\/]+/);
      expect(output).not.toMatch(/C:\\Users\\[^\\]+/);
      expect(output).not.toMatch(/node_modules/);
    });

    it('should not expose system information in verbose mode', async () => {
      const result = await execCLI(['--help']);
      
      expect(result.stdout).not.toContain(process.version);
      expect(result.stdout).not.toContain(os.hostname());
      expect(result.stdout).not.toContain(process.cwd());
    });
  });
});

/**
 * Execute CLI command with security context
 */
function execCLI(args = []) {
  return new Promise((resolve) => {
    const child = spawn('node', [cliPath, ...args], {
      cwd: process.cwd(),
      env: { ...process.env, NODE_ENV: 'test' },
      timeout: 30000,
      stdio: ['pipe', 'pipe', 'pipe']
    });

    let stdout = '';
    let stderr = '';

    child.stdout?.on('data', (data) => {
      stdout += data.toString();
    });

    child.stderr?.on('data', (data) => {
      stderr += data.toString();
    });

    child.on('close', (exitCode) => {
      resolve({ exitCode: exitCode || 0, stdout, stderr });
    });

    child.on('error', (error) => {
      resolve({ exitCode: 1, stdout, stderr: error.message });
    });
  });
}

// Custom matcher
expect.extend({
  toBeOneOf(received, expected) {
    const pass = expected.includes(received);
    return {
      message: () => `expected ${received} to be one of ${expected.join(', ')}`,
      pass
    };
  }
});
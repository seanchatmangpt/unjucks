/**
 * Security Exploit Demonstration
 * Real attack scenarios to validate security controls
 */

import crypto from 'crypto';
import { performance } from 'perf_hooks';

class ExploitDemonstration {
  constructor() {
    this.exploitResults = [];
    this.detectedVulnerabilities = [];
  }

  async runExploitDemonstration() {
    console.log('üíÄ SECURITY EXPLOIT DEMONSTRATION');
    console.log('‚ö†Ô∏è  WARNING: This demonstrates real attack techniques for security validation');
    console.log('=' .repeat(70));

    const exploits = {
      timingAttacks: await this.demonstrateTimingAttacks(),
      signatureForgery: await this.demonstrateSignatureForgery(), 
      keyExtraction: await this.demonstrateKeyExtraction(),
      entropyExploitation: await this.demonstrateEntropyExploitation(),
      sidechannelAttacks: await this.demonstrateSidechannelAttacks()
    };

    console.log('\nüõ°Ô∏è EXPLOIT DEMONSTRATION COMPLETE');
    console.log('=' .repeat(70));
    this.summarizeResults();

    return {
      timestamp: new Date().toISOString(),
      exploits,
      vulnerabilities: this.detectedVulnerabilities,
      securityPosture: this.assessSecurityPosture()
    };
  }

  async demonstrateTimingAttacks() {
    console.log('\n‚è∞ TIMING ATTACK DEMONSTRATION');
    console.log('-'.repeat(40));

    // Simulate password guessing via timing attack
    console.log('üéØ Target: Password comparison function');
    
    const SECRET_PASSWORD = 'SuperSecret123!@#';
    
    // Vulnerable comparison function (early exit)
    const vulnerableCompare = (guess, secret) => {
      if (guess.length !== secret.length) return false;
      for (let i = 0; i < guess.length; i++) {
        if (guess[i] !== secret[i]) return false; // Early exit - VULNERABLE
      }
      return true;
    };

    // Attack: Progressive password guessing
    console.log('üîç Attempting progressive password discovery...');
    
    const charset = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789!@#$%^&*()';
    let discoveredPassword = '';
    const maxIterations = 50; // Limit for demonstration

    for (let pos = 0; pos < SECRET_PASSWORD.length && pos < maxIterations; pos++) {
      let bestChar = '';
      let longestTime = 0;
      
      for (let i = 0; i < Math.min(charset.length, 20); i++) { // Limit charset for demo
        const testChar = charset[i];
        const guess = discoveredPassword + testChar + 'X'.repeat(SECRET_PASSWORD.length - pos - 1);
        
        // Measure timing
        const iterations = 1000;
        const start = performance.now();
        
        for (let j = 0; j < iterations; j++) {
          vulnerableCompare(guess, SECRET_PASSWORD);
        }
        
        const end = performance.now();
        const timing = end - start;
        
        if (timing > longestTime) {
          longestTime = timing;
          bestChar = testChar;
        }
      }
      
      discoveredPassword += bestChar;
      console.log(`  Position ${pos}: '${bestChar}' (timing: ${longestTime.toFixed(2)}ms)`);
      
      // Check if we got the correct character
      if (bestChar === SECRET_PASSWORD[pos]) {
        console.log(`  ‚úÖ Correct character discovered at position ${pos}`);
      } else {
        console.log(`  ‚ùå Incorrect character (actual: '${SECRET_PASSWORD[pos]}')`);
        break;
      }
    }

    const attackSuccess = discoveredPassword.startsWith(SECRET_PASSWORD.substring(0, discoveredPassword.length));
    
    if (attackSuccess) {
      this.detectedVulnerabilities.push({
        type: 'TIMING_ATTACK_VULNERABILITY',
        severity: 'HIGH',
        description: 'Password comparison vulnerable to timing attacks',
        discoveredPrefix: discoveredPassword,
        actualPassword: SECRET_PASSWORD.substring(0, 10) + '...'
      });
    }

    console.log(`üéØ Attack Result: ${attackSuccess ? 'SUCCESSFUL' : 'FAILED'}`);
    console.log(`üìä Discovered: '${discoveredPassword}' (${discoveredPassword.length}/${SECRET_PASSWORD.length} chars)`);

    return {
      attackType: 'TIMING_ATTACK',
      successful: attackSuccess,
      discoveredPassword,
      targetLength: SECRET_PASSWORD.length,
      discoveredLength: discoveredPassword.length
    };
  }

  async demonstrateSignatureForgery() {
    console.log('\n‚úçÔ∏è SIGNATURE FORGERY DEMONSTRATION');
    console.log('-'.repeat(40));

    try {
      const keyPair = crypto.generateKeyPairSync('rsa', {
        modulusLength: 1024 // Smaller for faster demonstration
      });

      const originalMessage = 'Transfer $100 to Alice';
      const maliciousMessage = 'Transfer $999999 to Mallory';

      console.log(`üéØ Target: Digital signature system`);
      console.log(`üìÑ Original: "${originalMessage}"`);
      console.log(`üíÄ Malicious: "${maliciousMessage}"`);

      // Get legitimate signature
      const legitimateSignature = crypto.sign('sha256', Buffer.from(originalMessage), keyPair.privateKey);
      console.log(`üîê Legitimate signature obtained (${legitimateSignature.length} bytes)`);

      // Attempt 1: Direct signature transfer
      console.log('\nüîç Attempt 1: Direct signature transfer');
      const directTransfer = crypto.verify('sha256', Buffer.from(maliciousMessage), keyPair.publicKey, legitimateSignature);
      console.log(`  Result: ${directTransfer ? '‚úÖ SUCCESSFUL (VULNERABLE!)' : '‚ùå FAILED (SECURE)'}`);

      // Attempt 2: Signature malleability exploit
      console.log('\nüîç Attempt 2: Signature malleability');
      const modifiedSignature = Buffer.from(legitimateSignature);
      // Flip some bits to test malleability
      modifiedSignature[modifiedSignature.length - 1] ^= 0x01;
      
      const malleabilitySuccess = crypto.verify('sha256', Buffer.from(originalMessage), keyPair.publicKey, modifiedSignature);
      console.log(`  Result: ${malleabilitySuccess ? '‚úÖ SUCCESSFUL (VULNERABLE!)' : '‚ùå FAILED (SECURE)'}`);

      // Attempt 3: Weak signature generation
      console.log('\nüîç Attempt 3: Weak signature analysis');
      
      const signatures = [];
      const message = 'test message';
      
      // Generate multiple signatures of the same message
      for (let i = 0; i < 5; i++) {
        const sig = crypto.sign('sha256', Buffer.from(message), keyPair.privateKey);
        signatures.push(sig.toString('hex'));
      }
      
      // Check for signature reuse (would be a critical vulnerability)
      const uniqueSignatures = new Set(signatures);
      const signatureReuse = uniqueSignatures.size < signatures.length;
      
      console.log(`  Generated signatures: ${signatures.length}`);
      console.log(`  Unique signatures: ${uniqueSignatures.size}`);
      console.log(`  Result: ${signatureReuse ? '‚úÖ REUSE DETECTED (CRITICAL!)' : '‚ùå NO REUSE (SECURE)'}`);

      const forgerySuccessful = directTransfer || malleabilitySuccess || signatureReuse;

      if (forgerySuccessful) {
        this.detectedVulnerabilities.push({
          type: 'SIGNATURE_FORGERY_VULNERABILITY',
          severity: 'CRITICAL',
          description: 'Digital signature scheme vulnerable to forgery attacks'
        });
      }

      console.log(`\nüéØ Overall forgery attack: ${forgerySuccessful ? 'SUCCESSFUL' : 'FAILED'}`);

      return {
        attackType: 'SIGNATURE_FORGERY',
        successful: forgerySuccessful,
        attempts: {
          directTransfer,
          malleability: malleabilitySuccess,
          signatureReuse
        }
      };

    } catch (error) {
      console.log(`‚ùå Signature forgery test failed: ${error.message}`);
      return {
        attackType: 'SIGNATURE_FORGERY',
        successful: false,
        error: error.message
      };
    }
  }

  async demonstrateKeyExtraction() {
    console.log('\nüîê KEY EXTRACTION DEMONSTRATION');
    console.log('-'.repeat(40));

    try {
      // Simulate key extraction via timing analysis
      console.log('üéØ Target: RSA private key');

      const keyPair = crypto.generateKeyPairSync('rsa', {
        modulusLength: 512 // Very small for demonstration
      });

      // Attempt to extract key bits via timing analysis of decryption
      console.log('üîç Analyzing decryption timing patterns...');

      const timingData = [];
      const testCiphertexts = [];

      // Generate test ciphertexts with known patterns
      for (let i = 0; i < 20; i++) {
        const plaintext = Buffer.alloc(32);
        plaintext.fill(i); // Different patterns
        
        try {
          const ciphertext = crypto.publicEncrypt(keyPair.publicKey, plaintext);
          testCiphertexts.push({ plaintext: i, ciphertext });
        } catch (error) {
          // Some plaintexts might not encrypt properly
        }
      }

      console.log(`üìä Generated ${testCiphertexts.length} test ciphertexts`);

      // Measure decryption timings
      for (const test of testCiphertexts) {
        const measurements = [];
        
        for (let j = 0; j < 10; j++) {
          const start = performance.now();
          try {
            crypto.privateDecrypt(keyPair.privateKey, test.ciphertext);
          } catch (error) {
            // Decryption might fail, but we're measuring timing
          }
          const end = performance.now();
          measurements.push(end - start);
        }

        const avgTiming = measurements.reduce((a, b) => a + b) / measurements.length;
        const variance = this.calculateVariance(measurements);
        
        timingData.push({
          pattern: test.plaintext,
          avgTiming,
          variance,
          measurements
        });
      }

      // Analyze timing patterns for key-dependent behavior
      const timings = timingData.map(d => d.avgTiming);
      const maxTiming = Math.max(...timings);
      const minTiming = Math.min(...timings);
      const timingVariation = (maxTiming - minTiming) / minTiming;

      console.log(`‚è±Ô∏è  Timing variation: ${(timingVariation * 100).toFixed(2)}%`);
      
      // If timing variation is significant, key extraction might be possible
      const extractionPossible = timingVariation > 0.1; // 10% threshold
      
      console.log(`üéØ Key extraction via timing: ${extractionPossible ? 'POSSIBLE (VULNERABLE!)' : 'NOT FEASIBLE (SECURE)'}`);

      if (extractionPossible) {
        // Simulate partial key recovery
        const simulatedKeyBits = this.simulateKeyBitRecovery(timingData);
        console.log(`üîì Simulated key bits recovered: ${simulatedKeyBits.length} bits`);
        console.log(`üìä Estimated key recovery: ${simulatedKeyBits.slice(0, 16)}...`);

        this.detectedVulnerabilities.push({
          type: 'KEY_EXTRACTION_VULNERABILITY',
          severity: 'CRITICAL',
          description: 'Private key vulnerable to timing-based extraction',
          timingVariation: timingVariation
        });
      }

      return {
        attackType: 'KEY_EXTRACTION',
        successful: extractionPossible,
        timingVariation,
        testCiphertexts: testCiphertexts.length,
        keyBitsRecovered: extractionPossible ? 16 : 0
      };

    } catch (error) {
      console.log(`‚ùå Key extraction test failed: ${error.message}`);
      return {
        attackType: 'KEY_EXTRACTION',
        successful: false,
        error: error.message
      };
    }
  }

  async demonstrateEntropyExploitation() {
    console.log('\nüé≤ ENTROPY EXPLOITATION DEMONSTRATION');
    console.log('-'.repeat(40));

    console.log('üéØ Target: Random number generation');
    
    // Collect random samples to analyze for patterns
    const samples = [];
    const sampleSize = 1000;

    console.log(`üìä Collecting ${sampleSize} random samples...`);
    
    for (let i = 0; i < sampleSize; i++) {
      const sample = crypto.randomBytes(4).readUInt32BE(0);
      samples.push(sample);
    }

    // Analysis 1: Look for sequential patterns
    console.log('\nüîç Analysis 1: Sequential pattern detection');
    let sequentialPairs = 0;
    
    for (let i = 0; i < samples.length - 1; i++) {
      if (Math.abs(samples[i + 1] - samples[i]) === 1) {
        sequentialPairs++;
      }
    }
    
    const sequentialRatio = sequentialPairs / (samples.length - 1);
    console.log(`  Sequential pairs found: ${sequentialPairs}/${samples.length - 1} (${(sequentialRatio * 100).toFixed(3)}%)`);
    
    // Analysis 2: Modulus bias
    console.log('\nüîç Analysis 2: Modulus bias detection');
    const modulus = 256;
    const bins = new Array(modulus).fill(0);
    
    samples.forEach(sample => {
      bins[sample % modulus]++;
    });
    
    const expectedCount = samples.length / modulus;
    const maxDeviation = Math.max(...bins.map(count => 
      Math.abs(count - expectedCount) / expectedCount
    ));
    
    console.log(`  Maximum bin deviation: ${(maxDeviation * 100).toFixed(2)}%`);
    
    // Analysis 3: Autocorrelation
    console.log('\nüîç Analysis 3: Autocorrelation analysis');
    const maxLag = 10;
    let maxCorrelation = 0;
    
    for (let lag = 1; lag <= maxLag; lag++) {
      let correlation = 0;
      let count = 0;
      
      for (let i = 0; i < samples.length - lag; i++) {
        correlation += samples[i] * samples[i + lag];
        count++;
      }
      
      correlation = Math.abs(correlation / count);
      maxCorrelation = Math.max(maxCorrelation, correlation);
    }
    
    console.log(`  Maximum autocorrelation: ${maxCorrelation.toExponential(3)}`);
    
    // Determine if entropy is exploitable
    const entropyWeakness = sequentialRatio > 0.01 || maxDeviation > 0.2 || maxCorrelation > 1e10;
    
    console.log(`\nüéØ Entropy exploitation: ${entropyWeakness ? 'POSSIBLE (VULNERABLE!)' : 'NOT FEASIBLE (SECURE)'}`);

    if (entropyWeakness) {
      this.detectedVulnerabilities.push({
        type: 'ENTROPY_WEAKNESS',
        severity: 'HIGH',
        description: 'Random number generator shows exploitable patterns',
        evidence: {
          sequentialRatio,
          maxDeviation,
          maxCorrelation: maxCorrelation.toExponential(3)
        }
      });
    }

    return {
      attackType: 'ENTROPY_EXPLOITATION',
      successful: entropyWeakness,
      analysis: {
        sequentialRatio,
        maxDeviation,
        maxCorrelation
      },
      samplesAnalyzed: sampleSize
    };
  }

  async demonstrateSidechannelAttacks() {
    console.log('\nüì° SIDE-CHANNEL ATTACK DEMONSTRATION');
    console.log('-'.repeat(40));

    console.log('üéØ Target: AES encryption operation');
    
    try {
      const key = crypto.randomBytes(32); // AES-256 key
      const testData = [
        Buffer.alloc(16, 0x00),      // All zeros
        Buffer.alloc(16, 0xFF),      // All ones  
        Buffer.from('0123456789ABCDEF'), // Sequential pattern
        crypto.randomBytes(16)        // Random
      ];

      console.log(`üìä Testing ${testData.length} different plaintext patterns`);

      const timingProfiles = [];

      // Collect timing data for each pattern
      for (let i = 0; i < testData.length; i++) {
        const plaintext = testData[i];
        const measurements = [];

        console.log(`üîç Pattern ${i + 1}: ${plaintext.toString('hex').substring(0, 8)}...`);

        for (let j = 0; j < 100; j++) {
          const start = performance.now();
          
          // Encrypt the data
          const cipher = crypto.createCipher('aes-256-ecb', key);
          cipher.update(plaintext);
          cipher.final();
          
          const end = performance.now();
          measurements.push(end - start);
        }

        const avgTiming = measurements.reduce((a, b) => a + b) / measurements.length;
        const variance = this.calculateVariance(measurements);

        timingProfiles.push({
          pattern: plaintext.toString('hex').substring(0, 8) + '...',
          avgTiming,
          variance,
          measurements: measurements.length
        });

        console.log(`  Average timing: ${avgTiming.toFixed(4)}ms, Variance: ${variance.toFixed(6)}`);
      }

      // Analyze for side-channel leakage
      const timings = timingProfiles.map(p => p.avgTiming);
      const variances = timingProfiles.map(p => p.variance);
      
      const timingRange = Math.max(...timings) - Math.min(...timings);
      const avgTiming = timings.reduce((a, b) => a + b) / timings.length;
      const timingVariation = timingRange / avgTiming;

      console.log(`\nüìä Analysis Results:`);
      console.log(`  Timing range: ${timingRange.toFixed(4)}ms`);
      console.log(`  Average timing: ${avgTiming.toFixed(4)}ms`);
      console.log(`  Relative variation: ${(timingVariation * 100).toFixed(3)}%`);

      // Determine if side-channel attack is feasible
      const sidechannelVulnerable = timingVariation > 0.05; // 5% threshold

      console.log(`\nüéØ Side-channel attack: ${sidechannelVulnerable ? 'FEASIBLE (VULNERABLE!)' : 'NOT FEASIBLE (SECURE)'}`);

      if (sidechannelVulnerable) {
        this.detectedVulnerabilities.push({
          type: 'SIDECHANNEL_VULNERABILITY',
          severity: 'MEDIUM',
          description: 'Cryptographic operations vulnerable to timing-based side-channel attacks',
          timingVariation: timingVariation
        });
      }

      return {
        attackType: 'SIDECHANNEL',
        successful: sidechannelVulnerable,
        timingVariation,
        patternsAnalyzed: testData.length,
        measurementsPerPattern: 100
      };

    } catch (error) {
      console.log(`‚ùå Side-channel attack test failed: ${error.message}`);
      return {
        attackType: 'SIDECHANNEL',
        successful: false,
        error: error.message
      };
    }
  }

  // Utility methods
  calculateVariance(data) {
    if (data.length === 0) return 0;
    const mean = data.reduce((a, b) => a + b) / data.length;
    const squaredDiffs = data.map(value => Math.pow(value - mean, 2));
    return squaredDiffs.reduce((a, b) => a + b) / data.length;
  }

  simulateKeyBitRecovery(timingData) {
    // Simulate key bit recovery based on timing analysis
    // In reality, this would require sophisticated statistical analysis
    const recoveredBits = [];
    
    for (let i = 0; i < 16; i++) { // Simulate recovering 16 bits
      // Use timing patterns to guess key bits (simplified simulation)
      const bit = timingData[i % timingData.length]?.avgTiming > 
                  (timingData.reduce((sum, d) => sum + d.avgTiming, 0) / timingData.length) ? '1' : '0';
      recoveredBits.push(bit);
    }
    
    return recoveredBits.join('');
  }

  summarizeResults() {
    const totalExploits = this.exploitResults.length;
    const successfulExploits = this.exploitResults.filter(e => e.successful).length;
    const vulnerabilityCount = this.detectedVulnerabilities.length;

    console.log(`\nüìä EXPLOIT DEMONSTRATION SUMMARY:`);
    console.log(`  Total attack scenarios: ${totalExploits || 5}`);
    console.log(`  Successful exploits: ${successfulExploits || 'TBD'}`);
    console.log(`  Vulnerabilities detected: ${vulnerabilityCount}`);

    if (this.detectedVulnerabilities.length > 0) {
      console.log('\nüö® DETECTED VULNERABILITIES:');
      this.detectedVulnerabilities.forEach((vuln, index) => {
        console.log(`  ${index + 1}. [${vuln.severity}] ${vuln.type}: ${vuln.description}`);
      });
    } else {
      console.log('\n‚úÖ NO CRITICAL VULNERABILITIES DETECTED');
    }
  }

  assessSecurityPosture() {
    const criticalVulns = this.detectedVulnerabilities.filter(v => v.severity === 'CRITICAL').length;
    const highVulns = this.detectedVulnerabilities.filter(v => v.severity === 'HIGH').length;
    const mediumVulns = this.detectedVulnerabilities.filter(v => v.severity === 'MEDIUM').length;

    if (criticalVulns > 0) return 'CRITICAL';
    if (highVulns > 0) return 'HIGH_RISK';
    if (mediumVulns > 0) return 'MEDIUM_RISK';
    return 'SECURE';
  }
}

// Execute the exploit demonstration
const exploitDemo = new ExploitDemonstration();
const results = await exploitDemo.runExploitDemonstration();

console.log(`\nüîê FINAL SECURITY ASSESSMENT: ${results.securityPosture}`);

// Exit with appropriate status
if (results.securityPosture === 'CRITICAL') {
  process.exit(1);
} else if (results.securityPosture === 'HIGH_RISK') {
  process.exit(2);
} else {
  process.exit(0);
}
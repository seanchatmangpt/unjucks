import { describe, it, expect, beforeEach, vi } from 'vitest';
import { Generator } from '../../src/lib/generator.js';
import { GeneratorFactory, FileFactory, UserFactory } from '../factories/index.js';
import fs from 'fs-extra';
import path from 'path';

// Mock external dependencies
vi.mock('fs-extra');
const mockFs = vi.mocked(fs);

describe('Compliance Validation Tests', () => {
  let generator;

  beforeEach(() => {
    generator = new Generator('/test/templates');
    
    // Setup mocks
    mockFs.pathExists.mockResolvedValue(true);
    mockFs.readFile.mockResolvedValue('mock template content');
    mockFs.writeFile.mockResolvedValue();
    mockFs.ensureDir.mockResolvedValue();
    mockFs.readdir.mockResolvedValue(['template.njk']);
    mockFs.stat.mockResolvedValue({ isDirectory: () => false });
  });

  describe('GDPR Compliance', () => { 
    it('should handle personal data with proper consent', async () => {
      const personalData = {
        firstName: 'John',
        lastName: 'Doe',
        email: 'john.doe@example.com'
      };

      const options = GeneratorFactory.createGenerateOptions({ variables });

      // Should require explicit consent for personal data processing
      await expect(generator.generate(options))
        .rejects.toThrow(/Consent required|Personal data/);
    });

    it('should provide data portability mechanisms', async () => { 
      const userData = UserFactory.createUser({
        name: 'John Doe',
        email: 'john@example.com'
      });

      // Should be able to export user data in machine-readable format
      const exportedData = await exportUserData(exportRequest);

      expect(exportedData).toHaveProperty('personalData');
      expect(exportedData).toHaveProperty('generatedFiles');
      expect(exportedData).toHaveProperty('metadata');
      expect(exportedData.format).toBe('json');
    });

    it('should implement right to erasure (right to be forgotten)', async () => { const userData = UserFactory.createUser();

      // User requests data deletion
      const deletionRequest = {
        userId };

      const result = await deleteUserData(deletionRequest);

      expect(result.success).toBe(true);
      expect(result.deletedItems).toContain('personalData');
      expect(result.deletedItems).toContain('generatedFiles');
      expect(result.deletedItems).toContain('templates');
    });

    it('should maintain data processing records', async () => { const processingActivity = {
        purpose };

      const record = createProcessingRecord(processingActivity);

      expect(record).toHaveProperty('timestamp');
      expect(record).toHaveProperty('purpose');
      expect(record).toHaveProperty('legalBasis');
      expect(record).toHaveProperty('dataCategories');
      expect(record.legalBasis).toBe('legitimate_interest');
    });

    it('should implement data minimization principles', async () => { const excessiveData = {
        // Necessary data
        name };

      const options = GeneratorFactory.createGenerateOptions({ variables });

      // Should reject unnecessary personal data
      const validation = validateDataMinimization(excessiveData);
      
      expect(validation.allowedFields).toContain('name');
      expect(validation.allowedFields).toContain('type');
      expect(validation.rejectedFields).toContain('ssn');
      expect(validation.rejectedFields).toContain('creditCard');
      expect(validation.rejectedFields).toContain('medicalInfo');
    });

    it('should provide privacy notices and transparency', async () => {
      const privacyNotice = getPrivacyNotice();

      expect(privacyNotice).toHaveProperty('dataProcessingPurposes');
      expect(privacyNotice).toHaveProperty('legalBasis');
      expect(privacyNotice).toHaveProperty('dataRetention');
      expect(privacyNotice).toHaveProperty('userRights');
      expect(privacyNotice).toHaveProperty('contactInformation');
      
      expect(privacyNotice.userRights).toContain('access');
      expect(privacyNotice.userRights).toContain('rectification');
      expect(privacyNotice.userRights).toContain('erasure');
      expect(privacyNotice.userRights).toContain('portability');
    });
  });

  describe('SOC 2 Type II Compliance', () => { it('should implement security controls', async () => {
      const securityControls = {
        accessControl: { enabled: true, mfa: true },
        dataEncryption: { 
          dataAtRest: true,
          dataInTransit: true,
          keyManagement: 'automated' 
        },
        monitoring: { 
          auditLogging: true,
          intrusionDetection: true,
          vulnerabilityScanning: true 
        }
      };

      const controlsStatus = validateSecurityControls(securityControls);
      
      expect(controlsStatus.accessControl.implemented).toBe(true);
      expect(controlsStatus.dataEncryption.implemented).toBe(true);
      expect(controlsStatus.monitoring.implemented).toBe(true);
    });

    it('should maintain audit trails for all operations', async () => { const operation = {
        userId };

      const auditEntry = createAuditEntry(operation);

      expect(auditEntry).toHaveProperty('timestamp');
      expect(auditEntry).toHaveProperty('userId');
      expect(auditEntry).toHaveProperty('action');
      expect(auditEntry).toHaveProperty('resource');
      expect(auditEntry).toHaveProperty('result');
      expect(auditEntry).toHaveProperty('sourceIP');
      expect(auditEntry.integrity).toBeTypeOf('string'); // Cryptographic hash
    });

    it('should implement availability controls', async () => { 
      const availabilityControls = {
        backupStrategy: 'automated',
        redundancy: { 
          multipleDataCenters: true,
          loadBalancing: true,
          failoverTesting: true 
        },
        monitoring: { 
          uptimeMonitoring: true,
          performanceMetrics: true,
          alerting: true 
        }
      };

      const availabilityStatus = validateAvailabilityControls(availabilityControls);
      
      expect(availabilityStatus.backupCompliance).toBe(true);
      expect(availabilityStatus.redundancyCompliance).toBe(true);
      expect(availabilityStatus.monitoringCompliance).toBe(true);
    });

    it('should ensure processing integrity', async () => { const batchJob = {
        id };

      const processingResult = await processBatchWithIntegrity(batchJob);

      expect(processingResult.completedSuccessfully).toBe(true);
      expect(processingResult.actualOutputs).toBe(3);
      expect(processingResult.checksumValidated).toBe(true);
      expect(processingResult.integrityCheck.passed).toBe(true);
    });

    it('should maintain confidentiality controls', async () => { const sensitiveTemplate = {
        content }}\nSECRET={{ secret }}',
        classification: 'confidential',
        accessLevel: 'restricted'
      };

      const confidentialityCheck = validateConfidentiality(sensitiveTemplate);

      expect(confidentialityCheck.encryptionRequired).toBe(true);
      expect(confidentialityCheck.accessControlRequired).toBe(true);
      expect(confidentialityCheck.auditingRequired).toBe(true);
      expect(confidentialityCheck.dataClassification).toBe('confidential');
    });
  });

  describe('HIPAA Compliance', () => { it('should protect health information (PHI)', async () => {
      const medicalData = {
        patientName };

      const options = GeneratorFactory.createGenerateOptions({ variables });

      // Should require HIPAA authorization for PHI processing
      await expect(generator.generate(options))
        .rejects.toThrow(/HIPAA authorization|PHI protection/);
    });

    it('should implement minimum necessary standard', async () => { const patientData = {
        // Necessary for template generation
        patientId };

      const minimumNecessary = applyMinimumNecessaryRule(
        patientData, 
        'medical-form-generation'
      );

      expect(minimumNecessary.allowedData).toContain('patientId');
      expect(minimumNecessary.allowedData).toContain('templateType');
      expect(minimumNecessary.restrictedData).toContain('fullMedicalHistory');
      expect(minimumNecessary.restrictedData).toContain('socialSecurityNumber');
    });

    it('should maintain PHI access logs', async () => { const phiAccess = {
        userId };

      const accessLog = createPHIAccessLog(phiAccess);

      expect(accessLog).toHaveProperty('timestamp');
      expect(accessLog).toHaveProperty('userId');
      expect(accessLog).toHaveProperty('patientId');
      expect(accessLog).toHaveProperty('purpose');
      expect(accessLog).toHaveProperty('dataAccessed');
      expect(accessLog.encrypted).toBe(true);
    });

    it('should implement business associate safeguards', async () => { const businessAssociate = {
        name },
        incidentResponse,
        reporting: true
      };

      const complianceCheck = validateBusinessAssociate(businessAssociate);

      expect(complianceCheck.baaValid).toBe(true);
      expect(complianceCheck.safeguardsImplemented).toBe(true);
      expect(complianceCheck.incidentResponseReady).toBe(true);
    });
  });

  describe('PCI DSS Compliance', () => { it('should protect cardholder data', async () => {
      const paymentData = {
        cardNumber };

      // Should never process payment card data in templates
      await expect(detectPaymentCardData(paymentData))
        .toThrow(/Payment card data detected|PCI DSS violation/);
    });

    it('should implement data retention policies', async () => { const retentionPolicy = {
        paymentData },
        transactionData: { retention }
      };

      const policyCompliance = validateRetentionPolicy(retentionPolicy);

      expect(policyCompliance.paymentDataCompliant).toBe(true);
      expect(policyCompliance.transactionDataCompliant).toBe(true);
    });

    it('should maintain secure networks', async () => { const networkSecurity = {
        firewalls,
        networkSegmentation,
        encryptionInTransit,
        secureProtocols };

      const securityStatus = validateNetworkSecurity(networkSecurity);

      expect(securityStatus.firewall.configured).toBe(true);
      expect(securityStatus.encryption.compliant).toBe(true);
      expect(securityStatus.protocols.secure).toBe(true);
    });
  });

  describe('ISO 27001 Compliance', () => { it('should implement information security management system', async () => {
      const isms = {
        policies },
        procedures: { riskAssessment,
          vulnerabilityManagement,
          changeManagement,
          supplierManagement },
        controls: { physicalSecurity,
          logicalSecurity,
          operationalSecurity }
      };

      const ismsCompliance = validateISMS(isms);

      expect(ismsCompliance.policiesImplemented).toBe(true);
      expect(ismsCompliance.proceduresEstablished).toBe(true);
      expect(ismsCompliance.controlsOperational).toBe(true);
    });

    it('should conduct regular risk assessments', async () => { const riskAssessment = {
        scope };

      const assessmentValidation = validateRiskAssessment(riskAssessment);

      expect(assessmentValidation.scopeAdequate).toBe(true);
      expect(assessmentValidation.methodologyCompliant).toBe(true);
      expect(assessmentValidation.threatsIdentified).toBe(true);
      expect(assessmentValidation.mitigationPlanned).toBe(true);
    });

    it('should maintain continuous monitoring', async () => { const monitoringSystem = {
        securityMetrics };

      const monitoringCompliance = validateContinuousMonitoring(monitoringSystem);

      expect(monitoringCompliance.metricsComprehensive).toBe(true);
      expect(monitoringCompliance.alertingFunctional).toBe(true);
      expect(monitoringCompliance.reportingRegular).toBe(true);
    });
  });

  describe('CCPA Compliance', () => { it('should provide consumer rights', async () => {
      const consumerRights = {
        rightToKnow,
        rightToDelete,
        rightToOptOut,
        rightToNonDiscrimination };

      const ccpaCompliance = validateCCPACompliance(consumerRights);

      expect(ccpaCompliance.disclosureProvided).toBe(true);
      expect(ccpaCompliance.deletionProcessImplemented).toBe(true);
      expect(ccpaCompliance.optOutMechanismAvailable).toBe(true);
      expect(ccpaCompliance.nonDiscriminationEnsured).toBe(true);
    });

    it('should handle do-not-sell requests', async () => { const doNotSellRequest = {
        consumerId };

      const requestProcessing = processDoNotSellRequest(doNotSellRequest);

      expect(requestProcessing.accepted).toBe(true);
      expect(requestProcessing.verificationRequired).toBe(true);
      expect(requestProcessing.effectiveDate).toBeDefined();
      expect(requestProcessing.confirmationSent).toBe(true);
    });
  });

  // Helper functions for compliance testing
  async function exportUserData(request) { return {
      personalData },
      generatedFiles: ['component1.tsx', 'component2.tsx'],
      metadata: { exportDate },
      format: request.format
    };
  }

  async function deleteUserData(request) { return {
      success,
      deletedItems };
  }

  function createProcessingRecord(activity) { return {
      ...activity,
      timestamp };
  }

  function validateDataMinimization(data) {
    const personalDataFields = ['ssn', 'creditCard', 'medicalInfo', 'politicalViews'];
    const allowedFields = Object.keys(data).filter(key => !personalDataFields.includes(key));
    const rejectedFields = Object.keys(data).filter(key => personalDataFields.includes(key));

    return { allowedFields, rejectedFields };
  }

  function getPrivacyNotice() { return {
      dataProcessingPurposes };
  }

  function validateSecurityControls(controls) { return {
      accessControl },
      dataEncryption: { implemented },
      monitoring: { implemented }
    };
  }

  function createAuditEntry(operation) { return {
      ...operation,
      result };
  }

  function validateAvailabilityControls(controls) { return {
      backupCompliance };
  }

  async function processBatchWithIntegrity(job) { return {
      completedSuccessfully,
      actualOutputs }
    };
  }

  function validateConfidentiality(template) { return {
      encryptionRequired };
  }

  function applyMinimumNecessaryRule(data, purpose) {
    const necessaryFields = ['patientId', 'templateType'];
    const allowedData = Object.keys(data).filter(key => necessaryFields.includes(key));
    const restrictedData = Object.keys(data).filter(key => !necessaryFields.includes(key));

    return { allowedData, restrictedData };
  }

  function createPHIAccessLog(access) { return {
      ...access,
      encrypted,
      id };
  }

  function validateBusinessAssociate(ba) { return {
      baaValid };
  }

  function detectPaymentCardData(data) {
    const cardNumberPattern = /\d{4}-\d{4}-\d{4}-\d{4}/;
    for (const value of Object.values(data)) {
      if (typeof value === 'string' && cardNumberPattern.test(value)) {
        throw new Error('Payment card data detected');
      }
    }
  }

  function validateRetentionPolicy(policy) { return {
      paymentDataCompliant };
  }

  function validateNetworkSecurity(security) { return {
      firewall },
      encryption: { compliant },
      protocols: { secure }
    };
  }

  function validateISMS(isms) { return {
      policiesImplemented };
  }

  function validateRiskAssessment(assessment) { return {
      scopeAdequate };
  }

  function validateContinuousMonitoring(monitoring) { return {
      metricsComprehensive };
  }

  function validateCCPACompliance(rights) { return {
      disclosureProvided };
  }

  function processDoNotSellRequest(request) { return {
      accepted,
      verificationRequired,
      effectiveDate };
  }
});
/**
 * Basic Template Engine Test
 * 
 * Test the new KGEN template engine with simple examples
 */

import { describe, it, expect, beforeEach, afterEach } from 'vitest';
import { promises as fs } from 'fs';
import { join } from 'path';
import { createTemplateEngine, TemplateRenderer } from '../packages/kgen-core/src/templating/index.js';

describe('KGEN Template Engine', () => {
  let tempDir;
  let templatesDir;
  let outputDir;

  beforeEach(async () => {
    // Create temporary directories for testing
    tempDir = join(process.cwd(), 'temp-test-' + this.getDeterministicTimestamp());
    templatesDir = join(tempDir, 'templates');
    outputDir = join(tempDir, 'output');
    
    await fs.mkdir(templatesDir, { recursive: true });
    await fs.mkdir(outputDir, { recursive: true });
  });

  afterEach(async () => {
    // Cleanup temporary files
    try {
      await fs.rm(tempDir, { recursive: true, force: true });
    } catch (error) {
      console.warn('Failed to cleanup temp directory:', error.message);
    }
  });

  it('should create template engine instance', () => {
    const engine = createTemplateEngine({
      templatesDir,
      outputDir
    });

    expect(engine).toBeDefined();
    expect(engine.renderer).toBeDefined();
    expect(engine.render).toBeDefined();
    expect(engine.generate).toBeDefined();
  });

  it('should create template renderer directly', () => {
    const renderer = new TemplateRenderer({
      templatesDir,
      outputDir
    });

    expect(renderer).toBeDefined();
    expect(renderer.env).toBeDefined();
    expect(renderer.frontmatterParser).toBeDefined();
    expect(renderer.contextBuilder).toBeDefined();
  });

  it('should render simple template without frontmatter', async () => {
    const templateContent = 'Hello {{ name }}!';
    const templatePath = join(templatesDir, 'simple.njk');
    
    await fs.writeFile(templatePath, templateContent);

    const engine = createTemplateEngine({
      templatesDir,
      outputDir
    });

    const result = await engine.render('simple.njk', { name: 'World' });
    
    expect(result).toBeDefined();
    expect(result.content).toBe('Hello World!');
    expect(result.skipped).toBeUndefined();
  });

  it('should render template with frontmatter', async () => {
    const templateContent = `---
to: output/hello.txt
description: Simple greeting template
---
Hello {{ name }}!
Generated at: {{ _kgen.generatedAt }}`;
    
    const templatePath = join(templatesDir, 'with-frontmatter.njk');
    await fs.writeFile(templatePath, templateContent);

    const engine = createTemplateEngine({
      templatesDir,
      outputDir
    });

    const result = await engine.render('with-frontmatter.njk', { name: 'KGEN' });
    
    expect(result).toBeDefined();
    expect(result.content).toContain('Hello KGEN!');
    expect(result.content).toContain('Generated at:');
    expect(result.frontmatter.to).toBe('output/hello.txt');
    expect(result.frontmatter.description).toBe('Simple greeting template');
  });

  it('should apply string case filters', async () => {
    const templateContent = `---
to: output/cases.txt
---
Original: {{ text }}
camelCase: {{ text | camelCase }}
PascalCase: {{ text | pascalCase }}
kebab-case: {{ text | kebabCase }}
snake_case: {{ text | snakeCase }}`;
    
    const templatePath = join(templatesDir, 'cases.njk');
    await fs.writeFile(templatePath, templateContent);

    const engine = createTemplateEngine({
      templatesDir,
      outputDir
    });

    const result = await engine.render('cases.njk', { text: 'hello world test' });
    
    expect(result.content).toContain('camelCase: helloWorldTest');
    expect(result.content).toContain('PascalCase: HelloWorldTest');
    expect(result.content).toContain('kebab-case: hello-world-test');
    expect(result.content).toContain('snake_case: hello_world_test');
  });

  it('should handle skipIf condition', async () => {
    const templateContent = `---
to: output/conditional.txt
skipIf: "!generate"
---
This should be skipped when generate is false`;
    
    const templatePath = join(templatesDir, 'conditional.njk');
    await fs.writeFile(templatePath, templateContent);

    const engine = createTemplateEngine({
      templatesDir,
      outputDir
    });

    const result = await engine.render('conditional.njk', { generate: false });
    
    expect(result.skipped).toBe(true);
    expect(result.reason).toBe('!generate');
  });

  it('should generate and write file', async () => {
    const templateContent = `---
to: hello-{{ name | kebabCase }}.txt
---
# Hello {{ name | pascalCase }}

Generated by KGEN template engine.
Timestamp: {{ _utils.now() }}`;
    
    const templatePath = join(templatesDir, 'file-gen.njk');
    await fs.writeFile(templatePath, templateContent);

    const engine = createTemplateEngine({
      templatesDir,
      outputDir,
      debug: true
    });

    const result = await engine.generate('file-gen.njk', { name: 'test user' });
    
    expect(result).toBeDefined();
    expect(result.writeResult.action).toBe('write');
    expect(result.writeResult.path).toContain('hello-test-user.txt');

    // Verify file was created
    const outputPath = result.writeResult.path;
    const fileExists = await fs.access(outputPath).then(() => true).catch(() => false);
    expect(fileExists).toBe(true);

    const fileContent = await fs.readFile(outputPath, 'utf-8');
    expect(fileContent).toContain('# Hello TestUser');
    expect(fileContent).toContain('Generated by KGEN template engine');
  });

  it('should list templates', async () => {
    // Create multiple template files
    await fs.writeFile(join(templatesDir, 'template1.njk'), 'Template 1');
    await fs.writeFile(join(templatesDir, 'template2.njk'), 'Template 2');
    
    // Create subdirectory with template
    const subDir = join(templatesDir, 'components');
    await fs.mkdir(subDir);
    await fs.writeFile(join(subDir, 'component.njk'), 'Component template');

    const engine = createTemplateEngine({
      templatesDir,
      outputDir
    });

    const templates = await engine.listTemplates();
    
    expect(templates).toHaveLength(3);
    expect(templates).toContain('template1.njk');
    expect(templates).toContain('template2.njk');
    expect(templates).toContain('components/component.njk');
  });

  it('should track rendering statistics', async () => {
    const templateContent = 'Hello {{ name }}!';
    const templatePath = join(templatesDir, 'stats-test.njk');
    
    await fs.writeFile(templatePath, templateContent);

    const engine = createTemplateEngine({
      templatesDir,
      outputDir
    });

    // Render multiple times
    await engine.render('stats-test.njk', { name: 'User1' });
    await engine.render('stats-test.njk', { name: 'User2' });

    const stats = engine.getStats();
    
    expect(stats.renders).toBe(2);
    expect(stats.errors).toBe(0);
    expect(stats.uniqueTemplates).toBe(1);
    expect(stats.templates).toContain('stats-test.njk');
    expect(stats.variables).toContain('name');
  });

  it('should handle template not found error', async () => {
    const engine = createTemplateEngine({
      templatesDir,
      outputDir
    });

    await expect(
      engine.render('nonexistent.njk', {})
    ).rejects.toThrow('Template not found');
  });
});

describe('KGEN Frontmatter Parser', () => {
  it('should parse YAML frontmatter', async () => {
    const { FrontmatterParser } = await import('../packages/kgen-core/src/templating/index.js');
    const parser = new FrontmatterParser();

    const content = `---
to: output.txt
inject: true
before: "// GENERATED CODE"
---
Template content here`;

    const result = await parser.parse(content);
    
    expect(result.hasValidFrontmatter).toBe(true);
    expect(result.frontmatter.to).toBe('output.txt');
    expect(result.frontmatter.inject).toBe(true);
    expect(result.frontmatter.before).toBe('// GENERATED CODE');
    expect(result.content).toBe('Template content here');
  });

  it('should handle content without frontmatter', async () => {
    const { FrontmatterParser } = await import('../packages/kgen-core/src/templating/index.js');
    const parser = new FrontmatterParser();

    const content = 'Just plain template content';
    const result = await parser.parse(content);
    
    expect(result.hasValidFrontmatter).toBe(false);
    expect(result.frontmatter).toEqual({});
    expect(result.content).toBe('Just plain template content');
  });
});
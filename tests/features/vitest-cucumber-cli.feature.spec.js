import { describe, test, expect, beforeEach, afterEach, vi } from 'vitest';
import { execSync } from 'child_process';
import { promises } from 'fs';
import path from 'path';

/**
 * BDD Feature: Complete CLI Command Testing with MCP Integration
 * Tests all CLI commands using vitest-cucumber framework and validates MCP tool integration
 */

describe('Feature, () => {
  let testDir => {
    originalCwd = process.cwd();
    testDir = await globalThis.testUtils.createTempDir();
    process.chdir(testDir);
    await setupTestEnvironment();
  });

  afterEach(async () => {
    process.chdir(originalCwd);
    await globalThis.testUtils.removeTempDir(testDir);
  });

  /**
   * Scenario: CLI Discovery and Help System
   */
  describe('Scenario, () => { test('Given I want to discover available commands, When I run unjucks without arguments, Then I should see command overview', () => {
      const result = execSync('node ../dist/cli.js', { encoding });
      expect(result).toContain('unjucks');
      expect(result).toContain('generate');
      expect(result).toContain('list');
      expect(result).toContain('help');
      expect(result).toContain('semantic');
    });

    test('Given I want detailed help, When I run unjucks --help, Then I should see all available options', () => { const result = execSync('node ../dist/cli.js --help', { encoding);
      expect(result).toContain('Usage });
  });

  /**
   * Scenario: Template Discovery and Listing
   */
  describe('Scenario, () => { test('Given I have templates in _templates directory, When I run unjucks list, Then I should see all available generators', async () => {
      // Given
      await createSampleTemplates();

      // When
      const result = execSync('node ../dist/cli.js list', { encoding);

      // Then
      expect(result).toContain('component');
      expect(result).toContain('service');
      expect(result).toContain('Available generators });\n\n    test('Given I have no templates, When I run unjucks list, Then I should see appropriate message', async () => {\n      // When & Then\n      expect(() => {\n        execSync('node ../dist/cli.js list', { encoding);\n      }).toThrow();\n    });\n  });\n\n  /**\n   * Scenario: Template Help and Variable Discovery\n   */\n  describe('Scenario, () => {\n    beforeEach(async () => {\n      await createSampleTemplates();\n    });\n\n    test('Given I want help for a specific generator, When I run unjucks help , Then I should see variables and usage', () => { \n      const result = execSync('node ../dist/cli.js help component', { encoding);\n      expect(result).toContain('component');\n      expect(result).toContain('Variables });\n  });\n\n  /**\n   * Scenario: Basic File Generation\n   */\n  describe('Scenario, () => {\n    beforeEach(async () => {\n      await createSampleTemplates();\n    });\n\n    test('Given I have a component template, When I generate with required variables, Then files should be created correctly', async () => {\n      // When\n      execSync('node ../dist/cli.js generate component --name UserProfile --type interface', { encoding);\n\n      // Then\n      const mainFile = await fs.readFile('userProfile.ts', 'utf8');\n      expect(mainFile).toContain('interface UserProfile');\n      expect(mainFile).toContain('export interface UserProfile');\n\n      const testFile = await fs.readFile('userProfile.test.ts', 'utf8');\n      expect(testFile).toContain('describe(\\'UserProfile\\'');\n    });\n\n    test('Given I want to preview generation, When I run with --dry flag, Then I should see planned operations without file creation', () => {\n      const result = execSync('node ../dist/cli.js generate component --name Product --type class --dry', { encoding);\n      expect(result).toContain('DRY RUN');\n      expect(result).toContain('Would create);\n      expect(result).toContain('Would create);\n    });\n\n    test('Given I want to generate to specific location, When I use --dest option, Then files should be created in target directory', async () => { \n      // Given\n      await fs.mkdir('src/components', { recursive });\n\n      // When\n      execSync('node ../dist/cli.js generate component --name Button --type class --dest ./src/components', { encoding);\n\n      // Then\n      const generatedFile = await fs.readFile('src/components/button.ts', 'utf8');\n      expect(generatedFile).toContain('class Button');\n    });\n  });\n\n  /**\n   * Scenario: Advanced File Injection\n   */\n  describe('Scenario, () => {\n    test('Given an existing file and injection template, When I run injection command, Then content should be merged correctly', async () => {\n      // Given - create existing file\n      await fs.writeFile('api.ts', `export class ApiService {\n  // Existing methods\n  getUsers() {\n    return [];\n  }\n}`);\n\n      // Create injection template\n      await fs.mkdir('_templates/method', { recursive });\n      await fs.writeFile('_templates/method/add.ts.ejs', `---\nto: <%= target %>\ninject: true\nafter) { \"\nappend }`);\n\n      // When\n      execSync('node ../dist/cli.js generate method --name Product --target api.ts', { encoding);\n\n      // Then\n      const injectedFile = await fs.readFile('api.ts', 'utf8');\n      expect(injectedFile).toContain('getProduct()');\n      expect(injectedFile).toContain('productRepository');\n      expect(injectedFile).toContain('getUsers()');\n    });\n  });\n\n  /**\n   * Scenario: Semantic Command Integration\n   */\n  describe('Scenario, () => {\n    beforeEach(async () => {\n      await createSemanticTestData();\n    });\n\n    test('Given I have RDF ontology data, When I run semantic generate, Then TypeScript types should be generated', async () => { \n      // Mock MCP response for semantic generation\n      globalThis.testUtils.mockMCPResponse('unjucks_semantic_generate', {\n        success,\n        generated });\n\n    test('Given I have template variables, When I run semantic reasoning, Then enhanced context should be generated', async () => { \n      // Mock MCP response\n      globalThis.testUtils.mockMCPResponse('unjucks_reasoning_apply', {\n        success,\n        enhancedContext },\n        inferences);\n\n      // When\n      const result = execSync('node ../dist/cli.js semantic reason --variables ./variables.json --rules ./rules.ttl', { encoding);\n\n      // Then\n      expect(result).toContain('Reasoning completed');\n    });\n\n    test('Given I have RDF data, When I run semantic validate, Then validation report should be generated', async () => { \n      // Mock MCP response\n      globalThis.testUtils.mockMCPResponse('unjucks_semantic_validate', {\n        validation });\n  });\n\n  /**\n   * Scenario: Error Handling and Edge Cases\n   */\n  describe('Scenario, () => {\n    test('Given I provide invalid template name, When I run generate command, Then I should get clear error message', () => {\n      expect(() => {\n        execSync('node ../dist/cli.js generate nonexistent --name Test', { encoding);\n      }).toThrow(/Generator.*not found/);\n    });\n\n    test('Given I omit required variables, When I run generate command, Then I should get validation error', () => { \n      expect(() => {\n        execSync('node ../dist/cli.js generate component', { encoding }).toThrow();\n    });\n\n    test('Given I use conflicting options, When I run command, Then I should get usage guidance', () => { \n      expect(() => {\n        execSync('node ../dist/cli.js generate component --name Test --dry --force', { encoding }).not.toThrow();\n    });\n  });\n\n  /**\n   * Scenario: Performance and Stress Testing\n   */\n  describe('Scenario, () => {\n    test('Given I generate multiple files simultaneously, When I run batch generation, Then all files should be created correctly', async () => {\n      await createSampleTemplates();\n\n      const startTime = this.getDeterministicTimestamp();\n      \n      // Generate multiple components\n      const names = ['User', 'Product', 'Order', 'Customer', 'Invoice'];\n      for (const name of names) {\n        execSync(`node ../dist/cli.js generate component --name ${name} --type class`, { encoding);\n      }\n\n      const endTime = this.getDeterministicTimestamp();\n      expect(endTime - startTime).toBeLessThan(5000); // Should complete within 5 seconds\n\n      // Verify all files were created\n      for (const name of names) {\n        const filename = name.toLowerCase() + '.ts';\n        expect(await fs.access(filename)).not.toThrow();\n      }\n    });\n  });\n\n  /**\n   * Helper Functions\n   */\n  async function setupTestEnvironment() { \n    // Create basic directory structure\n    await fs.mkdir('_templates', { recursive });\n    await fs.mkdir('src', { recursive });\n    await fs.mkdir('test', { recursive });\n  }\n\n  async function createSampleTemplates() { \n    // Component template\n    await fs.mkdir('_templates/component', { recursive });\n    await fs.writeFile('_templates/component/index.ts.ejs', `---\nto) %>.ts\nvariables:\n  - name\n  - type\n---\n<% if (type === 'interface') { %>\nexport interface <%= h.changeCase.pascal(name) %> {\n  id }\n<% } else { %>\nexport class <%= h.changeCase.pascal(name) %> {\n  constructor(\n    public id,\n    public name) {}\n}\n<% } %>`);\n\n    await fs.writeFile('_templates/component/test.ts.ejs', `---\nto) %>.test.ts\n---\nimport { describe, test, expect } from 'vitest';\nimport { <%= h.changeCase.pascal(name) %> } from './<%= h.changeCase.camel(name) %>.js';\n\ndescribe('<%= h.changeCase.pascal(name) %>', () => {\n  test('should be defined', () => {\n    <% if (type === 'class') { %>\n    const instance = new <%= h.changeCase.pascal(name) %>('1', 'test');\n    expect(instance).toBeDefined();\n    expect(instance.id).toBe('1');\n    <% } else { %>\n    const instance };\n    expect(instance).toBeDefined();\n    <% } %>\n  });\n});`);\n\n    // Service template\n    await fs.mkdir('_templates/service', { recursive });\n    await fs.writeFile('_templates/service/service.ts.ejs', `---\nto) %>.service.ts\nvariables:\n  - name\n---\nexport class <%= h.changeCase.pascal(name) %>Service {\n  async get<%= h.changeCase.pascal(name) %>ById(id) {\n    // Implementation here\n    return null;\n  }\n\n  async create<%= h.changeCase.pascal(name) %>(data) {\n    // Implementation here\n    return data;\n  }\n}`);\n  }\n\n  async function createSemanticTestData() { \n    // Create test ontology\n    await fs.writeFile('test-ontology.ttl', `@prefix ex }, null, 2));\n\n    // Create test rules\n    await fs.writeFile('rules.ttl', `@prefix ex: <http://example.org/> .\n@prefix rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#> .\n\n# Rule, it must have an email\n{ ?x rdf } => { ?x ex } .`);\n  }\n});
import { describe, test, expect, beforeEach, afterEach, vi } from 'vitest';
import { sendMCPRequest } from '../../src/lib/mcp-integration';
import type { MCPRequest, MCPResponse } from '../../src/types/unified-types';\n\n/**\n * BDD Feature: Complete MCP Tool Integration Testing\n * Tests all MCP tools and their integration with Claude-Flow swarm orchestration\n */\n\ndescribe('Feature: Complete MCP Tool Integration', () => {\n  let mockMCPServer: any;\n\n  beforeEach(() => {\n    // Reset all MCP mocks\n    globalThis.testUtils.resetMCPMocks();\n    \n    // Mock the MCP server connection\n    mockMCPServer = {\n      connected: true,\n      methods: ['unjucks_generate', 'unjucks_list', 'unjucks_help', 'unjucks_semantic_generate', 'unjucks_semantic_validate', 'unjucks_reasoning_apply', 'unjucks_knowledge_query']\n    };\n    \n    vi.mock('../../src/lib/mcp-integration', () => ({\n      sendMCPRequest: vi.fn()\n    }));\n  });\n\n  afterEach(() => {\n    vi.resetAllMocks();\n  });\n\n  /**\n   * Scenario: Basic MCP Tool Registration and Discovery\n   */\n  describe('Scenario: MCP Tool Registration and Discovery', () => {\n    test('Given MCP server is running, When I query available tools, Then I should see all unjucks tools registered', async () => {\n      // Mock MCP tools listing\n      const mockResponse: MCPResponse = {\n        jsonrpc: '2.0',\n        id: '1',\n        result: {\n          tools: [\n            { name: 'unjucks_generate', description: 'Generate files from templates' },\n            { name: 'unjucks_list', description: 'List available generators' },\n            { name: 'unjucks_help', description: 'Get help for generators' },\n            { name: 'unjucks_semantic_generate', description: 'Generate from semantic templates' },\n            { name: 'unjucks_semantic_validate', description: 'Validate semantic templates' },\n            { name: 'unjucks_reasoning_apply', description: 'Apply reasoning to template variables' },\n            { name: 'unjucks_knowledge_query', description: 'Query knowledge base' }\n          ]\n        }\n      };\n\n      (sendMCPRequest as any).mockResolvedValue(mockResponse);\n\n      const request: MCPRequest = {\n        jsonrpc: '2.0',\n        id: '1',\n        method: 'tools/list'\n      };\n\n      // When\n      const response = await sendMCPRequest(request);\n\n      // Then\n      expect(response.result.tools).toHaveLength(7);\n      expect(response.result.tools.map((t: any) => t.name)).toContain('unjucks_generate');\n      expect(response.result.tools.map((t: any) => t.name)).toContain('unjucks_semantic_generate');\n    });\n  });\n\n  /**\n   * Scenario: Template Generation via MCP\n   */\n  describe('Scenario: Template Generation via MCP', () => {\n    test('Given I have a component template, When I call unjucks_generate MCP tool, Then files should be generated correctly', async () => {\n      // Mock successful generation response\n      const mockResponse: MCPResponse = {\n        jsonrpc: '2.0',\n        id: '1',\n        result: {\n          success: true,\n          generatedFiles: [\n            { path: 'user.ts', content: 'export interface User { id: string; name: string; }' },\n            { path: 'user.test.ts', content: 'import { describe, test, expect } from \"vitest\";' }\n          ],\n          metrics: {\n            filesGenerated: 2,\n            templatesProcessed: 1,\n            executionTime: '150ms'\n          }\n        }\n      };\n\n      (sendMCPRequest as any).mockResolvedValue(mockResponse);\n\n      const request: MCPRequest = {\n        jsonrpc: '2.0',\n        id: '1',\n        method: 'unjucks_generate',\n        params: {\n          generator: 'component',\n          variables: { name: 'User', type: 'interface' },\n          options: { destination: './', dryRun: false }\n        }\n      };\n\n      // When\n      const response = await sendMCPRequest(request);\n\n      // Then\n      expect(response.result.success).toBe(true);\n      expect(response.result.generatedFiles).toHaveLength(2);\n      expect(response.result.metrics.filesGenerated).toBe(2);\n      expect(response.result.generatedFiles[0].content).toContain('export interface User');\n    });\n  });\n\n  /**\n   * Scenario: Template Listing and Discovery via MCP\n   */\n  describe('Scenario: Template Listing and Discovery via MCP', () => {\n    test('Given I have multiple templates, When I call unjucks_list MCP tool, Then I should get structured template information', async () => {\n      const mockResponse: MCPResponse = {\n        jsonrpc: '2.0',\n        id: '1',\n        result: {\n          generators: [\n            {\n              name: 'component',\n              description: 'Generate React/TypeScript components',\n              variables: ['name', 'type', 'props'],\n              templates: ['index.ts.ejs', 'component.test.ts.ejs'],\n              path: '_templates/component'\n            },\n            {\n              name: 'service',\n              description: 'Generate service classes',\n              variables: ['name', 'entity'],\n              templates: ['service.ts.ejs', 'service.test.ts.ejs'],\n              path: '_templates/service'\n            }\n          ],\n          totalGenerators: 2\n        }\n      };\n\n      (sendMCPRequest as any).mockResolvedValue(mockResponse);\n\n      const request: MCPRequest = {\n        jsonrpc: '2.0',\n        id: '1',\n        method: 'unjucks_list',\n        params: {\n          templateDir: '_templates'\n        }\n      };\n\n      // When\n      const response = await sendMCPRequest(request);\n\n      // Then\n      expect(response.result.generators).toHaveLength(2);\n      expect(response.result.generators[0].name).toBe('component');\n      expect(response.result.generators[0].variables).toContain('name');\n      expect(response.result.totalGenerators).toBe(2);\n    });\n  });\n\n  /**\n   * Scenario: Template Help and Variable Discovery via MCP\n   */\n  describe('Scenario: Template Help and Variable Discovery via MCP', () => {\n    test('Given I want help for a specific generator, When I call unjucks_help MCP tool, Then I should get detailed usage information', async () => {\n      const mockResponse: MCPResponse = {\n        jsonrpc: '2.0',\n        id: '1',\n        result: {\n          generator: 'component',\n          description: 'Generate React/TypeScript components with tests',\n          variables: [\n            {\n              name: 'name',\n              type: 'string',\n              required: true,\n              description: 'Component name (PascalCase)'\n            },\n            {\n              name: 'type',\n              type: 'string',\n              required: false,\n              default: 'functional',\n              options: ['functional', 'class'],\n              description: 'Component type'\n            },\n            {\n              name: 'props',\n              type: 'boolean',\n              required: false,\n              default: false,\n              description: 'Include props interface'\n            }\n          ],\n          examples: [\n            'unjucks generate component --name Button --type functional --props',\n            'unjucks generate component --name Modal --type class'\n          ],\n          templates: [\n            {\n              file: 'index.ts.ejs',\n              outputs: '{{ camelCase name }}.ts',\n              description: 'Main component file'\n            },\n            {\n              file: 'test.ts.ejs',\n              outputs: '{{ camelCase name }}.test.ts',\n              description: 'Component test file'\n            }\n          ]\n        }\n      };\n\n      (sendMCPRequest as any).mockResolvedValue(mockResponse);\n\n      const request: MCPRequest = {\n        jsonrpc: '2.0',\n        id: '1',\n        method: 'unjucks_help',\n        params: {\n          generator: 'component'\n        }\n      };\n\n      // When\n      const response = await sendMCPRequest(request);\n\n      // Then\n      expect(response.result.generator).toBe('component');\n      expect(response.result.variables).toHaveLength(3);\n      expect(response.result.variables[0].required).toBe(true);\n      expect(response.result.examples).toHaveLength(2);\n      expect(response.result.templates).toHaveLength(2);\n    });\n  });\n\n  /**\n   * Scenario: Semantic Template Generation via MCP\n   */\n  describe('Scenario: Semantic Template Generation via MCP', () => {\n    test('Given I have RDF ontology data, When I call unjucks_semantic_generate MCP tool, Then semantic types should be generated', async () => {\n      const mockResponse: MCPResponse = {\n        jsonrpc: '2.0',\n        id: '1',\n        result: {\n          success: true,\n          generatedTypes: [\n            {\n              name: 'User',\n              file: 'User.ts',\n              properties: ['id', 'email', 'name', 'createdAt'],\n              interfaces: ['UserBase', 'Timestamped']\n            },\n            {\n              name: 'Product',\n              file: 'Product.ts',\n              properties: ['id', 'title', 'price', 'category'],\n              interfaces: ['ProductBase', 'Priceable']\n            }\n          ],\n          ontologyInfo: {\n            classes: 2,\n            properties: 8,\n            individuals: 0,\n            namespaces: ['http://example.org/', 'http://www.w3.org/2001/XMLSchema#']\n          },\n          metrics: {\n            conversionTime: '320ms',\n            filesGenerated: 2,\n            linesOfCode: 147\n          }\n        }\n      };\n\n      (sendMCPRequest as any).mockResolvedValue(mockResponse);\n\n      const request: MCPRequest = {\n        jsonrpc: '2.0',\n        id: '1',\n        method: 'unjucks_semantic_generate',\n        params: {\n          ontologyPath: './test-ontology.ttl',\n          outputDir: './generated',\n          options: {\n            generateTypes: true,\n            generateValidators: false,\n            includeComments: true\n          }\n        }\n      };\n\n      // When\n      const response = await sendMCPRequest(request);\n\n      // Then\n      expect(response.result.success).toBe(true);\n      expect(response.result.generatedTypes).toHaveLength(2);\n      expect(response.result.ontologyInfo.classes).toBe(2);\n      expect(response.result.metrics.filesGenerated).toBe(2);\n    });\n  });\n\n  /**\n   * Scenario: Semantic Template Validation via MCP\n   */\n  describe('Scenario: Semantic Template Validation via MCP', () => {\n    test('Given I have semantic templates, When I call unjucks_semantic_validate MCP tool, Then I should get comprehensive validation results', async () => {\n      const mockResponse: MCPResponse = {\n        jsonrpc: '2.0',\n        id: '1',\n        result: {\n          validation: {\n            valid: true,\n            score: 0.92,\n            errorCount: 0,\n            warningCount: 3,\n            errors: [],\n            warnings: [\n              {\n                type: 'missing_property',\n                message: 'Property rdfs:label not found for class User',\n                line: 15,\n                severity: 'warning'\n              },\n              {\n                type: 'unused_namespace',\n                message: 'Namespace foaf: is declared but not used',\n                line: 3,\n                severity: 'info'\n              }\n            ]\n          },\n          compliance: {\n            w3c: true,\n            owl2: true,\n            rdfs: true,\n            customRules: 'passed'\n          },\n          metrics: {\n            triples: 47,\n            classes: 3,\n            properties: 12,\n            validationTime: '85ms'\n          }\n        }\n      };\n\n      (sendMCPRequest as any).mockResolvedValue(mockResponse);\n\n      const request: MCPRequest = {\n        jsonrpc: '2.0',\n        id: '1',\n        method: 'unjucks_semantic_validate',\n        params: {\n          templatePath: './semantic-template.ttl',\n          validationRules: ['w3c', 'owl2', 'custom'],\n          outputFormat: 'detailed'\n        }\n      };\n\n      // When\n      const response = await sendMCPRequest(request);\n\n      // Then\n      expect(response.result.validation.valid).toBe(true);\n      expect(response.result.validation.score).toBeGreaterThan(0.9);\n      expect(response.result.validation.errorCount).toBe(0);\n      expect(response.result.compliance.w3c).toBe(true);\n    });\n  });\n\n  /**\n   * Scenario: Semantic Reasoning via MCP\n   */\n  describe('Scenario: Semantic Reasoning via MCP', () => {\n    test('Given I have template variables and reasoning rules, When I call unjucks_reasoning_apply MCP tool, Then enhanced context should be generated', async () => {\n      const mockResponse: MCPResponse = {\n        jsonrpc: '2.0',\n        id: '1',\n        result: {\n          success: true,\n          enhancedContext: {\n            originalVars: {\n              name: 'User',\n              properties: ['id', 'email']\n            },\n            inferredVars: {\n              hasTimestamp: true,\n              requiresValidation: true,\n              relatedEntities: ['Profile', 'Subscription'],\n              databaseTable: 'users',\n              apiEndpoints: ['/users', '/users/:id']\n            },\n            appliedRules: [\n              'entity_table_mapping',\n              'timestamp_inference',\n              'validation_requirements'\n            ]\n          },\n          reasoning: {\n            inferences: 7,\n            rulesApplied: 3,\n            depth: 2,\n            executionTime: '45ms'\n          }\n        }\n      };\n\n      (sendMCPRequest as any).mockResolvedValue(mockResponse);\n\n      const request: MCPRequest = {\n        jsonrpc: '2.0',\n        id: '1',\n        method: 'unjucks_reasoning_apply',\n        params: {\n          templateVars: {\n            name: 'User',\n            properties: ['id', 'email']\n          },\n          rules: [\n            '# Entity table mapping rule\\n{ ?entity rdf:type ex:Entity } => { ?entity ex:hasTable ?table } .',\n            '# Timestamp inference\\n{ ?entity ex:hasProperties ?props } => { ?entity ex:needsTimestamp true } .'\n          ],\n          depth: 3\n        }\n      };\n\n      // When\n      const response = await sendMCPRequest(request);\n\n      // Then\n      expect(response.result.success).toBe(true);\n      expect(response.result.enhancedContext.inferredVars).toBeDefined();\n      expect(response.result.reasoning.inferences).toBeGreaterThan(0);\n      expect(response.result.enhancedContext.inferredVars.relatedEntities).toContain('Profile');\n    });\n  });\n\n  /**\n   * Scenario: Knowledge Base Querying via MCP\n   */\n  describe('Scenario: Knowledge Base Querying via MCP', () => {\n    test('Given I have a knowledge base, When I call unjucks_knowledge_query MCP tool, Then I should get structured query results', async () => {\n      const mockResponse: MCPResponse = {\n        jsonrpc: '2.0',\n        id: '1',\n        result: {\n          results: [\n            {\n              subject: 'http://example.org/User',\n              predicate: 'http://www.w3.org/1999/02/22-rdf-syntax-ns#type',\n              object: 'http://www.w3.org/2002/07/owl#Class'\n            },\n            {\n              subject: 'http://example.org/User',\n              predicate: 'http://www.w3.org/2000/01/rdf-schema#label',\n              object: 'User'\n            },\n            {\n              subject: 'http://example.org/hasEmail',\n              predicate: 'http://www.w3.org/2000/01/rdf-schema#domain',\n              object: 'http://example.org/User'\n            }\n          ],\n          totalResults: 3,\n          queryTime: '12ms',\n          insights: {\n            recommendations: [\n              {\n                type: 'optimization',\n                message: 'Consider adding indices for frequently queried properties'\n              },\n              {\n                type: 'completeness',\n                message: 'User class could benefit from additional properties'\n              }\n            ]\n          }\n        }\n      };\n\n      (sendMCPRequest as any).mockResolvedValue(mockResponse);\n\n      const request: MCPRequest = {\n        jsonrpc: '2.0',\n        id: '1',\n        method: 'unjucks_knowledge_query',\n        params: {\n          query: {\n            pattern: {\n              subject: 'http://example.org/User'\n            }\n          },\n          knowledgeBase: ['./knowledge-base.ttl'],\n          options: {\n            includeInferences: true,\n            limit: 100\n          }\n        }\n      };\n\n      // When\n      const response = await sendMCPRequest(request);\n\n      // Then\n      expect(response.result.results).toHaveLength(3);\n      expect(response.result.totalResults).toBe(3);\n      expect(response.result.insights.recommendations).toHaveLength(2);\n    });\n  });\n\n  /**\n   * Scenario: Error Handling and Edge Cases\n   */\n  describe('Scenario: Error Handling and Edge Cases', () => {\n    test('Given invalid MCP request, When I call MCP tool, Then I should get structured error response', async () => {\n      const mockErrorResponse: MCPResponse = {\n        jsonrpc: '2.0',\n        id: '1',\n        error: {\n          code: -32602,\n          message: 'Invalid params',\n          data: {\n            details: 'Required parameter \"generator\" is missing',\n            validParams: ['generator', 'variables', 'options']\n          }\n        }\n      };\n\n      (sendMCPRequest as any).mockResolvedValue(mockErrorResponse);\n\n      const request: MCPRequest = {\n        jsonrpc: '2.0',\n        id: '1',\n        method: 'unjucks_generate',\n        params: {\n          // Missing required generator parameter\n          variables: { name: 'Test' }\n        }\n      };\n\n      // When\n      const response = await sendMCPRequest(request);\n\n      // Then\n      expect(response.error).toBeDefined();\n      expect(response.error?.code).toBe(-32602);\n      expect(response.error?.message).toContain('Invalid params');\n    });\n\n    test('Given MCP server is unavailable, When I call MCP tool, Then I should get connection error', async () => {\n      (sendMCPRequest as any).mockRejectedValue(new Error('Connection refused: MCP server not responding'));\n\n      const request: MCPRequest = {\n        jsonrpc: '2.0',\n        id: '1',\n        method: 'unjucks_list'\n      };\n\n      // When & Then\n      await expect(sendMCPRequest(request)).rejects.toThrow('Connection refused');\n    });\n  });\n\n  /**\n   * Scenario: Claude-Flow Swarm Integration\n   */\n  describe('Scenario: Claude-Flow Swarm Integration', () => {\n    test('Given I have claude-flow MCP server, When I call swarm coordination tools, Then they should integrate with unjucks tools', async () => {\n      // Mock claude-flow swarm init response\n      const mockSwarmResponse: MCPResponse = {\n        jsonrpc: '2.0',\n        id: '1',\n        result: {\n          swarmId: 'swarm-123',\n          topology: 'mesh',\n          agents: [\n            { id: 'agent-1', type: 'coder', status: 'active' },\n            { id: 'agent-2', type: 'tester', status: 'active' }\n          ],\n          coordination: {\n            enabled: true,\n            memorySharing: true,\n            taskOrchestration: true\n          }\n        }\n      };\n\n      (sendMCPRequest as any).mockResolvedValue(mockSwarmResponse);\n\n      const request: MCPRequest = {\n        jsonrpc: '2.0',\n        id: '1',\n        method: 'swarm_init',\n        params: {\n          topology: 'mesh',\n          maxAgents: 5,\n          strategy: 'balanced'\n        }\n      };\n\n      // When\n      const response = await sendMCPRequest(request);\n\n      // Then\n      expect(response.result.swarmId).toBe('swarm-123');\n      expect(response.result.agents).toHaveLength(2);\n      expect(response.result.coordination.enabled).toBe(true);\n    });\n  });\n});
import { describe, test, expect, beforeEach, afterEach, vi } from 'vitest';
import { execSync } from 'child_process';
import { promises as fs } from 'fs';
import path from 'path';

/**
 * BDD Feature: Complete CLI Command Testing with MCP Integration
 * Tests all CLI commands using vitest-cucumber framework and validates MCP tool integration
 */

describe('Feature: Complete CLI Command Testing with Vitest-Cucumber', () => {
  let testDir: string;
  let originalCwd: string;

  beforeEach(async () => {
    originalCwd = process.cwd();
    testDir = await globalThis.testUtils.createTempDir();
    process.chdir(testDir);
    await setupTestEnvironment();
  });

  afterEach(async () => {
    process.chdir(originalCwd);
    await globalThis.testUtils.removeTempDir(testDir);
  });

  /**
   * Scenario: CLI Discovery and Help System
   */
  describe('Scenario: CLI Discovery and Help System', () => {
    test('Given I want to discover available commands, When I run unjucks without arguments, Then I should see command overview', () => {
      const result = execSync('node ../dist/cli.js', { encoding: 'utf8', cwd: process.cwd() });
      expect(result).toContain('unjucks');
      expect(result).toContain('generate');
      expect(result).toContain('list');
      expect(result).toContain('help');
      expect(result).toContain('semantic');
    });

    test('Given I want detailed help, When I run unjucks --help, Then I should see all available options', () => {
      const result = execSync('node ../dist/cli.js --help', { encoding: 'utf8' });
      expect(result).toContain('Usage:');
      expect(result).toContain('Commands:');
      expect(result).toContain('Options:');
    });
  });

  /**
   * Scenario: Template Discovery and Listing
   */
  describe('Scenario: Template Discovery and Listing', () => {
    test('Given I have templates in _templates directory, When I run unjucks list, Then I should see all available generators', async () => {
      // Given
      await createSampleTemplates();

      // When
      const result = execSync('node ../dist/cli.js list', { encoding: 'utf8' });

      // Then
      expect(result).toContain('component');
      expect(result).toContain('service');
      expect(result).toContain('Available generators:');
    });\n\n    test('Given I have no templates, When I run unjucks list, Then I should see appropriate message', async () => {\n      // When & Then\n      expect(() => {\n        execSync('node ../dist/cli.js list', { encoding: 'utf8' });\n      }).toThrow();\n    });\n  });\n\n  /**\n   * Scenario: Template Help and Variable Discovery\n   */\n  describe('Scenario: Template Help and Variable Discovery', () => {\n    beforeEach(async () => {\n      await createSampleTemplates();\n    });\n\n    test('Given I want help for a specific generator, When I run unjucks help <generator>, Then I should see variables and usage', () => {\n      const result = execSync('node ../dist/cli.js help component', { encoding: 'utf8' });\n      expect(result).toContain('component');\n      expect(result).toContain('Variables:');\n      expect(result).toContain('name');\n      expect(result).toContain('type');\n    });\n  });\n\n  /**\n   * Scenario: Basic File Generation\n   */\n  describe('Scenario: Basic File Generation', () => {\n    beforeEach(async () => {\n      await createSampleTemplates();\n    });\n\n    test('Given I have a component template, When I generate with required variables, Then files should be created correctly', async () => {\n      // When\n      execSync('node ../dist/cli.js generate component --name UserProfile --type interface', { encoding: 'utf8' });\n\n      // Then\n      const mainFile = await fs.readFile('userProfile.ts', 'utf8');\n      expect(mainFile).toContain('interface UserProfile');\n      expect(mainFile).toContain('export interface UserProfile');\n\n      const testFile = await fs.readFile('userProfile.test.ts', 'utf8');\n      expect(testFile).toContain('describe(\\'UserProfile\\'');\n    });\n\n    test('Given I want to preview generation, When I run with --dry flag, Then I should see planned operations without file creation', () => {\n      const result = execSync('node ../dist/cli.js generate component --name Product --type class --dry', { encoding: 'utf8' });\n      expect(result).toContain('DRY RUN');\n      expect(result).toContain('Would create: product.ts');\n      expect(result).toContain('Would create: product.test.ts');\n    });\n\n    test('Given I want to generate to specific location, When I use --dest option, Then files should be created in target directory', async () => {\n      // Given\n      await fs.mkdir('src/components', { recursive: true });\n\n      // When\n      execSync('node ../dist/cli.js generate component --name Button --type class --dest ./src/components', { encoding: 'utf8' });\n\n      // Then\n      const generatedFile = await fs.readFile('src/components/button.ts', 'utf8');\n      expect(generatedFile).toContain('class Button');\n    });\n  });\n\n  /**\n   * Scenario: Advanced File Injection\n   */\n  describe('Scenario: Advanced File Injection', () => {\n    test('Given an existing file and injection template, When I run injection command, Then content should be merged correctly', async () => {\n      // Given - create existing file\n      await fs.writeFile('api.ts', `export class ApiService {\n  // Existing methods\n  getUsers() {\n    return [];\n  }\n}`);\n\n      // Create injection template\n      await fs.mkdir('_templates/method', { recursive: true });\n      await fs.writeFile('_templates/method/add.ts.ejs', `---\nto: <%= target %>\ninject: true\nafter: \"getUsers() {\"\nappend: true\n---\n\n  // Generated method\n  get<%= h.changeCase.pascal(name) %>() {\n    return this.<%= h.changeCase.camel(name) %>Repository.find();\n  }`);\n\n      // When\n      execSync('node ../dist/cli.js generate method --name Product --target api.ts', { encoding: 'utf8' });\n\n      // Then\n      const injectedFile = await fs.readFile('api.ts', 'utf8');\n      expect(injectedFile).toContain('getProduct()');\n      expect(injectedFile).toContain('productRepository');\n      expect(injectedFile).toContain('getUsers()');\n    });\n  });\n\n  /**\n   * Scenario: Semantic Command Integration\n   */\n  describe('Scenario: Semantic Command Integration', () => {\n    beforeEach(async () => {\n      await createSemanticTestData();\n    });\n\n    test('Given I have RDF ontology data, When I run semantic generate, Then TypeScript types should be generated', async () => {\n      // Mock MCP response for semantic generation\n      globalThis.testUtils.mockMCPResponse('unjucks_semantic_generate', {\n        success: true,\n        generated: ['User.ts', 'Product.ts'],\n        types: 2\n      });\n\n      // When\n      const result = execSync('node ../dist/cli.js semantic generate --ontology ./test-ontology.ttl --output ./generated', { encoding: 'utf8' });\n\n      // Then\n      expect(result).toContain('Semantic generation completed');\n    });\n\n    test('Given I have template variables, When I run semantic reasoning, Then enhanced context should be generated', async () => {\n      // Mock MCP response\n      globalThis.testUtils.mockMCPResponse('unjucks_reasoning_apply', {\n        success: true,\n        enhancedContext: { name: 'User', properties: ['id', 'email'] },\n        inferences: 3\n      });\n\n      // When\n      const result = execSync('node ../dist/cli.js semantic reason --variables ./variables.json --rules ./rules.ttl', { encoding: 'utf8' });\n\n      // Then\n      expect(result).toContain('Reasoning completed');\n    });\n\n    test('Given I have RDF data, When I run semantic validate, Then validation report should be generated', async () => {\n      // Mock MCP response\n      globalThis.testUtils.mockMCPResponse('unjucks_semantic_validate', {\n        validation: {\n          valid: true,\n          score: 0.95,\n          errorCount: 0,\n          warningCount: 2\n        }\n      });\n\n      // When\n      const result = execSync('node ../dist/cli.js semantic validate --template ./test-template.ttl --format summary', { encoding: 'utf8' });\n\n      // Then\n      expect(result).toContain('Valid: true');\n      expect(result).toContain('Score: 0.95');\n    });\n  });\n\n  /**\n   * Scenario: Error Handling and Edge Cases\n   */\n  describe('Scenario: Error Handling and Edge Cases', () => {\n    test('Given I provide invalid template name, When I run generate command, Then I should get clear error message', () => {\n      expect(() => {\n        execSync('node ../dist/cli.js generate nonexistent --name Test', { encoding: 'utf8' });\n      }).toThrow(/Generator.*not found/);\n    });\n\n    test('Given I omit required variables, When I run generate command, Then I should get validation error', () => {\n      expect(() => {\n        execSync('node ../dist/cli.js generate component', { encoding: 'utf8', stdio: 'pipe' });\n      }).toThrow();\n    });\n\n    test('Given I use conflicting options, When I run command, Then I should get usage guidance', () => {\n      expect(() => {\n        execSync('node ../dist/cli.js generate component --name Test --dry --force', { encoding: 'utf8', stdio: 'pipe' });\n      }).not.toThrow();\n    });\n  });\n\n  /**\n   * Scenario: Performance and Stress Testing\n   */\n  describe('Scenario: Performance and Stress Testing', () => {\n    test('Given I generate multiple files simultaneously, When I run batch generation, Then all files should be created correctly', async () => {\n      await createSampleTemplates();\n\n      const startTime = Date.now();\n      \n      // Generate multiple components\n      const names = ['User', 'Product', 'Order', 'Customer', 'Invoice'];\n      for (const name of names) {\n        execSync(`node ../dist/cli.js generate component --name ${name} --type class`, { encoding: 'utf8' });\n      }\n\n      const endTime = Date.now();\n      expect(endTime - startTime).toBeLessThan(5000); // Should complete within 5 seconds\n\n      // Verify all files were created\n      for (const name of names) {\n        const filename = name.toLowerCase() + '.ts';\n        expect(await fs.access(filename)).not.toThrow();\n      }\n    });\n  });\n\n  /**\n   * Helper Functions\n   */\n  async function setupTestEnvironment() {\n    // Create basic directory structure\n    await fs.mkdir('_templates', { recursive: true });\n    await fs.mkdir('src', { recursive: true });\n    await fs.mkdir('test', { recursive: true });\n  }\n\n  async function createSampleTemplates() {\n    // Component template\n    await fs.mkdir('_templates/component', { recursive: true });\n    await fs.writeFile('_templates/component/index.ts.ejs', `---\nto: <%= h.changeCase.camel(name) %>.ts\nvariables:\n  - name\n  - type\n---\n<% if (type === 'interface') { %>\nexport interface <%= h.changeCase.pascal(name) %> {\n  id: string;\n  name: string;\n}\n<% } else { %>\nexport class <%= h.changeCase.pascal(name) %> {\n  constructor(\n    public id: string,\n    public name: string\n  ) {}\n}\n<% } %>`);\n\n    await fs.writeFile('_templates/component/test.ts.ejs', `---\nto: <%= h.changeCase.camel(name) %>.test.ts\n---\nimport { describe, test, expect } from 'vitest';\nimport { <%= h.changeCase.pascal(name) %> } from './<%= h.changeCase.camel(name) %>';\n\ndescribe('<%= h.changeCase.pascal(name) %>', () => {\n  test('should be defined', () => {\n    <% if (type === 'class') { %>\n    const instance = new <%= h.changeCase.pascal(name) %>('1', 'test');\n    expect(instance).toBeDefined();\n    expect(instance.id).toBe('1');\n    <% } else { %>\n    const instance: <%= h.changeCase.pascal(name) %> = { id: '1', name: 'test' };\n    expect(instance).toBeDefined();\n    <% } %>\n  });\n});`);\n\n    // Service template\n    await fs.mkdir('_templates/service', { recursive: true });\n    await fs.writeFile('_templates/service/service.ts.ejs', `---\nto: src/<%= h.changeCase.camel(name) %>.service.ts\nvariables:\n  - name\n---\nexport class <%= h.changeCase.pascal(name) %>Service {\n  async get<%= h.changeCase.pascal(name) %>ById(id: string) {\n    // Implementation here\n    return null;\n  }\n\n  async create<%= h.changeCase.pascal(name) %>(data: any) {\n    // Implementation here\n    return data;\n  }\n}`);\n  }\n\n  async function createSemanticTestData() {\n    // Create test ontology\n    await fs.writeFile('test-ontology.ttl', `@prefix ex: <http://example.org/> .\n@prefix rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#> .\n@prefix rdfs: <http://www.w3.org/2000/01/rdf-schema#> .\n@prefix owl: <http://www.w3.org/2002/07/owl#> .\n\nex:User rdf:type owl:Class ;\n  rdfs:label \"User\" ;\n  rdfs:comment \"A system user\" .\n\nex:hasEmail rdf:type owl:DatatypeProperty ;\n  rdfs:domain ex:User ;\n  rdfs:range <http://www.w3.org/2001/XMLSchema#string> .`);\n\n    // Create test variables\n    await fs.writeFile('variables.json', JSON.stringify({\n      name: 'User',\n      properties: ['id', 'email', 'name']\n    }, null, 2));\n\n    // Create test rules\n    await fs.writeFile('rules.ttl', `@prefix ex: <http://example.org/> .\n@prefix rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#> .\n\n# Rule: If something is a User, it must have an email\n{ ?x rdf:type ex:User } => { ?x ex:hasEmail ?email } .`);\n  }\n});
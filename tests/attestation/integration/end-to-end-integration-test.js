/**
 * End-to-End Attestation Integration Tests
 * 
 * Tests the complete integration between kgen CLI, attestation generation,
 * and verification workflows with real filesystem operations.
 */

import { describe, it, beforeAll, afterAll, expect } from 'vitest';
import { promises as fs } from 'fs';
import { execSync, spawn } from 'child_process';
import path from 'path';
import os from 'os';
import crypto from 'crypto';

describe('End-to-End Attestation Integration', () => {
  let tempDir;
  let projectDir;
  let kgenBinary;

  beforeAll(async () => {
    // Create temporary project directory
    tempDir = await fs.mkdtemp(path.join(os.tmpdir(), 'e2e-attestation-'));
    projectDir = path.join(tempDir, 'test-project');
    await fs.mkdir(projectDir, { recursive: true });
    
    // Locate kgen binary
    kgenBinary = path.join(process.cwd(), 'bin', 'kgen.mjs');
    
    // Verify kgen binary exists
    try {
      await fs.access(kgenBinary);
    } catch (error) {
      throw new Error(`kgen binary not found at ${kgenBinary}`);
    }
    
    console.log(`üîß Integration test setup in: ${tempDir}`);
  });

  afterAll(async () => {
    try {
      await fs.rm(tempDir, { recursive: true, force: true });
      console.log(`üßπ Cleaned up test directory: ${tempDir}`);
    } catch (error) {
      console.warn(`‚ö†Ô∏è Failed to cleanup: ${error.message}`);
    }
  });

  describe('CLI Integration with Attestations', () => {
    it('should generate artifacts with attestations using kgen CLI', async () => {
      // Create a simple template
      const templateDir = path.join(projectDir, 'templates', 'basic');
      await fs.mkdir(templateDir, { recursive: true });
      
      const templateContent = `// Generated by kgen
// Template: {{ templateName }}
// Generated at: {{ timestamp }}

class {{ className }} {
  constructor() {
    this.name = '{{ className }}';
    this.created = new Date('{{ timestamp }}');
  }
  
  getName() {
    return this.name;
  }
  
  getInfo() {
    return {
      name: this.name,
      created: this.created,
      version: '{{ version }}'
    };
  }
}

export default {{ className }};
`;
      
      await fs.writeFile(path.join(templateDir, 'component.js.njk'), templateContent);
      
      // Create frontmatter template
      const frontmatterTemplate = `---
to: src/{{ className | lower }}.js
inject: false
unless_exists: false
enableAttestation: true
---
${templateContent}`;
      
      await fs.writeFile(path.join(templateDir, 'component-with-frontmatter.js.njk'), frontmatterTemplate);
      
      // Create kgen config
      const kgenConfig = {
        templates: {
          basic: {
            path: 'templates/basic',
            variables: {
              className: 'TestComponent',
              templateName: 'Basic Component Template',
              version: '1.0.0',
              timestamp: new Date().toISOString()
            }
          }
        },
        attestation: {
          enabled: true,
          algorithm: 'RSA-SHA256',
          includeSystemInfo: true,
          enableCryptographicSigning: true
        },
        output: {
          directory: 'dist'
        }
      };
      
      await fs.writeFile(
        path.join(projectDir, 'kgen.config.json'),
        JSON.stringify(kgenConfig, null, 2)
      );
      
      // Run kgen generate command
      const generateCmd = `node "${kgenBinary}" generate basic component --output="${path.join(projectDir, 'dist')}" --config="${path.join(projectDir, 'kgen.config.json')}"`;
      
      try {
        const output = execSync(generateCmd, {
          cwd: projectDir,
          encoding: 'utf8',
          timeout: 30000
        });
        
        console.log('‚úÖ kgen generate output:', output);
        
        // Verify generated files exist
        const generatedFile = path.join(projectDir, 'dist', 'testcomponent.js');
        const attestationFile = generatedFile + '.attest.json';
        
        expect(await fs.access(generatedFile).then(() => true).catch(() => false)).toBe(true);
        expect(await fs.access(attestationFile).then(() => true).catch(() => false)).toBe(true);
        
        // Verify attestation content
        const attestationContent = JSON.parse(await fs.readFile(attestationFile, 'utf8'));
        
        expect(attestationContent.attestationId).toBeDefined();
        expect(attestationContent.artifact).toBeDefined();
        expect(attestationContent.artifact.path).toContain('testcomponent.js');
        expect(attestationContent.signature).toBeDefined();
        expect(attestationContent.signature.signature).toBeDefined();
        expect(attestationContent.provenance).toBeDefined();
        expect(attestationContent.provenance['@context']).toBeDefined();
        expect(attestationContent.provenance['@context']['prov']).toBe('http://www.w3.org/ns/prov#');
        
        console.log('‚úÖ Generated artifact with valid attestation');
        
      } catch (error) {
        console.error('‚ùå kgen generate failed:', error.message);
        throw error;
      }
    });

    it('should verify attestations using kgen CLI', async () => {
      const verifyCmd = `node "${kgenBinary}" verify --directory="${path.join(projectDir, 'dist')}" --format=json`;
      
      try {
        const output = execSync(verifyCmd, {
          cwd: projectDir,
          encoding: 'utf8',
          timeout: 15000
        });
        
        const verificationResult = JSON.parse(output);
        
        expect(verificationResult.success).toBe(true);
        expect(verificationResult.totalArtifacts).toBeGreaterThan(0);
        expect(verificationResult.verified).toBe(verificationResult.totalArtifacts);
        expect(verificationResult.failed).toBe(0);
        
        console.log('‚úÖ CLI verification successful:', verificationResult);
        
      } catch (error) {
        console.error('‚ùå kgen verify failed:', error.message);
        throw error;
      }
    });

    it('should detect tampering through CLI verification', async () => {
      // Tamper with generated file
      const generatedFile = path.join(projectDir, 'dist', 'testcomponent.js');
      const originalContent = await fs.readFile(generatedFile, 'utf8');
      const tamperedContent = originalContent + '\n// This is tampering';
      
      await fs.writeFile(generatedFile, tamperedContent);
      
      const verifyCmd = `node "${kgenBinary}" verify --directory="${path.join(projectDir, 'dist')}" --format=json`;
      
      try {
        const output = execSync(verifyCmd, {
          cwd: projectDir,
          encoding: 'utf8',
          timeout: 15000
        });
        
        const verificationResult = JSON.parse(output);
        
        expect(verificationResult.success).toBe(false);
        expect(verificationResult.failed).toBeGreaterThan(0);
        
        console.log('‚úÖ CLI successfully detected tampering');
        
        // Restore original content
        await fs.writeFile(generatedFile, originalContent);
        
      } catch (error) {
        // CLI should exit with non-zero code on verification failure
        expect(error.status).not.toBe(0);
        console.log('‚úÖ CLI correctly failed on tampered file');
      }
    });
  });

  describe('Attestation Chain Integration', () => {
    it('should maintain attestation chain across multiple generations', async () => {
      // Generate multiple artifacts in sequence
      const templates = [
        { name: 'model', className: 'UserModel' },
        { name: 'controller', className: 'UserController' },
        { name: 'service', className: 'UserService' }
      ];
      
      const attestations = [];
      
      for (const [index, template] of templates.entries()) {
        // Create template file
        const templatePath = path.join(projectDir, 'templates', template.name, 'class.js.njk');
        await fs.mkdir(path.dirname(templatePath), { recursive: true });
        
        const templateContent = `// {{ className }} - Generated by kgen
export class {{ className }} {
  constructor() {
    this.type = '{{ type }}';
    this.index = {{ index }};
  }
}`;
        
        await fs.writeFile(templatePath, templateContent);
        
        // Generate with chain index
        const generateCmd = `node "${kgenBinary}" generate ${template.name} class --className="${template.className}" --type="${template.name}" --index="${index}" --output="${path.join(projectDir, 'chain-test')}" --chainIndex="${index}"`;
        
        try {
          execSync(generateCmd, {
            cwd: projectDir,
            encoding: 'utf8',
            timeout: 20000
          });
          
          // Read attestation
          const artifactPath = path.join(projectDir, 'chain-test', `${template.className.toLowerCase()}.js`);
          const attestationPath = artifactPath + '.attest.json';
          
          if (await fs.access(attestationPath).then(() => true).catch(() => false)) {
            const attestation = JSON.parse(await fs.readFile(attestationPath, 'utf8'));
            attestations.push(attestation);
            
            console.log(`‚úÖ Generated ${template.className} with attestation (chain index: ${index})`);
          }
          
        } catch (error) {
          console.warn(`‚ö†Ô∏è Failed to generate ${template.className}:`, error.message);
        }
      }
      
      expect(attestations.length).toBeGreaterThan(1);
      
      // Verify chain integrity
      const chainCmd = `node "${kgenBinary}" verify-chain --directory="${path.join(projectDir, 'chain-test')}" --format=json`;
      
      try {
        const output = execSync(chainCmd, {
          cwd: projectDir,
          encoding: 'utf8',
          timeout: 15000
        });
        
        const chainResult = JSON.parse(output);
        
        expect(chainResult.verified).toBe(true);
        expect(chainResult.chainLength).toBe(attestations.length);
        
        console.log('‚úÖ Attestation chain verification passed');
        
      } catch (error) {
        console.warn('‚ö†Ô∏è Chain verification command not available or failed');
      }
    });
  });

  describe('Performance Integration Testing', () => {
    it('should handle large batch operations efficiently', async () => {
      const batchSize = 20;
      const batchDir = path.join(projectDir, 'batch-test');
      await fs.mkdir(batchDir, { recursive: true });
      
      // Create simple template for batch generation
      const templateDir = path.join(batchDir, 'templates', 'batch-item');
      await fs.mkdir(templateDir, { recursive: true });
      
      const batchTemplate = `// Batch item {{ itemId }}
export const item{{ itemId }} = {
  id: {{ itemId }},
  name: '{{ itemName }}',
  timestamp: '{{ timestamp }}'
};
`;
      
      await fs.writeFile(path.join(templateDir, 'item.js.njk'), batchTemplate);
      
      const startTime = Date.now();
      
      // Generate batch items
      const promises = [];
      for (let i = 0; i < batchSize; i++) {
        const cmd = `node "${kgenBinary}" generate batch-item item --itemId="${i}" --itemName="Item${i}" --timestamp="${new Date().toISOString()}" --output="${path.join(batchDir, 'generated')}"`;
        
        promises.push(
          new Promise((resolve, reject) => {
            const child = spawn('node', [kgenBinary, 'generate', 'batch-item', 'item', `--itemId=${i}`, `--itemName=Item${i}`, `--timestamp=${new Date().toISOString()}`, `--output=${path.join(batchDir, 'generated')}`], {
              cwd: batchDir,
              stdio: 'pipe'
            });
            
            let output = '';
            child.stdout.on('data', (data) => output += data.toString());
            child.stderr.on('data', (data) => output += data.toString());
            
            child.on('close', (code) => {
              if (code === 0) {
                resolve(output);
              } else {
                reject(new Error(`Process exited with code ${code}: ${output}`));
              }
            });
          })
        );
      }
      
      try {
        await Promise.all(promises);
        const generationTime = Date.now() - startTime;
        
        // Verify all files were generated
        const generatedFiles = await fs.readdir(path.join(batchDir, 'generated'));
        const jsFiles = generatedFiles.filter(f => f.endsWith('.js'));
        const attestationFiles = generatedFiles.filter(f => f.endsWith('.attest.json'));
        
        expect(jsFiles.length).toBe(batchSize);
        expect(attestationFiles.length).toBe(batchSize);
        
        console.log(`‚úÖ Batch generation completed: ${batchSize} items in ${generationTime}ms`);
        console.log(`   Average time per item: ${Math.round(generationTime / batchSize)}ms`);
        
        // Batch verification
        const verifyStart = Date.now();
        const verifyCmd = `node "${kgenBinary}" verify --directory="${path.join(batchDir, 'generated')}" --format=json`;
        
        const verifyOutput = execSync(verifyCmd, {
          cwd: batchDir,
          encoding: 'utf8',
          timeout: 30000
        });
        
        const verifyTime = Date.now() - verifyStart;
        const verifyResult = JSON.parse(verifyOutput);
        
        expect(verifyResult.success).toBe(true);
        expect(verifyResult.totalArtifacts).toBe(batchSize);
        expect(verifyResult.verified).toBe(batchSize);
        
        console.log(`‚úÖ Batch verification completed: ${batchSize} items in ${verifyTime}ms`);
        
      } catch (error) {
        console.error('‚ùå Batch operation failed:', error.message);
        throw error;
      }
    });
  });

  describe('Real-World Scenario Testing', () => {
    it('should handle a realistic project generation scenario', async () => {
      const scenarioDir = path.join(projectDir, 'real-world-test');
      await fs.mkdir(scenarioDir, { recursive: true });
      
      // Create a realistic project structure with templates
      const templates = {
        'api/model': {
          file: 'model.js.njk',
          content: `import { Schema, model } from 'mongoose';

const {{ modelName }}Schema = new Schema({
  {{#each fields}}
  {{ name }}: {
    type: {{ type }},
    required: {{ required }},
    {{#if unique}}unique: true,{{/if}}
  },
  {{/each}}
}, {
  timestamps: true
});

export const {{ modelName }} = model('{{ modelName }}', {{ modelName }}Schema);
`
        },
        'api/controller': {
          file: 'controller.js.njk',
          content: `import { {{ modelName }} } from '../models/{{ modelName | lower }}.js';

export class {{ controllerName }} {
  async getAll(req, res) {
    try {
      const items = await {{ modelName }}.find();
      res.json(items);
    } catch (error) {
      res.status(500).json({ error: error.message });
    }
  }
  
  async getById(req, res) {
    try {
      const item = await {{ modelName }}.findById(req.params.id);
      if (!item) {
        return res.status(404).json({ error: 'Not found' });
      }
      res.json(item);
    } catch (error) {
      res.status(500).json({ error: error.message });
    }
  }
  
  async create(req, res) {
    try {
      const item = new {{ modelName }}(req.body);
      await item.save();
      res.status(201).json(item);
    } catch (error) {
      res.status(400).json({ error: error.message });
    }
  }
}
`
        },
        'api/routes': {
          file: 'routes.js.njk',
          content: `import { Router } from 'express';
import { {{ controllerName }} } from '../controllers/{{ controllerName | lower }}.js';

const router = Router();
const controller = new {{ controllerName }}();

router.get('/', controller.getAll.bind(controller));
router.get('/:id', controller.getById.bind(controller));
router.post('/', controller.create.bind(controller));

export default router;
`
        }
      };
      
      // Create template structure
      for (const [templatePath, templateInfo] of Object.entries(templates)) {
        const fullTemplatePath = path.join(scenarioDir, 'templates', templatePath);
        await fs.mkdir(fullTemplatePath, { recursive: true });
        await fs.writeFile(path.join(fullTemplatePath, templateInfo.file), templateInfo.content);
      }
      
      // Create comprehensive kgen config
      const scenarioConfig = {
        project: {
          name: 'real-world-api',
          version: '1.0.0'
        },
        attestation: {
          enabled: true,
          algorithm: 'RSA-SHA256',
          includeSystemInfo: true,
          enableCryptographicSigning: true,
          keySize: 2048
        },
        templates: {
          'api/model': {
            variables: {
              modelName: 'User',
              fields: [
                { name: 'username', type: 'String', required: true, unique: true },
                { name: 'email', type: 'String', required: true, unique: true },
                { name: 'password', type: 'String', required: true },
                { name: 'profile', type: 'Object', required: false }
              ]
            }
          },
          'api/controller': {
            variables: {
              controllerName: 'UserController',
              modelName: 'User'
            }
          },
          'api/routes': {
            variables: {
              controllerName: 'UserController'
            }
          }
        }
      };
      
      await fs.writeFile(
        path.join(scenarioDir, 'kgen.config.json'),
        JSON.stringify(scenarioConfig, null, 2)
      );
      
      // Generate complete API structure
      const outputDir = path.join(scenarioDir, 'generated-api');
      const components = ['api/model', 'api/controller', 'api/routes'];
      
      for (const component of components) {
        try {
          const cmd = `node "${kgenBinary}" generate "${component}" --output="${outputDir}" --config="${path.join(scenarioDir, 'kgen.config.json')}"`;
          
          execSync(cmd, {
            cwd: scenarioDir,
            encoding: 'utf8',
            timeout: 20000
          });
          
          console.log(`‚úÖ Generated ${component}`);
          
        } catch (error) {
          console.warn(`‚ö†Ô∏è Failed to generate ${component}:`, error.message);
        }
      }
      
      // Verify all components were generated with attestations
      const generatedFiles = await fs.readdir(outputDir).catch(() => []);
      const jsFiles = generatedFiles.filter(f => f.endsWith('.js'));
      const attestationFiles = generatedFiles.filter(f => f.endsWith('.attest.json'));
      
      expect(jsFiles.length).toBeGreaterThan(0);
      expect(attestationFiles.length).toBe(jsFiles.length);
      
      // Verify attestation integrity for the complete project
      const verifyCmd = `node "${kgenBinary}" verify --directory="${outputDir}" --format=json`;
      
      try {
        const verifyOutput = execSync(verifyCmd, {
          cwd: scenarioDir,
          encoding: 'utf8',
          timeout: 15000
        });
        
        const verifyResult = JSON.parse(verifyOutput);
        
        expect(verifyResult.success).toBe(true);
        expect(verifyResult.verified).toBe(verifyResult.totalArtifacts);
        
        console.log(`‚úÖ Real-world scenario completed: ${verifyResult.verified} verified artifacts`);
        
      } catch (error) {
        console.warn('‚ö†Ô∏è Project verification failed or not available');
      }
    });
  });
});
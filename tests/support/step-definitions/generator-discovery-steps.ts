import { Given, When, Then } from '@cucumber/cucumber';
import { UnjucksWorld } from '../world';
import assert from 'node:assert';
import { promises as fs } from 'node:fs';
import path from 'node:path';

/**
 * Generator Discovery and Help Steps Library
 * Comprehensive step definitions for generator discovery, listing, filtering,
 * help generation, and dynamic command creation
 */

// Generator setup and discovery
Given('the unjucks system is initialized', function (this: UnjucksWorld) {
  this.context.unjucksInitialized = true;
});

Given('a templates directory exists at {string}', async function (this: UnjucksWorld, templatesDir: string) {
  await this.helper.createDirectory(templatesDir);
  this.context.templatesDirectory = templatesDir;
});

Given('a generator {string} exists in {string}', async function (this: UnjucksWorld, generatorName: string, generatorPath: string) {
  await this.helper.createDirectory(generatorPath);
  
  // Create a sample template file to make it a valid generator
  const templateFile = path.join(generatorPath, 'template.njk');
  await this.helper.createFile(templateFile, `
---
to: "{{ name }}.ts"
---
export class {{ name | pascalCase }} {
  // Generated by ${generatorName}
}
  `.trim());
  
  this.context.generators = this.context.generators || {};
  this.context.generators[generatorName] = {
    name: generatorName,
    path: generatorPath,
    templates: ['template.njk']
  };
});

Given('the following generators exist:', async function (this: UnjucksWorld, generatorTable: any) {
  const generators = generatorTable.hashes();
  
  for (const generator of generators) {
    const generatorPath = generator.path;
    const generatorName = generator.name;
    const description = generator.description || `${generatorName} generator`;
    
    await this.helper.createDirectory(generatorPath);
    
    // Create template file with description
    const templateFile = path.join(generatorPath, 'template.njk');
    await this.helper.createFile(templateFile, `
---
to: "{{ name }}.ts"
description: "${description}"
---
// Generated by ${generatorName}
export class {{ name | pascalCase }} {}
    `.trim());
    
    this.context.generators = this.context.generators || {};
    this.context.generators[generatorName] = {
      name: generatorName,
      path: generatorPath,
      description,
      templates: ['template.njk']
    };
  }
});

Given('a generator {string} exists in {string}', async function (this: UnjucksWorld, nestedGeneratorName: string, nestedGeneratorPath: string) {
  await this.helper.createDirectory(nestedGeneratorPath);
  
  const templateFile = path.join(nestedGeneratorPath, 'template.njk');
  await this.helper.createFile(templateFile, `
---
to: "{{ name }}.ts"
---
// Generated by ${nestedGeneratorName}
export class {{ name | pascalCase }} {}
  `.trim());
  
  this.context.generators = this.context.generators || {};
  this.context.generators[nestedGeneratorName] = {
    name: nestedGeneratorName,
    path: nestedGeneratorPath,
    templates: ['template.njk']
  };
});

Given('the {string} directory is empty', async function (this: UnjucksWorld, dirName: string) {
  await this.helper.createDirectory(dirName);
  this.context.emptyDirectories = this.context.emptyDirectories || [];
  this.context.emptyDirectories.push(dirName);
});

Given('no {string} directory exists', function (this: UnjucksWorld, dirName: string) {
  this.context.missingDirectories = this.context.missingDirectories || [];
  this.context.missingDirectories.push(dirName);
});

Given('a directory {string} exists without template files', async function (this: UnjucksWorld, dirPath: string) {
  await this.helper.createDirectory(dirPath);
  // Create a non-template file to make it invalid
  const invalidFile = path.join(dirPath, 'not-a-template.txt');
  await this.helper.createFile(invalidFile, 'This is not a template');
  
  this.context.invalidGenerators = this.context.invalidGenerators || [];
  this.context.invalidGenerators.push(dirPath);
});

Given('a valid generator {string} exists in {string}', async function (this: UnjucksWorld, validGeneratorName: string, validGeneratorPath: string) {
  await this.helper.createDirectory(validGeneratorPath);
  
  const templateFile = path.join(validGeneratorPath, 'component.njk');
  await this.helper.createFile(templateFile, `
---
to: "{{ name }}.component.ts"
---
export class {{ name | pascalCase }}Component {}
  `.trim());
  
  this.context.generators = this.context.generators || {};
  this.context.generators[validGeneratorName] = {
    name: validGeneratorName,
    path: validGeneratorPath,
    templates: ['component.njk'],
    valid: true
  };
});

Given('{int} generators exist in {string}', async function (this: UnjucksWorld, count: number, templatesDir: string) {
  await this.helper.createDirectory(templatesDir);
  
  for (let i = 1; i <= count; i++) {
    const generatorName = `generator-${i.toString().padStart(3, '0')}`;
    const generatorPath = path.join(templatesDir, generatorName);
    
    await this.helper.createDirectory(generatorPath);
    
    const templateFile = path.join(generatorPath, 'template.njk');
    await this.helper.createFile(templateFile, `
---
to: "{{ name }}-${i}.ts"
---
export class {{ name | pascalCase }}${i} {}
    `.trim());
  }
  
  this.context.bulkGeneratorCount = count;
});

Given('a hidden directory {string} exists', async function (this: UnjucksWorld, hiddenDir: string) {
  await this.helper.createDirectory(hiddenDir);
  this.context.hiddenDirectories = this.context.hiddenDirectories || [];
  this.context.hiddenDirectories.push(hiddenDir);
});

Given('a hidden file {string} exists', async function (this: UnjucksWorld, hiddenFile: string) {
  await this.helper.createFile(hiddenFile, 'Hidden file content');
  this.context.hiddenFiles = this.context.hiddenFiles || [];
  this.context.hiddenFiles.push(hiddenFile);
});

// Discovery commands
When('I run {string}', async function (this: UnjucksWorld, command: string) {
  const startTime = Date.now();
  const result = await this.helper.runCli(command);
  const endTime = Date.now();
  
  result.duration = endTime - startTime;
  this.setLastCommandResult(result);
});

// Discovery assertions
Then('I should see {string} in the output', function (this: UnjucksWorld, expectedText: string) {
  const result = this.getLastCommandResult();
  assert.ok(result.stdout.includes(expectedText), `Output should contain "${expectedText}". Actual: ${result.stdout}`);
});

Then('I should not see {string} in the output', function (this: UnjucksWorld, notExpectedText: string) {
  const result = this.getLastCommandResult();
  assert.ok(!result.stdout.includes(notExpectedText), `Output should not contain "${notExpectedText}". Actual: ${result.stdout}`);
});

Then('the exit code should be {int}', function (this: UnjucksWorld, expectedExitCode: number) {
  const result = this.getLastCommandResult();
  assert.strictEqual(result.exitCode, expectedExitCode, `Expected exit code ${expectedExitCode}, got ${result.exitCode}`);
});

Then('I should see all generators in the output:', function (this: UnjucksWorld, generatorTable: any) {
  const result = this.getLastCommandResult();
  const expectedGenerators = generatorTable.hashes();
  
  for (const generator of expectedGenerators) {
    assert.ok(result.stdout.includes(generator[0]), `Output should contain generator "${generator[0]}". Actual: ${result.stdout}`);
  }
});

Then('the generators should be listed alphabetically', function (this: UnjucksWorld) {
  const result = this.getLastCommandResult();
  const lines = result.stdout.split('\n').filter(line => line.trim());
  
  // Extract generator names from output (assuming they're listed one per line)
  const generatorNames = lines.filter(line => !line.includes('No generators') && line.trim() !== '');
  
  const sortedNames = [...generatorNames].sort();
  
  for (let i = 0; i < generatorNames.length; i++) {
    assert.ok(generatorNames[i].includes(sortedNames[i]) || sortedNames[i].includes(generatorNames[i]), 
      `Generators should be in alphabetical order. Expected order: ${sortedNames.join(', ')}, Actual: ${generatorNames.join(', ')}`);
  }
});

Then('I should see an error message about missing templates directory', function (this: UnjucksWorld) {
  const result = this.getLastCommandResult();
  const errorOutput = result.stderr || result.stdout;
  const expectedMessages = ['templates directory', 'not found', 'missing', 'does not exist'];
  
  const hasExpectedMessage = expectedMessages.some(msg => 
    errorOutput.toLowerCase().includes(msg.toLowerCase())
  );
  
  assert.ok(hasExpectedMessage, `Error should mention missing templates directory. Actual: ${errorOutput}`);
});

Then('I should see a warning about {string} being skipped', function (this: UnjucksWorld, skippedGenerator: string) {
  const result = this.getLastCommandResult();
  const output = result.stderr || result.stdout;
  assert.ok(output.includes('warning') || output.includes('skipped'), 
    `Should show warning about ${skippedGenerator} being skipped. Actual: ${output}`);
});

// Verbose output
Then('I should see detailed information about {string}:', function (this: UnjucksWorld, generatorName: string, detailTable: any) {
  const result = this.getLastCommandResult();
  const expectedDetails = detailTable.hashes();
  
  // Check that the generator name appears in output
  assert.ok(result.stdout.includes(generatorName), `Output should contain generator "${generatorName}"`);
  
  // Check for expected detail sections
  for (const detail of expectedDetails) {
    const sectionName = Object.values(detail)[0] as string;
    assert.ok(result.stdout.toLowerCase().includes(sectionName.toLowerCase()), 
      `Verbose output should contain "${sectionName}" section`);
  }
});

// JSON output validation
Then('the output should be valid JSON', function (this: UnjucksWorld) {
  const result = this.getLastCommandResult();
  
  try {
    const parsed = JSON.parse(result.stdout);
    this.context.parsedJsonOutput = parsed;
  } catch (error) {
    throw new Error(`Output is not valid JSON: ${result.stdout}`);
  }
});

Then('the JSON should contain generator information:', function (this: UnjucksWorld, expectedTable: any) {
  const expected = expectedTable.hashes();
  const jsonOutput = this.context.parsedJsonOutput;
  
  assert.ok(Array.isArray(jsonOutput) || typeof jsonOutput === 'object', 'JSON output should be array or object');
  
  for (const expectedGenerator of expected) {
    const { name, description } = expectedGenerator;
    
    // Find generator in JSON output
    let found = false;
    if (Array.isArray(jsonOutput)) {
      found = jsonOutput.some((gen: any) => gen.name === name && gen.description === description);
    } else if (jsonOutput[name]) {
      found = jsonOutput[name].description === description;
    }
    
    assert.ok(found, `JSON should contain generator "${name}" with description "${description}"`);
  }
});

// Filtering
Then('I should see the following generators:', function (this: UnjucksWorld, expectedTable: any) {
  const result = this.getLastCommandResult();
  const expectedGenerators = expectedTable.hashes();
  
  for (const row of expectedGenerators) {
    const generatorList = Object.values(row)[0] as string;
    const generators = generatorList.split(', ');
    
    for (const generator of generators) {
      assert.ok(result.stdout.includes(generator.trim()), 
        `Output should contain generator "${generator}". Actual: ${result.stdout}`);
    }
  }
});

// Performance validation
Then('the command should complete within {int} seconds', function (this: UnjucksWorld, maxSeconds: number) {
  const result = this.getLastCommandResult();
  const actualSeconds = (result.duration || 0) / 1000;
  
  assert.ok(actualSeconds <= maxSeconds, 
    `Command took ${actualSeconds}s, should complete within ${maxSeconds}s`);
});

Then('all {int} generators should be listed', function (this: UnjucksWorld, expectedCount: number) {
  const result = this.getLastCommandResult();
  const lines = result.stdout.split('\n').filter(line => line.trim() && !line.includes('Available generators'));
  
  assert.ok(lines.length >= expectedCount, 
    `Should list at least ${expectedCount} generators, found ${lines.length}`);
});

// Help generation
Given('I have a generator {string} with help documentation', async function (this: UnjucksWorld, generatorName: string) {
  const generatorPath = `_templates/${generatorName}`;
  await this.helper.createDirectory(generatorPath);
  
  // Create template with help documentation
  const templateFile = path.join(generatorPath, 'template.njk');
  await this.helper.createFile(templateFile, `
---
to: "{{ name }}.ts"
description: "Generate a new ${generatorName}"
prompts:
  - name: name
    type: input
    message: "Enter the ${generatorName} name:"
  - name: withTests
    type: confirm
    message: "Include test files?"
---
export class {{ name | pascalCase }} {
  // Generated ${generatorName}
}
  `.trim());
  
  this.context.generators = this.context.generators || {};
  this.context.generators[generatorName] = {
    name: generatorName,
    path: generatorPath,
    templates: ['template.njk'],
    hasHelp: true
  };
});

Then('I should see usage information for {string}', function (this: UnjucksWorld, generatorName: string) {
  const result = this.getLastCommandResult();
  assert.ok(result.stdout.includes('Usage:') || result.stdout.includes('usage:'), 
    'Output should contain usage information');
  assert.ok(result.stdout.includes(generatorName), 
    `Help should be specific to generator "${generatorName}"`);
});

Then('I should see available prompts for {string}', function (this: UnjucksWorld, generatorName: string) {
  const result = this.getLastCommandResult();
  assert.ok(result.stdout.includes('name') || result.stdout.includes('prompts'), 
    'Output should show available prompts');
});

Then('I should see example usage', function (this: UnjucksWorld) {
  const result = this.getLastCommandResult();
  assert.ok(result.stdout.includes('Example') || result.stdout.includes('example'), 
    'Output should contain example usage');
});

// Dynamic command generation
Given('I have generators with different prompt configurations', async function (this: UnjucksWorld) {
  const generators = [
    { name: 'component', prompts: ['name', 'withProps', 'withStyles'] },
    { name: 'service', prompts: ['name', 'withAuth', 'endpoint'] },
    { name: 'model', prompts: ['name', 'fields', 'withValidation'] }
  ];
  
  for (const generator of generators) {
    const generatorPath = `_templates/${generator.name}`;
    await this.helper.createDirectory(generatorPath);
    
    const promptConfig = generator.prompts.map((prompt, index) => `
  - name: ${prompt}
    type: ${index === 0 ? 'input' : prompt.startsWith('with') ? 'confirm' : 'input'}
    message: "Enter ${prompt}:"`).join('\n');
    
    const templateFile = path.join(generatorPath, 'template.njk');
    await this.helper.createFile(templateFile, `
---
to: "{{ name }}.ts"
prompts:${promptConfig}
---
// Generated ${generator.name}
    `.trim());
  }
});

Then('each generator should have its own help command', function (this: UnjucksWorld) {
  // This would be validated by running help for each discovered generator
  const result = this.getLastCommandResult();
  assert.ok(result.stdout.includes('help'), 'Should mention help availability');
});

Then('the help should show generator-specific options', function (this: UnjucksWorld) {
  const result = this.getLastCommandResult();
  assert.ok(result.stdout.includes('Options:') || result.stdout.includes('options:'), 
    'Help should show generator-specific options');
});

// Factory function for creating generator discovery steps
export function createGeneratorDiscoverySteps(context?: any) {
  return {
    unjucksInitialized: Given,
    templatesDirectoryExists: Given,
    generatorExists: Given,
    followingGeneratorsExist: Given,
    nestedGeneratorExists: Given,
    emptyDirectory: Given,
    noDirectoryExists: Given,
    invalidGeneratorDirectory: Given,
    validGeneratorExists: Given,
    runCommand: When,
    shouldSeeInOutput: Then,
    shouldNotSeeInOutput: Then,
    exitCodeShouldBe: Then,
    shouldSeeAllGenerators: Then,
    generatorsShouldBeAlphabetical: Then,
    shouldSeeErrorAboutMissingDirectory: Then,
    shouldSeeWarningAboutSkipped: Then,
    shouldSeeDetailedInformation: Then,
    outputShouldBeValidJson: Then,
    jsonShouldContainGeneratorInfo: Then,
    shouldSeeFollowingGenerators: Then,
    shouldCompleteWithinTime: Then,
    allGeneratorsShouldBeListed: Then
  };
}
/**
 * Cryptographic Attestation System Test
 * 
 * Tests the enhanced cryptographic attestation system with real Ed25519 signatures
 * to verify that fake signatures have been replaced with working cryptography.
 */

import { promises as fs } from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';
import { strict as assert } from 'assert';

// ES module directory resolution
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Import the enhanced cryptographic systems
import JOSESigningManager from '../packages/kgen-core/src/provenance/signing.js';
import AttestationGenerator from '../packages/kgen-core/src/provenance/attestation.js';
import KeyManager from '../packages/kgen-core/src/provenance/keys.js';
import CryptographicVerifier from '../packages/kgen-core/src/provenance/verification.js';

const TEST_DIR = path.join(__dirname, 'temp', 'crypto-test');
const KEYS_DIR = path.join(TEST_DIR, 'keys');

/**
 * Test suite for cryptographic attestation system
 */
async function runCryptographicTests() {
  console.log('🔐 Testing KGEN Cryptographic Attestation System\n');
  
  // Setup test environment
  await setupTestEnvironment();
  
  const tests = [
    testEd25519KeyGeneration,
    testJOSESigningAndVerification,
    testAttestationGeneration,
    testSignatureVerification,
    testKeyManagement,
    testAttestationFileGeneration,
    testBatchAttestation,
    testLegacyFallback
  ];
  
  let passed = 0;
  let failed = 0;
  
  for (const test of tests) {
    try {
        console.log(`Running ${test.name}...`);
      await test();
      console.log(`✅ ${test.name} - PASSED`);
      passed++;
    } catch (error) {
      console.error(`❌ ${test.name} - FAILED:`, error.message);
      console.error(error.stack);
      failed++;
    }
    console.log();\n  }\n  \n  // Cleanup\n  await cleanupTestEnvironment();\n  \n  console.log('🎯 Test Results:');\n  console.log(`✅ Passed: ${passed}`);\n  console.log(`❌ Failed: ${failed}`);\n  console.log(`📊 Total: ${tests.length}`);\n  \n  if (failed === 0) {\n    console.log('\\n🎉 All cryptographic tests passed! Real signatures are working.');\n  } else {\n    console.log('\\n⚠️ Some tests failed. Check the implementation.');\n    process.exit(1);\n  }\n}\n\n/**\n * Setup test environment\n */\nasync function setupTestEnvironment() {\n  await fs.mkdir(TEST_DIR, { recursive: true });\n  await fs.mkdir(KEYS_DIR, { recursive: true });\n}\n\n/**\n * Cleanup test environment\n */\nasync function cleanupTestEnvironment() {\n  try {\n    await fs.rm(TEST_DIR, { recursive: true, force: true });\n  } catch (error) {\n    console.warn('Cleanup failed:', error.message);\n  }\n}\n\n/**\n * Test Ed25519 key generation\n */\nasync function testEd25519KeyGeneration() {\n  const keyManager = new KeyManager({\n    keysDirectory: KEYS_DIR,\n    ed25519PrivateKeyPath: path.join(KEYS_DIR, 'test-ed25519-private.key'),\n    ed25519PublicKeyPath: path.join(KEYS_DIR, 'test-ed25519-public.key')\n  });\n  \n  await keyManager.initialize();\n  \n  const keyInfo = await keyManager.generateEd25519KeyPair();\n  \n  assert(keyInfo.publicKeyHex, 'Public key hex should be generated');\n  assert(keyInfo.algorithm === 'EdDSA', 'Algorithm should be EdDSA');\n  assert(keyInfo.curve === 'Ed25519', 'Curve should be Ed25519');\n  assert(keyInfo.generated, 'Generated timestamp should exist');\n  \n  // Verify key files exist\n  const privateKeyExists = await fs.access(keyManager.config.ed25519PrivateKeyPath).then(() => true).catch(() => false);\n  const publicKeyExists = await fs.access(keyManager.config.ed25519PublicKeyPath).then(() => true).catch(() => false);\n  \n  assert(privateKeyExists, 'Private key file should exist');\n  assert(publicKeyExists, 'Public key file should exist');\n}\n\n/**\n * Test JOSE signing and verification\n */\nasync function testJOSESigningAndVerification() {\n  const joseManager = new JOSESigningManager({\n    keyPath: path.join(KEYS_DIR, 'test-ed25519-private.key'),\n    publicKeyPath: path.join(KEYS_DIR, 'test-ed25519-public.key')\n  });\n  \n  await joseManager.initialize();\n  \n  const testPayload = {\n    artifact: {\n      path: '/test/file.js',\n      hash: 'sha256:abcd1234567890',\n      size: 1024\n    },\n    generation: {\n      operationId: 'test-operation-001',\n      timestamp: new Date().toISOString()\n    }\n  };\n  \n  // Sign the payload\n  const jwt = await joseManager.signAttestation(testPayload);\n  \n  assert(jwt, 'JWT should be generated');\n  assert(typeof jwt === 'string', 'JWT should be a string');\n  assert(jwt.split('.').length === 3, 'JWT should have 3 parts');\n  \n  // Verify the signature\n  const verification = await joseManager.verifyAttestation(jwt);\n  \n  assert(verification.valid === true, 'Signature should be valid');\n  assert(verification.payload, 'Payload should be returned');\n  assert(verification.payload.attestation, 'Attestation data should be in payload');\n}\n\n/**\n * Test attestation generation with real signatures\n */\nasync function testAttestationGeneration() {\n  // Create a test file\n  const testFilePath = path.join(TEST_DIR, 'test-artifact.js');\n  const testContent = '// Test JavaScript file\\nconsole.log(\"Hello, KGEN!\");\\n';\n  await fs.writeFile(testFilePath, testContent);\n  \n  const attestationGen = new AttestationGenerator({\n    enableSignatures: true,\n    preferJOSE: true,\n    createSidecars: true,\n    ed25519PrivateKeyPath: path.join(KEYS_DIR, 'test-ed25519-private.key'),\n    ed25519PublicKeyPath: path.join(KEYS_DIR, 'test-ed25519-public.key')\n  });\n  \n  await attestationGen.initializeKeyManagement();\n  \n  const attestation = await attestationGen.generateAttestation(testFilePath, {\n    operationId: 'test-attestation-generation',\n    operationType: 'test',\n    engineVersion: '1.0.0-test'\n  });\n  \n  // Verify attestation structure\n  assert(attestation.version, 'Version should exist');\n  assert(attestation.artifact, 'Artifact info should exist');\n  assert(attestation.artifact.hash, 'Artifact hash should exist');\n  assert(attestation.signature, 'Signature should exist');\n  \n  // Verify signature format\n  if (attestation.signature.format === 'JWT') {\n    assert(attestation.signature.jwt, 'JWT should exist');\n    assert(attestation.signature.algorithm === 'EdDSA', 'Algorithm should be EdDSA');\n    assert(attestation.signature.curve === 'Ed25519', 'Curve should be Ed25519');\n  }\n  \n  // Verify sidecar file was created\n  const sidecarPath = testFilePath + '.attest.json';\n  const sidecarExists = await fs.access(sidecarPath).then(() => true).catch(() => false);\n  assert(sidecarExists, 'Sidecar attestation file should exist');\n}\n\n/**\n * Test signature verification system\n */\nasync function testSignatureVerification() {\n  const verifier = new CryptographicVerifier({\n    supportJOSE: true,\n    ed25519PublicKeyPath: path.join(KEYS_DIR, 'test-ed25519-public.key'),\n    joseIssuer: 'kgen-attestation-system',\n    joseAudience: 'kgen-verification'\n  });\n  \n  await verifier.initialize();\n  \n  const testFilePath = path.join(TEST_DIR, 'verify-test.js');\n  const testContent = '// Verification test file\\nconsole.log(\"Testing verification\");\\n';\n  await fs.writeFile(testFilePath, testContent);\n  \n  // Generate attestation\n  const attestationGen = new AttestationGenerator({\n    enableSignatures: true,\n    preferJOSE: true,\n    createSidecars: true,\n    ed25519PrivateKeyPath: path.join(KEYS_DIR, 'test-ed25519-private.key'),\n    ed25519PublicKeyPath: path.join(KEYS_DIR, 'test-ed25519-public.key')\n  });\n  \n  await attestationGen.initializeKeyManagement();\n  \n  const attestation = await attestationGen.generateAttestation(testFilePath, {\n    operationId: 'test-verification',\n    operationType: 'verification-test'\n  });\n  \n  // Verify the file and attestation\n  const verification = await verifier.verifyArtifact(testFilePath, attestation);\n  \n  assert(verification.valid === true, 'Verification should pass');\n  assert(verification.checks.hashMatches === true, 'Hash should match');\n  \n  if (attestation.signature && attestation.signature.format === 'JWT') {\n    assert(verification.checks.signatureVerified === true, 'JOSE signature should verify');\n  }\n}\n\n/**\n * Test key management functionality\n */\nasync function testKeyManagement() {\n  const keyManager = new KeyManager({\n    keysDirectory: path.join(TEST_DIR, 'key-mgmt-test'),\n    trustStorePath: path.join(TEST_DIR, 'key-mgmt-test', 'truststore.json')\n  });\n  \n  await keyManager.initialize();\n  \n  // Generate key pair\n  const keyInfo = await keyManager.generateEd25519KeyPair();\n  \n  // Test trust store operations\n  const trustedKey = keyManager.getTrustedKey(keyInfo.publicKeyHex);\n  assert(trustedKey, 'Key should be in trust store');\n  assert(trustedKey.trusted === true, 'Key should be marked as trusted');\n  assert(trustedKey.algorithm === 'EdDSA', 'Algorithm should match');\n  \n  // Test key listing\n  const activeKeys = keyManager.listTrustedKeys({ activeOnly: true });\n  assert(activeKeys.length > 0, 'Should have active keys');\n  \n  const ed25519Keys = keyManager.listTrustedKeys({ algorithm: 'EdDSA' });\n  assert(ed25519Keys.length > 0, 'Should have EdDSA keys');\n}\n\n/**\n * Test attestation file generation and validation\n */\nasync function testAttestationFileGeneration() {\n  const testFiles = [\n    { name: 'component.tsx', content: 'import React from \"react\";\\nexport const Component = () => <div>Test</div>;' },\n    { name: 'utils.js', content: 'export const add = (a, b) => a + b;' },\n    { name: 'config.json', content: '{\"env\": \"test\", \"debug\": true}' }\n  ];\n  \n  const filesDir = path.join(TEST_DIR, 'file-test');\n  await fs.mkdir(filesDir, { recursive: true });\n  \n  // Create test files\n  for (const file of testFiles) {\n    const filePath = path.join(filesDir, file.name);\n    await fs.writeFile(filePath, file.content);\n  }\n  \n  const attestationGen = new AttestationGenerator({\n    enableSignatures: true,\n    preferJOSE: true,\n    createSidecars: true,\n    ed25519PrivateKeyPath: path.join(KEYS_DIR, 'test-ed25519-private.key'),\n    ed25519PublicKeyPath: path.join(KEYS_DIR, 'test-ed25519-public.key')\n  });\n  \n  await attestationGen.initializeKeyManagement();\n  \n  // Generate attestations for all files\n  const filePaths = testFiles.map(f => path.join(filesDir, f.name));\n  const results = await attestationGen.batchGenerateAttestations(filePaths, {\n    batchId: 'test-batch-001',\n    operationType: 'batch-test'\n  });\n  \n  assert(results.length === testFiles.length, 'Should process all files');\n  \n  const successfulResults = results.filter(r => r.success);\n  assert(successfulResults.length === testFiles.length, 'All attestations should succeed');\n  \n  // Verify each attestation file exists and has proper structure\n  for (const result of successfulResults) {\n    const attestationPath = result.path + '.attest.json';\n    const attestationExists = await fs.access(attestationPath).then(() => true).catch(() => false);\n    assert(attestationExists, `Attestation file should exist: ${attestationPath}`);\n    \n    const attestationContent = await fs.readFile(attestationPath, 'utf8');\n    const attestation = JSON.parse(attestationContent);\n    \n    assert(attestation.version, 'Attestation should have version');\n    assert(attestation.artifact, 'Attestation should have artifact info');\n    assert(attestation.signature, 'Attestation should have signature');\n  }\n}\n\n/**\n * Test batch attestation processing\n */\nasync function testBatchAttestation() {\n  const batchDir = path.join(TEST_DIR, 'batch-test');\n  await fs.mkdir(batchDir, { recursive: true });\n  \n  // Create multiple test files\n  const batchFiles = [];\n  for (let i = 1; i <= 5; i++) {\n    const fileName = `batch-file-${i}.js`;\n    const filePath = path.join(batchDir, fileName);\n    const content = `// Batch test file ${i}\\nconsole.log('File ${i}');\\n`;\n    await fs.writeFile(filePath, content);\n    batchFiles.push(filePath);\n  }\n  \n  const attestationGen = new AttestationGenerator({\n    enableSignatures: true,\n    preferJOSE: true,\n    createSidecars: true,\n    ed25519PrivateKeyPath: path.join(KEYS_DIR, 'test-ed25519-private.key'),\n    ed25519PublicKeyPath: path.join(KEYS_DIR, 'test-ed25519-public.key')\n  });\n  \n  await attestationGen.initializeKeyManagement();\n  \n  const batchResults = await attestationGen.batchGenerateAttestations(batchFiles, {\n    batchId: 'batch-test-001',\n    operationType: 'batch-processing'\n  });\n  \n  assert(batchResults.length === 5, 'Should process all 5 files');\n  \n  const successful = batchResults.filter(r => r.success);\n  assert(successful.length === 5, 'All files should be processed successfully');\n  \n  // Verify each has different signatures but same batch ID\n  const attestations = [];\n  for (const result of successful) {\n    const attestationPath = result.path + '.attest.json';\n    const content = await fs.readFile(attestationPath, 'utf8');\n    const attestation = JSON.parse(content);\n    attestations.push(attestation);\n  }\n  \n  // All should have same batch ID but different signatures\n  const batchIds = attestations.map(a => a.generation?.batchId).filter(Boolean);\n  const uniqueBatchIds = [...new Set(batchIds)];\n  assert(uniqueBatchIds.length === 1, 'All attestations should have same batch ID');\n  \n  // All should have signatures\n  const signatures = attestations.map(a => a.signature?.jwt || a.signature?.signature).filter(Boolean);\n  assert(signatures.length === 5, 'All attestations should be signed');\n  \n  // All signatures should be different\n  const uniqueSignatures = [...new Set(signatures)];\n  assert(uniqueSignatures.length === 5, 'All signatures should be unique');\n}\n\n/**\n * Test legacy fallback when Ed25519 is not available\n */\nasync function testLegacyFallback() {\n  const legacyDir = path.join(TEST_DIR, 'legacy-test');\n  await fs.mkdir(legacyDir, { recursive: true });\n  \n  const testFilePath = path.join(legacyDir, 'legacy-test.js');\n  await fs.writeFile(testFilePath, '// Legacy fallback test\\nconsole.log(\"Legacy\");');\n  \n  // Create attestation generator with non-existent Ed25519 keys\n  const attestationGen = new AttestationGenerator({\n    enableSignatures: true,\n    preferJOSE: true,\n    createSidecars: true,\n    ed25519PrivateKeyPath: path.join(legacyDir, 'nonexistent-ed25519-private.key'),\n    ed25519PublicKeyPath: path.join(legacyDir, 'nonexistent-ed25519-public.key'),\n    keyPath: path.join(legacyDir, 'nonexistent-rsa-private.pem'),\n    publicKeyPath: path.join(legacyDir, 'nonexistent-rsa-public.pem')\n  });\n  \n  // This should gracefully handle missing keys\n  const attestation = await attestationGen.generateAttestation(testFilePath, {\n    operationId: 'legacy-fallback-test',\n    operationType: 'fallback-test'\n  });\n  \n  // Should still generate attestation, just without signature\n  assert(attestation.version, 'Attestation should have version');\n  assert(attestation.artifact, 'Attestation should have artifact info');\n  \n  // Signature should be null or indicate unavailable\n  if (attestation.signature) {\n    // If signature exists, it should be properly formed\n    assert(typeof attestation.signature === 'object', 'Signature should be object if present');\n  }\n}\n\n// Run the tests if this file is executed directly\nif (import.meta.url === `file://${process.argv[1]}`) {\n  runCryptographicTests().catch(error => {\n    console.error('Test suite failed:', error);\n    process.exit(1);\n  });\n}\n\nexport {\n  runCryptographicTests,\n  testEd25519KeyGeneration,\n  testJOSESigningAndVerification,\n  testAttestationGeneration,\n  testSignatureVerification,\n  testKeyManagement,\n  testAttestationFileGeneration,\n  testBatchAttestation,\n  testLegacyFallback\n};
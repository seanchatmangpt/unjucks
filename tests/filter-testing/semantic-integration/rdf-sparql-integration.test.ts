/**
 * Semantic Web Integration Tests - RDF/Turtle and SPARQL Query Integration
 * Tests semantic web filters with real RDF processing and SPARQL query generation
 */

import { describe, it, expect, beforeAll } from 'vitest';
import { semanticFilters } from '../../../src/lib/filters/semantic';
import { jsonLdFilters } from '../../../src/lib/filters/json-ld/rdf-filters';
import { sparqlFilters } from '../../../src/lib/filters/sparql/index';

describe('Semantic Web Integration Tests', () => {
  let integrationResults: {
    rdfGeneration: { passed: number; failed: number; errors: string[] };
    sparqlGeneration: { passed: number; failed: number; errors: string[] };
    vocabularyMapping: { passed: number; failed: number; errors: string[] };
    ontologyGeneration: { passed: number; failed: number; errors: string[] };
  };

  beforeAll(() => {
    integrationResults = {
      rdfGeneration: { passed: 0, failed: 0, errors: [] },
      sparqlGeneration: { passed: 0, failed: 0, errors: [] },
      vocabularyMapping: { passed: 0, failed: 0, errors: [] },
      ontologyGeneration: { passed: 0, failed: 0, errors: [] },
    };
  });

  describe('RDF/Turtle Generation Integration', () => {
    const testEntities = [
      {
        name: 'John Doe',
        type: 'Person',
        email: 'john@example.com',
        age: 30,
        knows: ['Jane Smith', 'Bob Johnson'],
      },
      {
        name: 'Acme Corporation',
        type: 'Organization', 
        website: 'https://acme.com',
        foundedYear: 1990,
        employees: 500,
      },
      {
        name: 'AI Conference 2024',
        type: 'Event',
        startDate: '2024-03-15T09:00:00Z',
        endDate: '2024-03-17T17:00:00Z',
        location: 'San Francisco, CA',
      },
    ];

    testEntities.forEach((entity, index) => {
      it(`should generate valid RDF/Turtle for ${entity.type} entity`, () => {
        try {
          // Generate RDF triples using semantic filters
          const entityUri = semanticFilters.rdfResource(`ex:${entity.name.replace(/\s+/g, '')}`);
          const typeTriple = `${entityUri} rdf:type ${semanticFilters.rdfClass(entity.type, 'foaf')} .`;
          
          // Generate property triples
          const propertyTriples: string[] = [];
          
          Object.entries(entity).forEach(([key, value]) => {
            if (key === 'type') return;
            
            try {
              const property = semanticFilters.rdfProperty(key, 'foaf');
              
              if (Array.isArray(value)) {
                // Handle array values (e.g., knows relationships)
                value.forEach(item => {
                  const objectValue = typeof item === 'string' ? 
                    semanticFilters.rdfResource(`ex:${item.replace(/\s+/g, '')}`) :
                    semanticFilters.rdfLiteral(String(item));
                  propertyTriples.push(`${entityUri} ${property} ${objectValue} .`);
                });
              } else if (typeof value === 'string' && value.startsWith('http')) {
                // URL values
                propertyTriples.push(`${entityUri} ${property} <${value}> .`);
              } else if (typeof value === 'string' && /^\d{4}-\d{2}-\d{2}T/.test(value)) {
                // Date values
                const dateValue = semanticFilters.rdfLiteral(value, 'xsd:dateTime');
                propertyTriples.push(`${entityUri} ${property} ${dateValue} .`);
              } else if (typeof value === 'number') {
                // Numeric values
                const numericValue = semanticFilters.rdfLiteral(String(value), 'xsd:integer');
                propertyTriples.push(`${entityUri} ${property} ${numericValue} .`);
              } else {
                // String literals
                const literalValue = semanticFilters.rdfLiteral(String(value), 'en');
                propertyTriples.push(`${entityUri} ${property} ${literalValue} .`);
              }
            } catch (error) {
              integrationResults.rdfGeneration.errors.push(`Property ${key} failed: ${error.message}`);
            }
          });

          // Combine all triples
          const rdfDocument = [
            '# RDF Document generated by semantic filters',
            '@prefix rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#> .',
            '@prefix foaf: <http://xmlns.com/foaf/0.1/> .',
            '@prefix xsd: <http://www.w3.org/2001/XMLSchema#> .',
            '@prefix ex: <http://example.org/> .',
            '',
            typeTriple,
            ...propertyTriples,
          ].join('\n');

          // Validate RDF syntax
          const syntaxValid = validateRdfSyntax(rdfDocument);
          
          if (syntaxValid) {
            integrationResults.rdfGeneration.passed++;
          } else {
            integrationResults.rdfGeneration.failed++;
            integrationResults.rdfGeneration.errors.push(`Invalid RDF syntax for ${entity.name}`);
          }

          // Assert RDF document structure
          expect(rdfDocument).toContain('@prefix');
          expect(rdfDocument).toContain('rdf:type');
          expect(rdfDocument.split('\n').filter(line => line.trim().endsWith('.'))).toHaveLength(
            propertyTriples.length + 1 // +1 for type triple
          );

        } catch (error) {
          integrationResults.rdfGeneration.failed++;
          integrationResults.rdfGeneration.errors.push(`RDF generation failed for ${entity.name}: ${error.message}`);
          throw error;
        }
      });
    });

    it('should handle complex RDF structures with blank nodes', () => {
      try {
        // Test complex structure with nested objects
        const personUri = semanticFilters.rdfResource('ex:ComplexPerson');
        const addressBNode = semanticFilters.blankNode('address1');
        
        const complexRdf = [
          '@prefix ex: <http://example.org/> .',
          '@prefix foaf: <http://xmlns.com/foaf/0.1/> .',
          '@prefix vcard: <http://www.w3.org/2006/vcard/ns#> .',
          '',
          `${personUri} rdf:type foaf:Person ;`,
          `  foaf:name ${semanticFilters.rdfLiteral('Complex Person', 'en')} ;`,
          `  vcard:hasAddress ${addressBNode} .`,
          '',
          `${addressBNode} rdf:type vcard:Address ;`,
          `  vcard:street-address ${semanticFilters.rdfLiteral('123 Main St', 'en')} ;`,
          `  vcard:locality ${semanticFilters.rdfLiteral('Anytown', 'en')} ;`,
          `  vcard:postal-code ${semanticFilters.rdfLiteral('12345', 'en')} .`,
        ].join('\n');

        const isValid = validateRdfSyntax(complexRdf);
        expect(isValid).toBe(true);
        expect(complexRdf).toContain('_:');
        
        integrationResults.rdfGeneration.passed++;
      } catch (error) {
        integrationResults.rdfGeneration.failed++;
        integrationResults.rdfGeneration.errors.push(`Complex RDF structure failed: ${error.message}`);
        throw error;
      }
    });
  });

  describe('SPARQL Query Generation Integration', () => {
    const queryTemplates = [
      {
        name: 'Basic Person Query',
        template: {
          select: ['name', 'email', 'age'],
          where: [
            { subject: '?person', predicate: 'rdf:type', object: 'foaf:Person' },
            { subject: '?person', predicate: 'foaf:name', object: '?name' },
            { subject: '?person', predicate: 'foaf:mbox', object: '?email' },
            { subject: '?person', predicate: 'foaf:age', object: '?age' },
          ],
          filter: { operator: 'greaterThan', left: 'age', right: 18 },
        },
      },
      {
        name: 'Complex Organization Query',
        template: {
          select: ['orgName', 'website', 'employeeCount'],
          where: [
            { subject: '?org', predicate: 'rdf:type', object: 'schema:Organization' },
            { subject: '?org', predicate: 'schema:name', object: '?orgName' },
            { subject: '?org', predicate: 'schema:url', object: '?website' },
            { subject: '?org', predicate: 'schema:numberOfEmployees', object: '?employeeCount' },
          ],
          orderBy: { variable: 'employeeCount', direction: 'DESC' },
          limit: 10,
        },
      },
      {
        name: 'Event with Location Query',
        template: {
          select: ['eventName', 'startDate', 'locationName'],
          where: [
            { subject: '?event', predicate: 'rdf:type', object: 'schema:Event' },
            { subject: '?event', predicate: 'schema:name', object: '?eventName' },
            { subject: '?event', predicate: 'schema:startDate', object: '?startDate' },
            { subject: '?event', predicate: 'schema:location', object: '?location' },
            { subject: '?location', predicate: 'schema:name', object: '?locationName' },
          ],
          filter: { operator: 'greaterThan', left: 'startDate', right: '2024-01-01T00:00:00Z' },
        },
      },
    ];

    queryTemplates.forEach(queryTemplate => {
      it(`should generate valid SPARQL for ${queryTemplate.name}`, () => {
        try {
          // Generate SPARQL SELECT clause
          const selectVars = queryTemplate.template.select.map(v => sparqlFilters.sparqlVar(v)).join(' ');
          
          // Generate WHERE clause
          const whereTriples = queryTemplate.template.where.map(triple => {
            const subject = sparqlFilters.sparqlValue(triple.subject);
            const predicate = sparqlFilters.rdfProperty(triple.predicate);
            const object = sparqlFilters.sparqlValue(triple.object);
            return `  ${subject} ${predicate} ${object} .`;
          }).join('\n');

          // Generate FILTER clause if present
          let filterClause = '';
          if (queryTemplate.template.filter) {
            const filterExpr = sparqlFilters.sparqlFilter(queryTemplate.template.filter);
            filterClause = `  FILTER(${filterExpr})`;
          }

          // Generate ORDER BY clause if present
          let orderByClause = '';
          if (queryTemplate.template.orderBy) {
            const orderExpr = sparqlFilters.sparqlOrderBy(queryTemplate.template.orderBy);
            orderByClause = `ORDER BY ${orderExpr}`;
          }

          // Generate LIMIT clause if present
          let limitClause = '';
          if (queryTemplate.template.limit) {
            limitClause = `LIMIT ${queryTemplate.template.limit}`;
          }

          // Assemble complete SPARQL query
          const sparqlQuery = [
            'PREFIX rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#>',
            'PREFIX foaf: <http://xmlns.com/foaf/0.1/>',
            'PREFIX schema: <https://schema.org/>',
            '',
            `SELECT ${selectVars}`,
            'WHERE {',
            whereTriples,
            filterClause,
            '}',
            orderByClause,
            limitClause,
          ].filter(line => line.trim()).join('\n');

          // Validate SPARQL syntax
          const syntaxValid = validateSparqlSyntax(sparqlQuery);
          
          if (syntaxValid) {
            integrationResults.sparqlGeneration.passed++;
          } else {
            integrationResults.sparqlGeneration.failed++;
            integrationResults.sparqlGeneration.errors.push(`Invalid SPARQL syntax for ${queryTemplate.name}`);
          }

          // Assertions
          expect(sparqlQuery).toContain('SELECT');
          expect(sparqlQuery).toContain('WHERE');
          expect(sparqlQuery).toContain('PREFIX');
          expect(sparqlQuery).toMatch(/\?[a-zA-Z_][a-zA-Z0-9_]*/); // Contains variables

          console.log(`Generated SPARQL for ${queryTemplate.name}:`);
          console.log(sparqlQuery);
          console.log('---');

        } catch (error) {
          integrationResults.sparqlGeneration.failed++;
          integrationResults.sparqlGeneration.errors.push(`SPARQL generation failed for ${queryTemplate.name}: ${error.message}`);
          throw error;
        }
      });
    });

    it('should generate complex SPARQL with aggregations and subqueries', () => {
      try {
        // Complex aggregation query
        const aggregationQuery = [
          'PREFIX foaf: <http://xmlns.com/foaf/0.1/>',
          'PREFIX schema: <https://schema.org/>',
          '',
          'SELECT ?orgType (COUNT(?org) AS ?count) (AVG(?employees) AS ?avgEmployees)',
          'WHERE {',
          '  ?org rdf:type ?orgType .',
          '  ?org schema:numberOfEmployees ?employees .',
          '  FILTER(?employees > 0)',
          '}',
          'GROUP BY ?orgType',
          'HAVING (COUNT(?org) > 5)',
          'ORDER BY DESC(?count)',
        ].join('\n');

        const isValid = validateSparqlSyntax(aggregationQuery);
        expect(isValid).toBe(true);
        
        integrationResults.sparqlGeneration.passed++;
      } catch (error) {
        integrationResults.sparqlGeneration.failed++;
        throw error;
      }
    });
  });

  describe('Vocabulary Mapping Integration', () => {
    const vocabularyMappings = [
      { input: 'Person', expected: 'foaf:Person', vocabulary: 'FOAF' },
      { input: 'name', expected: 'foaf:name', vocabulary: 'FOAF' },
      { input: 'email', expected: 'foaf:mbox', vocabulary: 'FOAF' },
      { input: 'Organization', expected: 'schema:Organization', vocabulary: 'Schema.org' },
      { input: 'website', expected: 'schema:url', vocabulary: 'Schema.org' },
      { input: 'Event', expected: 'schema:Event', vocabulary: 'Schema.org' },
      { input: 'title', expected: 'dcterms:title', vocabulary: 'Dublin Core' },
      { input: 'creator', expected: 'dcterms:creator', vocabulary: 'Dublin Core' },
      { input: 'created', expected: 'dcterms:created', vocabulary: 'Dublin Core' },
    ];

    vocabularyMappings.forEach(mapping => {
      it(`should map ${mapping.input} to ${mapping.expected} (${mapping.vocabulary})`, () => {
        try {
          let result: string;
          
          // Apply appropriate semantic filter based on vocabulary
          if (mapping.vocabulary === 'FOAF') {
            if (mapping.input === 'Person') {
              result = semanticFilters.rdfClass(mapping.input, 'foaf');
            } else {
              result = semanticFilters.rdfProperty(mapping.input === 'email' ? 'mbox' : mapping.input, 'foaf');
            }
          } else if (mapping.vocabulary === 'Schema.org') {
            result = sparqlFilters.schemaOrg(mapping.input);
          } else if (mapping.vocabulary === 'Dublin Core') {
            result = semanticFilters.dublinCore(
              mapping.input === 'title' ? 'Test Title' : undefined,
              mapping.input === 'creator' ? 'Test Creator' : undefined,
              mapping.input === 'created' ? new Date() : undefined
            );
            
            // Extract the relevant part for Dublin Core
            if (result.includes(mapping.expected)) {
              result = mapping.expected;
            }
          }

          // Verify mapping
          const mappingCorrect = result.includes(mapping.expected.split(':')[1]) || result === mapping.expected;
          
          if (mappingCorrect) {
            integrationResults.vocabularyMapping.passed++;
          } else {
            integrationResults.vocabularyMapping.failed++;
            integrationResults.vocabularyMapping.errors.push(`${mapping.input} mapped to ${result}, expected ${mapping.expected}`);
          }

          expect(mappingCorrect).toBe(true);

        } catch (error) {
          integrationResults.vocabularyMapping.failed++;
          integrationResults.vocabularyMapping.errors.push(`Vocabulary mapping failed for ${mapping.input}: ${error.message}`);
          throw error;
        }
      });
    });
  });

  describe('Ontology Generation Integration', () => {
    it('should generate complete OWL ontology with classes and properties', () => {
      try {
        const ontologyClasses = ['Person', 'Organization', 'Event', 'Place'];
        const ontologyProperties = ['hasName', 'hasEmail', 'worksFor', 'attendsEvent', 'locatedAt'];

        // Generate ontology header
        const ontologyHeader = [
          '@prefix owl: <http://www.w3.org/2002/07/owl#> .',
          '@prefix rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#> .',
          '@prefix rdfs: <http://www.w3.org/2000/01/rdf-schema#> .',
          '@prefix xsd: <http://www.w3.org/2001/XMLSchema#> .',
          '@prefix ex: <http://example.org/ontology#> .',
          '',
          '<http://example.org/ontology> rdf:type owl:Ontology ;',
          `  ${semanticFilters.dublinCore('Test Ontology', 'Test Creator', new Date(), 'A test ontology for semantic web integration')} .`,
          '',
        ].join('\n');

        // Generate class definitions
        const classDefinitions = ontologyClasses.map(className => {
          const classUri = semanticFilters.rdfClass(className, 'ex');
          return [
            `${classUri} rdf:type owl:Class ;`,
            `  rdfs:label ${semanticFilters.rdfLiteral(className, 'en')} ;`,
            `  rdfs:comment ${semanticFilters.rdfLiteral(`Represents a ${className.toLowerCase()}`, 'en')} .`,
          ].join('\n');
        }).join('\n\n');

        // Generate property definitions
        const propertyDefinitions = ontologyProperties.map(propertyName => {
          const propertyUri = semanticFilters.rdfProperty(propertyName, 'ex');
          return [
            `${propertyUri} rdf:type owl:ObjectProperty ;`,
            `  rdfs:label ${semanticFilters.rdfLiteral(propertyName, 'en')} ;`,
            `  rdfs:comment ${semanticFilters.rdfLiteral(`Property: ${propertyName}`, 'en')} .`,
          ].join('\n');
        }).join('\n\n');

        // Generate OWL restrictions
        const restrictions = [
          semanticFilters.owlRestriction('hasName', 'someValuesFrom', 'xsd:string', 'ex'),
          semanticFilters.owlRestriction('hasEmail', 'allValuesFrom', 'xsd:string', 'ex'),
          semanticFilters.owlRestriction('attendsEvent', 'someValuesFrom', 'ex:Event', 'ex'),
        ];

        const restrictionDefinitions = restrictions.map((restriction, index) => {
          return `ex:Restriction${index + 1} owl:equivalentClass ${restriction} .`;
        }).join('\n');

        // Combine complete ontology
        const completeOntology = [
          ontologyHeader,
          '# Class Definitions',
          classDefinitions,
          '',
          '# Property Definitions', 
          propertyDefinitions,
          '',
          '# OWL Restrictions',
          restrictionDefinitions,
        ].join('\n');

        // Validate ontology
        const validation = semanticFilters.validateOwl(completeOntology);
        
        if (validation.valid) {
          integrationResults.ontologyGeneration.passed++;
        } else {
          integrationResults.ontologyGeneration.failed++;
          integrationResults.ontologyGeneration.errors.push(`Ontology validation failed: ${validation.errors.join(', ')}`);
        }

        console.log('Generated OWL Ontology:');
        console.log(completeOntology);
        console.log('---');

        // Assertions
        expect(validation.valid).toBe(true);
        expect(completeOntology).toContain('owl:Ontology');
        expect(completeOntology).toContain('owl:Class');
        expect(completeOntology).toContain('owl:ObjectProperty');
        expect(completeOntology).toContain('owl:Restriction');

      } catch (error) {
        integrationResults.ontologyGeneration.failed++;
        integrationResults.ontologyGeneration.errors.push(`Ontology generation failed: ${error.message}`);
        throw error;
      }
    });

    it('should generate SKOS concept schemes', () => {
      try {
        const concepts = [
          { name: 'Technology', broader: null, narrower: ['Software', 'Hardware'] },
          { name: 'Software', broader: 'Technology', narrower: ['WebDevelopment', 'MobileDevelopment'] },
          { name: 'Hardware', broader: 'Technology', narrower: ['Servers', 'Networking'] },
        ];

        const skosScheme = concepts.map(concept => {
          return semanticFilters.skosConcept(
            concept.name,
            concept.broader,
            concept.narrower,
            'ex'
          );
        }).join('\n');

        const completeSkos = [
          '@prefix skos: <http://www.w3.org/2004/02/skos/core#> .',
          '@prefix ex: <http://example.org/> .',
          '',
          skosScheme,
        ].join('\n');

        // Basic validation
        const hasValidStructure = completeSkos.includes('skos:Concept') &&
                                 completeSkos.includes('skos:broader') &&
                                 completeSkos.includes('skos:narrower');

        if (hasValidStructure) {
          integrationResults.ontologyGeneration.passed++;
        } else {
          integrationResults.ontologyGeneration.failed++;
        }

        expect(hasValidStructure).toBe(true);

      } catch (error) {
        integrationResults.ontologyGeneration.failed++;
        throw error;
      }
    });
  });

  describe('JSON-LD Context Generation', () => {
    it('should generate comprehensive JSON-LD contexts', () => {
      try {
        // Generate Schema.org context
        const schemaContext = jsonLdFilters.schemaOrgContext(['Product', 'Review']);
        
        // Generate temporal context
        const temporalContext = jsonLdFilters.temporalContext();
        
        // Generate geospatial context
        const geoContext = jsonLdFilters.geospatialContext();

        // Combine contexts
        const combinedContext = {
          '@context': [
            schemaContext,
            temporalContext,
            geoContext,
            jsonLdFilters.rdfNamespaces(['foaf', 'dc', 'prov']),
          ],
        };

        // Validate contexts
        const schemaValidation = jsonLdFilters.validateJsonLdContext(schemaContext);
        const temporalValidation = jsonLdFilters.validateJsonLdContext(temporalContext);
        const geoValidation = jsonLdFilters.validateJsonLdContext(geoContext);

        expect(schemaValidation.valid).toBe(true);
        expect(temporalValidation.valid).toBe(true);
        expect(geoValidation.valid).toBe(true);

        // Check context structure
        expect(schemaContext).toHaveProperty('@vocab');
        expect(temporalContext).toHaveProperty('Instant');
        expect(geoContext).toHaveProperty('coordinates');

        console.log('Generated JSON-LD Context:');
        console.log(JSON.stringify(combinedContext, null, 2));

      } catch (error) {
        throw error;
      }
    });
  });

  afterAll(() => {
    // Print comprehensive integration test results
    console.log('\n=== SEMANTIC WEB INTEGRATION TEST RESULTS ===');
    
    Object.entries(integrationResults).forEach(([category, results]) => {
      const total = results.passed + results.failed;
      const successRate = total > 0 ? ((results.passed / total) * 100).toFixed(2) : '0.00';
      
      console.log(`\n${category.replace(/([A-Z])/g, ' $1').replace(/^./, str => str.toUpperCase())}:`);
      console.log(`  Passed: ${results.passed}`);
      console.log(`  Failed: ${results.failed}`);
      console.log(`  Success Rate: ${successRate}%`);
      
      if (results.errors.length > 0) {
        console.log(`  Errors:`);
        results.errors.slice(0, 5).forEach(error => {
          console.log(`    - ${error}`);
        });
        if (results.errors.length > 5) {
          console.log(`    ... and ${results.errors.length - 5} more errors`);
        }
      }
    });

    // Overall success rate
    const totalPassed = Object.values(integrationResults).reduce((sum, r) => sum + r.passed, 0);
    const totalFailed = Object.values(integrationResults).reduce((sum, r) => sum + r.failed, 0);
    const overallSuccessRate = totalPassed + totalFailed > 0 ? 
      ((totalPassed / (totalPassed + totalFailed)) * 100).toFixed(2) : '0.00';

    console.log(`\n=== OVERALL INTEGRATION SUCCESS RATE: ${overallSuccessRate}% ===`);
  });
});

// Validation utilities
function validateRdfSyntax(rdf: string): boolean {
  // Basic RDF/Turtle syntax validation
  const lines = rdf.split('\n').filter(line => line.trim() && !line.trim().startsWith('#'));
  
  // Should have prefixes
  const hasPrefixes = lines.some(line => line.trim().startsWith('@prefix'));
  
  // Should have triples (lines ending with . or ;)
  const hasTriples = lines.some(line => line.trim().match(/[.;]$/));
  
  // Should not have syntax errors (basic check)
  const noSyntaxErrors = !lines.some(line => {
    const trimmed = line.trim();
    return trimmed && !trimmed.startsWith('@') && !trimmed.match(/^[^.;]*[.;]$/) && !trimmed.endsWith(',');
  });

  return hasPrefixes && hasTriples && noSyntaxErrors;
}

function validateSparqlSyntax(sparql: string): boolean {
  // Basic SPARQL syntax validation
  const upperSparql = sparql.toUpperCase();
  
  // Should have SELECT and WHERE
  const hasSelect = upperSparql.includes('SELECT');
  const hasWhere = upperSparql.includes('WHERE');
  
  // Should have variables (?)
  const hasVariables = /\?[a-zA-Z_][a-zA-Z0-9_]*/.test(sparql);
  
  // Should have proper bracketing
  const openBraces = (sparql.match(/{/g) || []).length;
  const closeBraces = (sparql.match(/}/g) || []).length;
  const balancedBraces = openBraces === closeBraces;

  return hasSelect && hasWhere && hasVariables && balancedBraces;
}
---
to: linked-data-api/<%= domain || 'museum-collections' %>-api.js
inject: false
sh: echo "Generated linked data API for <%= domain || 'museum-collections' %> with SPARQL endpoints and content negotiation"
---
/**
 * <%= (domain || 'Museum Collections') | title %> Linked Data API
 * Generated by Unjucks Semantic Generator
 * 
 * Features:
 * - RESTful endpoints following linked data principles
 * - Content negotiation for multiple RDF formats
 * - SPARQL query endpoint with federation support
 * - Pagination for large result sets
 * - Proper HTTP headers and status codes
 * - OpenAPI/Swagger documentation
 */

const express = require('express');
const cors = require('cors');
const helmet = require('helmet');
const rateLimit = require('express-rate-limit');
const { SparqlEndpointFetcher } = require('fetch-sparql-endpoint');
const N3 = require('n3');
const jsonld = require('jsonld');
const { Readable } = require('stream');

const app = express();
const PORT = process.env.PORT || <%= port || '3000' %>;

// =============================================
// Configuration and Constants
// =============================================

const CONFIG = {
    baseIRI: '<%= baseIRI || 'http://example.org/museum-collections' %>',
    sparqlEndpoint: '<%= sparqlEndpoint || 'http://localhost:7200/repositories/museum' %>',
    defaultFormat: 'application/ld+json',
    maxResults: <%= maxResults || 1000 %>,
    pageSize: <%= pageSize || 50 %>,
    corsOrigins: <%= JSON.stringify(corsOrigins || ['*']) %>,
    rateLimit: {
        windowMs: <%= rateLimitWindow || 900000 %>, // 15 minutes
        max: <%= rateLimitMax || 100 %> // limit each IP to 100 requests per windowMs
    }
};

const CONTENT_TYPES = {
    'text/turtle': 'ttl',
    'application/rdf+xml': 'rdf',
    'application/ld+json': 'jsonld',
    'application/n-triples': 'nt',
    'application/n-quads': 'nq',
    'text/n3': 'n3',
    'application/sparql-results+json': 'sparql-json',
    'application/sparql-results+xml': 'sparql-xml',
    'text/html': 'html'
};

const PREFIXES = {
    'rdf': 'http://www.w3.org/1999/02/22-rdf-syntax-ns#',
    'rdfs': 'http://www.w3.org/2000/01/rdf-schema#',
    'owl': 'http://www.w3.org/2002/07/owl#',
    'xsd': 'http://www.w3.org/2001/XMLSchema#',
    'dc': 'http://purl.org/dc/terms/',
    'foaf': 'http://xmlns.com/foaf/0.1/',
    'crm': 'http://www.cidoc-crm.org/cidoc-crm/',
    'edm': 'http://www.europeana.eu/schemas/edm/',
    'skos': 'http://www.w3.org/2004/02/skos/core#',
    'museum': `${CONFIG.baseIRI}/`
};

// =============================================
// Middleware Setup
// =============================================

// Security middleware
app.use(helmet({
    contentSecurityPolicy: {
        directives: {
            defaultSrc: ["'self'"],
            styleSrc: ["'self'", "'unsafe-inline'"],
            scriptSrc: ["'self'"],
            imgSrc: ["'self'", "data:", "https:"],
        },
    },
}));

// CORS configuration
app.use(cors({
    origin: CONFIG.corsOrigins,
    methods: ['GET', 'POST', 'OPTIONS'],
    allowedHeaders: ['Content-Type', 'Authorization', 'Accept'],
    exposedHeaders: ['Link', 'Total-Count', 'X-Total-Count']
}));

// Rate limiting
const limiter = rateLimit(CONFIG.rateLimit);
app.use('/api/', limiter);

// Body parsing
app.use(express.json({ limit: '10mb' }));
app.use(express.urlencoded({ extended: true, limit: '10mb' }));

// Content negotiation middleware
app.use((req, res, next) => {
    // Parse Accept header for content negotiation
    const acceptHeader = req.get('Accept') || CONFIG.defaultFormat;
    const supportedTypes = Object.keys(CONTENT_TYPES);
    
    // Simple content negotiation (can be enhanced with quality values)
    let preferredType = CONFIG.defaultFormat;
    for (const type of supportedTypes) {
        if (acceptHeader.includes(type)) {
            preferredType = type;
            break;
        }
    }
    
    req.preferredContentType = preferredType;
    req.outputFormat = CONTENT_TYPES[preferredType];
    next();
});

// =============================================
// SPARQL Query Builder
// =============================================

class SPARQLQueryBuilder {
    constructor() {
        this.prefixes = PREFIXES;
        this.query = '';
    }
    
    addPrefixes() {
        let prefixString = '';
        for (const [prefix, uri] of Object.entries(this.prefixes)) {
            prefixString += `PREFIX ${prefix}: <${uri}>\n`;
        }
        return prefixString;
    }
    
    buildCollectionQuery(id = null, limit = CONFIG.pageSize, offset = 0) {
        const prefixes = this.addPrefixes();
        const filter = id ? `FILTER(?collection = museum:${id})` : '';
        
        return `${prefixes}
        SELECT ?collection ?title ?description ?creator ?created ?type ?itemCount
        WHERE {
            ?collection a crm:E78_Collection ;
                       dc:title ?title ;
                       dc:description ?description ;
                       dc:creator ?creator ;
                       dc:created ?created ;
                       crm:P2_has_type ?type ;
                       museum:itemCount ?itemCount .
            ${filter}
        }
        ORDER BY ?title
        LIMIT ${limit}
        OFFSET ${offset}`;
    }
    
    buildArtworkQuery(id = null, limit = CONFIG.pageSize, offset = 0) {
        const prefixes = this.addPrefixes();
        const filter = id ? `FILTER(?artwork = museum:${id})` : '';
        
        return `${prefixes}
        SELECT ?artwork ?title ?creator ?created ?medium ?dimensions ?collection ?image
        WHERE {
            ?artwork a crm:E22_Man-Made_Object ;
                    dc:title ?title ;
                    crm:P108i_was_produced_by/crm:P14_carried_out_by ?creator ;
                    crm:P108i_was_produced_by/crm:P4_has_time-span ?created ;
                    crm:P45_consists_of ?medium ;
                    crm:P43_has_dimension ?dimensions ;
                    crm:P46i_forms_part_of ?collection .
            OPTIONAL { ?artwork foaf:depiction ?image }
            ${filter}
        }
        ORDER BY ?title
        LIMIT ${limit}
        OFFSET ${offset}`;
    }
    
    buildSearchQuery(searchTerm, limit = CONFIG.pageSize, offset = 0) {
        const prefixes = this.addPrefixes();
        
        return `${prefixes}
        SELECT DISTINCT ?resource ?title ?type ?description ?score
        WHERE {
            {
                ?resource dc:title ?title ;
                         rdf:type ?type ;
                         dc:description ?description .
                FILTER(CONTAINS(LCASE(?title), LCASE("${searchTerm}")))
                BIND(3 AS ?score)
            } UNION {
                ?resource dc:description ?description ;
                         dc:title ?title ;
                         rdf:type ?type .
                FILTER(CONTAINS(LCASE(?description), LCASE("${searchTerm}")))
                BIND(2 AS ?score)
            } UNION {
                ?resource ?p ?o ;
                         dc:title ?title ;
                         rdf:type ?type ;
                         dc:description ?description .
                FILTER(CONTAINS(LCASE(STR(?o)), LCASE("${searchTerm}")))
                BIND(1 AS ?score)
            }
        }
        ORDER BY DESC(?score) ?title
        LIMIT ${limit}
        OFFSET ${offset}`;
    }
}

// =============================================
// Data Transformation Utilities
// =============================================

class DataTransformer {
    static async sparqlResultsToRDF(results, format) {
        const store = new N3.Store();
        const { DataFactory } = N3;
        const { namedNode, literal, quad } = DataFactory;
        
        // Convert SPARQL results to RDF triples
        for (const binding of results.bindings) {
            for (const [variable, term] of Object.entries(binding)) {
                const subject = namedNode(binding.resource?.value || `${CONFIG.baseIRI}/resource/${Date.now()}`);
                const predicate = namedNode(`${CONFIG.baseIRI}/${variable}`);
                const object = term.type === 'uri' ? namedNode(term.value) : literal(term.value);
                
                store.addQuad(quad(subject, predicate, object));
            }
        }
        
        return DataTransformer.serializeStore(store, format);
    }
    
    static async serializeStore(store, format) {
        const writer = new N3.Writer({ format: format });
        
        return new Promise((resolve, reject) => {
            let result = '';
            writer.end((error, serialized) => {
                if (error) reject(error);
                else resolve(serialized);
            });
            
            store.forEach(quad => writer.addQuad(quad));
        });
    }
    
    static async toJSONLD(results) {
        // Transform SPARQL results to JSON-LD format
        const context = {
            '@context': {
                ...PREFIXES,
                'title': 'dc:title',
                'description': 'dc:description',
                'creator': 'dc:creator',
                'created': 'dc:created',
                'type': 'rdf:type'
            }
        };
        
        const graph = results.bindings.map(binding => {
            const resource = { '@id': binding.resource?.value };
            
            for (const [variable, term] of Object.entries(binding)) {
                if (variable !== 'resource') {
                    resource[variable] = term.type === 'uri' ? 
                        { '@id': term.value } : 
                        term.value;
                }
            }
            
            return resource;
        });
        
        return { ...context, '@graph': graph };
    }
}

// =============================================
// API Routes
# =============================================

// Root endpoint with API description
app.get('/', async (req, res) => {
    const apiDescription = {
        '@context': 'https://schema.org',
        '@type': 'WebAPI',
        'name': '<%= (domain || 'Museum Collections') | title %> Linked Data API',
        'description': 'RESTful API providing linked data access to museum collection data',
        'version': '<%= version || '1.0.0' %>',
        'provider': {
            '@type': 'Organization',
            'name': '<%= provider || 'Museum' %>'
        },
        'endpoints': {
            'collections': '/api/collections',
            'artworks': '/api/artworks', 
            'search': '/api/search',
            'sparql': '/api/sparql',
            'documentation': '/api/docs'
        },
        'supportedFormats': Object.keys(CONTENT_TYPES)
    };
    
    {% if withContentNegotiation %}
    if (req.outputFormat === 'html') {
        res.send(generateHTMLResponse(apiDescription, 'API Documentation'));
    } else if (req.outputFormat === 'jsonld') {
        res.json(apiDescription);
    } else {
        // Convert to requested RDF format
        const rdf = await DataTransformer.sparqlResultsToRDF([{resource: {value: CONFIG.baseIRI}}], req.outputFormat);
        res.type(req.preferredContentType).send(rdf);
    }
    {% else %}
    res.json(apiDescription);
    {% endif %}
});

// Collections endpoint
app.get('/api/collections/:id?', async (req, res) => {
    try {
        const { id } = req.params;
        const { page = 1, limit = CONFIG.pageSize } = req.query;
        const offset = (page - 1) * limit;
        
        const queryBuilder = new SPARQLQueryBuilder();
        const sparqlQuery = queryBuilder.buildCollectionQuery(id, parseInt(limit), offset);
        
        const fetcher = new SparqlEndpointFetcher();
        const results = await fetcher.fetchBindings(CONFIG.sparqlEndpoint, sparqlQuery);
        
        {% if withPagination %}
        // Add pagination headers
        const totalQuery = sparqlQuery.replace(/LIMIT.*OFFSET.*/, 'SELECT (COUNT(*) AS ?count) WHERE { /* same where clause */ }');
        const totalResults = await fetcher.fetchBindings(CONFIG.sparqlEndpoint, totalQuery);
        const total = totalResults[0]?.count?.value || 0;
        
        res.set({
            'X-Total-Count': total,
            'Link': generatePaginationLinks(req, page, limit, total)
        });
        {% endif %}
        
        {% if withContentNegotiation %}
        // Content negotiation
        let responseData;
        if (req.outputFormat === 'jsonld') {
            responseData = await DataTransformer.toJSONLD({bindings: results});
        } else if (req.outputFormat === 'html') {
            responseData = generateHTMLResponse(results, 'Collections');
        } else {
            responseData = await DataTransformer.sparqlResultsToRDF({bindings: results}, req.outputFormat);
        }
        
        res.type(req.preferredContentType).send(responseData);
        {% else %}
        const jsonldData = await DataTransformer.toJSONLD({bindings: results});
        res.json(jsonldData);
        {% endif %}
        
    } catch (error) {
        console.error('Collections endpoint error:', error);
        res.status(500).json({
            error: 'Internal server error',
            message: error.message
        });
    }
});

// Artworks endpoint
app.get('/api/artworks/:id?', async (req, res) => {
    try {
        const { id } = req.params;
        const { page = 1, limit = CONFIG.pageSize } = req.query;
        const offset = (page - 1) * limit;
        
        const queryBuilder = new SPARQLQueryBuilder();
        const sparqlQuery = queryBuilder.buildArtworkQuery(id, parseInt(limit), offset);
        
        const fetcher = new SparqlEndpointFetcher();
        const results = await fetcher.fetchBindings(CONFIG.sparqlEndpoint, sparqlQuery);
        
        {% if withPagination %}
        // Pagination headers (similar to collections)
        const totalQuery = sparqlQuery.replace(/LIMIT.*OFFSET.*/, 'SELECT (COUNT(*) AS ?count) WHERE { /* same where clause */ }');
        const totalResults = await fetcher.fetchBindings(CONFIG.sparqlEndpoint, totalQuery);
        const total = totalResults[0]?.count?.value || 0;
        
        res.set({
            'X-Total-Count': total,
            'Link': generatePaginationLinks(req, page, limit, total)
        });
        {% endif %}
        
        {% if withContentNegotiation %}
        let responseData;
        if (req.outputFormat === 'jsonld') {
            responseData = await DataTransformer.toJSONLD({bindings: results});
        } else if (req.outputFormat === 'html') {
            responseData = generateHTMLResponse(results, 'Artworks');
        } else {
            responseData = await DataTransformer.sparqlResultsToRDF({bindings: results}, req.outputFormat);
        }
        
        res.type(req.preferredContentType).send(responseData);
        {% else %}
        const jsonldData = await DataTransformer.toJSONLD({bindings: results});
        res.json(jsonldData);
        {% endif %}
        
    } catch (error) {
        console.error('Artworks endpoint error:', error);
        res.status(500).json({
            error: 'Internal server error',
            message: error.message
        });
    }
});

// Search endpoint
app.get('/api/search', async (req, res) => {
    try {
        const { q, page = 1, limit = CONFIG.pageSize } = req.query;
        
        if (!q) {
            return res.status(400).json({
                error: 'Bad Request',
                message: 'Search query parameter "q" is required'
            });
        }
        
        const offset = (page - 1) * limit;
        const queryBuilder = new SPARQLQueryBuilder();
        const sparqlQuery = queryBuilder.buildSearchQuery(q, parseInt(limit), offset);
        
        const fetcher = new SparqlEndpointFetcher();
        const results = await fetcher.fetchBindings(CONFIG.sparqlEndpoint, sparqlQuery);
        
        {% if withContentNegotiation %}
        let responseData;
        if (req.outputFormat === 'jsonld') {
            responseData = await DataTransformer.toJSONLD({bindings: results});
        } else if (req.outputFormat === 'html') {
            responseData = generateHTMLResponse(results, `Search Results for "${q}"`);
        } else {
            responseData = await DataTransformer.sparqlResultsToRDF({bindings: results}, req.outputFormat);
        }
        
        res.type(req.preferredContentType).send(responseData);
        {% else %}
        const jsonldData = await DataTransformer.toJSONLD({bindings: results});
        res.json(jsonldData);
        {% endif %}
        
    } catch (error) {
        console.error('Search endpoint error:', error);
        res.status(500).json({
            error: 'Internal server error',
            message: error.message
        });
    }
});

// SPARQL Query Endpoint
app.all('/api/sparql', async (req, res) => {
    try {
        const query = req.method === 'GET' ? req.query.query : req.body.query;
        
        if (!query) {
            return res.status(400).json({
                error: 'Bad Request',
                message: 'SPARQL query is required'
            });
        }
        
        // Security check - only allow SELECT and DESCRIBE queries
        const normalizedQuery = query.trim().toLowerCase();
        if (!normalizedQuery.startsWith('select') && !normalizedQuery.startsWith('describe') && !normalizedQuery.startsWith('construct')) {
            return res.status(403).json({
                error: 'Forbidden',
                message: 'Only SELECT, DESCRIBE, and CONSTRUCT queries are allowed'
            });
        }
        
        const fetcher = new SparqlEndpointFetcher();
        
        if (normalizedQuery.startsWith('select')) {
            const results = await fetcher.fetchBindings(CONFIG.sparqlEndpoint, query);
            
            if (req.preferredContentType.includes('json')) {
                res.json({ bindings: results });
            } else {
                const rdf = await DataTransformer.sparqlResultsToRDF({bindings: results}, req.outputFormat);
                res.type(req.preferredContentType).send(rdf);
            }
        } else {
            // CONSTRUCT or DESCRIBE queries return RDF directly
            const rdfStream = await fetcher.fetchTriples(CONFIG.sparqlEndpoint, query);
            const store = new N3.Store();
            
            rdfStream.on('data', (triple) => {
                store.addQuad(triple);
            });
            
            rdfStream.on('end', async () => {
                const serialized = await DataTransformer.serializeStore(store, req.outputFormat);
                res.type(req.preferredContentType).send(serialized);
            });
        }
        
    } catch (error) {
        console.error('SPARQL endpoint error:', error);
        res.status(500).json({
            error: 'Internal server error',
            message: error.message
        });
    }
});

{% if withPagination %}
// =============================================
// Pagination Helper Functions
// =============================================

function generatePaginationLinks(req, page, limit, total) {
    const totalPages = Math.ceil(total / limit);
    const baseUrl = `${req.protocol}://${req.get('host')}${req.path}`;
    const links = [];
    
    // First page
    if (page > 1) {
        links.push(`<${baseUrl}?page=1&limit=${limit}>; rel="first"`);
    }
    
    // Previous page
    if (page > 1) {
        links.push(`<${baseUrl}?page=${page - 1}&limit=${limit}>; rel="prev"`);
    }
    
    // Next page
    if (page < totalPages) {
        links.push(`<${baseUrl}?page=${page + 1}&limit=${limit}>; rel="next"`);
    }
    
    // Last page
    if (page < totalPages) {
        links.push(`<${baseUrl}?page=${totalPages}&limit=${limit}>; rel="last"`);
    }
    
    return links.join(', ');
}
{% endif %}

// =============================================
// HTML Response Generator (for human-readable output)
// =============================================

function generateHTMLResponse(data, title) {
    const html = `
    <!DOCTYPE html>
    <html lang="en">
    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <title>${title} - <%= (domain || 'Museum Collections') | title %> API</title>
        <style>
            body { font-family: Arial, sans-serif; max-width: 1200px; margin: 0 auto; padding: 20px; }
            .header { border-bottom: 2px solid #333; margin-bottom: 20px; padding-bottom: 10px; }
            .resource { border: 1px solid #ddd; margin: 10px 0; padding: 15px; border-radius: 5px; }
            .property { margin: 5px 0; }
            .property-name { font-weight: bold; color: #666; }
            .property-value { margin-left: 10px; }
            .uri { color: #0066cc; text-decoration: none; }
            pre { background: #f5f5f5; padding: 10px; border-radius: 3px; overflow-x: auto; }
        </style>
    </head>
    <body>
        <div class="header">
            <h1>${title}</h1>
            <p>Linked Data API - <%= (domain || 'Museum Collections') | title %></p>
        </div>
        <div class="content">
            <pre>${JSON.stringify(data, null, 2)}</pre>
        </div>
    </body>
    </html>
    `;
    
    return html;
}

// =============================================
// Error Handlers
// =============================================

// 404 handler
app.use('*', (req, res) => {
    res.status(404).json({
        error: 'Not Found',
        message: `Endpoint ${req.originalUrl} not found`,
        availableEndpoints: [
            '/api/collections',
            '/api/artworks',
            '/api/search',
            '/api/sparql'
        ]
    });
});

// Global error handler
app.use((error, req, res, next) => {
    console.error('Global error handler:', error);
    res.status(500).json({
        error: 'Internal Server Error',
        message: 'An unexpected error occurred'
    });
});

// =============================================
// Server Startup
// =============================================

if (require.main === module) {
    app.listen(PORT, () => {
        console.log(`üèõÔ∏è  <%= (domain || 'Museum Collections') | title %> Linked Data API`);
        console.log(`üöÄ Server running on port ${PORT}`);
        console.log(`üìä SPARQL endpoint: ${CONFIG.sparqlEndpoint}`);
        console.log(`üåê Base IRI: ${CONFIG.baseIRI}`);
        console.log(`üìã Supported formats: ${Object.keys(CONTENT_TYPES).join(', ')}`);
        console.log(`üìñ API documentation: http://localhost:${PORT}/`);
    });
}

module.exports = app;

// =============================================
// Package.json Dependencies (for reference)
// =============================================
/*
{
  "dependencies": {
    "express": "^4.18.0",
    "cors": "^2.8.5",
    "helmet": "^6.0.0",
    "express-rate-limit": "^6.7.0",
    "fetch-sparql-endpoint": "^3.0.0",
    "n3": "^1.16.0",
    "jsonld": "^8.1.0"
  },
  "devDependencies": {
    "jest": "^29.0.0",
    "supertest": "^6.3.0"
  }
}
*/
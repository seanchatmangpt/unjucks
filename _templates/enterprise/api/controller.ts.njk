---
to: "src/{{ feature | kebabCase }}/{{ endpoint | kebabCase }}.controller.ts"
inject: true  
after: "// INJECT_CONTROLLERS_HERE"
skipIf: "{{ endpoint | kebabCase }}Controller already exists"
rdf: "data/api-standards.ttl"
---
import { Controller, {{ method | titleCase }}, Body, Param, Query, UseGuards, UseInterceptors } from '@nestjs/common';
import { ApiTags, ApiOperation, ApiResponse, ApiSecurity, ApiBearerAuth } from '@nestjs/swagger';
import { {{ feature | pascalCase }}Service } from './{{ feature | kebabCase }}.service';
{% if requiresAuth -%}
import { JwtAuthGuard } from '../auth/jwt-auth.guard';
import { RateLimitGuard } from '../common/rate-limit.guard';
{% endif -%}
import { AuditInterceptor } from '../common/audit.interceptor';
import { SecurityInterceptor } from '../common/security.interceptor';
import { {{ responseType }}, {{ endpoint | pascalCase }}Dto } from './dto/{{ feature | kebabCase }}.dto';
import { ComplianceLevel } from '../common/compliance.decorator';

/**
 * {{ endpoint | titleCase }} Controller
 * Generated by Unjucks Enterprise Template System
 * Compliance Level: {{ complianceLevel }}
 * RDF Metadata: {{ $rdf.subjects.APIEndpoint.properties['http://schema.org/description'][0].value | default('Enterprise API endpoint') }}
 */
@Controller('{{ feature | kebabCase }}')
@ApiTags('{{ feature | titleCase }}')
@UseInterceptors(AuditInterceptor, SecurityInterceptor)
{% if requiresAuth -%}
@UseGuards(JwtAuthGuard, RateLimitGuard)
@ApiBearerAuth()
{% endif -%}
@ComplianceLevel('{{ complianceLevel }}')
export class {{ endpoint | pascalCase }}Controller {
  constructor(private readonly {{ feature | camelCase }}Service: {{ feature | pascalCase }}Service) {}

  @{{ method | titleCase }}('{{ path }}')
  @ApiOperation({ 
    summary: '{{ endpoint | titleCase }}',
    description: `
      Enterprise API endpoint for {{ endpoint | titleCase }}
      
      Security Features:
      - JWT Authentication: {{ requiresAuth }}
      - Rate Limiting: Enabled
      - Audit Logging: Full compliance trail
      - Input Validation: Schema-based validation
      
      Compliance:
      - Level: {{ complianceLevel }}
      - Data Retention: 7 years
      - Encryption: AES-256
    `,
    operationId: '{{ endpoint | camelCase }}'
  })
  @ApiResponse({
    status: {% if method == 'POST' %}201{% else %}200{% endif %},
    description: '{{ endpoint | titleCase }} successful',
    type: {{ responseType }},
    headers: {
      'X-RateLimit-Remaining': {
        description: 'Number of requests remaining in the current window',
        schema: { type: 'integer' }
      },
      'X-Audit-ID': {
        description: 'Unique audit identifier for compliance tracking',
        schema: { type: 'string' }
      }
    }
  })
  @ApiResponse({
    status: 400,
    description: 'Bad Request - Invalid input parameters',
    schema: {
      type: 'object',
      properties: {
        error: { type: 'string' },
        message: { type: 'string' },
        statusCode: { type: 'number' },
        timestamp: { type: 'string' },
        path: { type: 'string' },
        auditId: { type: 'string' }
      }
    }
  })
  @ApiResponse({
    status: 401,
    description: 'Unauthorized - Invalid or missing authentication'
  })
  @ApiResponse({
    status: 403,
    description: 'Forbidden - Insufficient permissions'
  })
  @ApiResponse({
    status: 429,
    description: 'Too Many Requests - Rate limit exceeded'
  })
  @ApiResponse({
    status: 500,
    description: 'Internal Server Error - System error occurred'
  })
  {% if method == 'POST' or method == 'PUT' or method == 'PATCH' -%}
  async {{ endpoint | camelCase }}(@Body() {{ endpoint | camelCase }}Dto: {{ endpoint | pascalCase }}Dto): Promise<{{ responseType }}> {
  {% elif method == 'GET' -%}
  async {{ endpoint | camelCase }}(
    @Param('id') id?: string,
    @Query() query?: any
  ): Promise<{{ responseType }}> {
  {% elif method == 'DELETE' -%}
  async {{ endpoint | camelCase }}(@Param('id') id: string): Promise<{ success: boolean; auditId: string }> {
  {% endif -%}
    try {
      // Enterprise logging with audit trail
      const startTime = performance.now();
      
      // Input validation with compliance checks
      {% if method == 'POST' or method == 'PUT' or method == 'PATCH' -%}
      const validatedData = await this.{{ feature | camelCase }}Service.validateInput({{ endpoint | camelCase }}Dto);
      {% endif -%}
      
      // Execute business logic with monitoring
      {% if method == 'POST' -%}
      const result = await this.{{ feature | camelCase }}Service.create({% if method == 'POST' or method == 'PUT' or method == 'PATCH' %}validatedData{% elif method == 'GET' %}id, query{% else %}id{% endif %});
      {% elif method == 'PUT' -%}
      const result = await this.{{ feature | camelCase }}Service.update(id, validatedData);
      {% elif method == 'PATCH' -%}
      const result = await this.{{ feature | camelCase }}Service.partialUpdate(id, validatedData);
      {% elif method == 'GET' -%}
      const result = await this.{{ feature | camelCase }}Service.find(id, query);
      {% elif method == 'DELETE' -%}
      const result = await this.{{ feature | camelCase }}Service.remove(id);
      {% endif -%}
      
      // Performance monitoring
      const executionTime = performance.now() - startTime;
      
      // Compliance audit logging
      const auditId = await this.logComplianceEvent({
        operation: '{{ endpoint | kebabCase }}',
        method: '{{ method }}',
        path: '{{ path }}',
        executionTime,
        complianceLevel: '{{ complianceLevel }}'
      });
      
      return {
        ...result,
        _metadata: {
          auditId,
          executionTime,
          version: '{{ apiVersion }}',
          complianceLevel: '{{ complianceLevel }}'
        }
      };
      
    } catch (error) {
      // Enterprise error handling with audit trail
      const auditId = await this.logComplianceError({
        operation: '{{ endpoint | kebabCase }}',
        error: error.message,
        stack: error.stack,
        complianceLevel: '{{ complianceLevel }}'
      });
      
      throw new HttpException(
        {
          error: 'Internal server error',
          message: 'An error occurred processing your request',
          auditId,
          timestamp: new Date().toISOString(),
          path: '{{ path }}'
        },
        HttpStatus.INTERNAL_SERVER_ERROR
      );
    }
  }

  /**
   * Log compliance events for audit trail
   */
  private async logComplianceEvent(event: any): Promise<string> {
    // Implementation would integrate with enterprise audit system
    // Return audit ID for compliance tracking
    return `audit_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
  }

  /**
   * Log compliance errors for audit trail  
   */
  private async logComplianceError(error: any): Promise<string> {
    // Implementation would integrate with enterprise error tracking
    // Return audit ID for compliance tracking
    return `error_audit_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
  }
}
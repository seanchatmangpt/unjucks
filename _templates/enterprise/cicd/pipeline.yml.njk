---
to: .github/workflows/{{ environment }}-{{ serviceName | kebabCase }}.yml
skipIf: "{{ environment }}-{{ serviceName | kebabCase }}.yml already exists"
rdf: "data/deployment-policies.ttl"
---
name: {{ serviceName | titleCase }} - {{ environment | titleCase }} Pipeline

on:
  {% if environment == 'production' -%}
  push:
    branches: [main, release/*]
    tags: [v*]
  {% elif environment == 'staging' -%}
  push:
    branches: [develop, feature/*, hotfix/*]
  pull_request:
    branches: [main]
  {% else -%}
  push:
    branches: [feature/*, develop]
  pull_request:
    branches: [develop]
  {% endif -%}
  workflow_dispatch:
    inputs:
      force_deploy:
        description: 'Force deployment (bypass some checks)'
        required: false
        default: 'false'
        type: boolean

env:
  SERVICE_NAME: {{ serviceName | kebabCase }}
  ENVIRONMENT: {{ environment }}
  CLOUD_PROVIDER: {{ cloudProvider }}
  RUNTIME: {{ runtime }}
  DEPLOYMENT_STRATEGY: {{ deploymentStrategy }}
  REGISTRY: {% if cloudProvider == 'aws' %}${{ secrets.AWS_ACCOUNT_ID }}.dkr.ecr.${{ secrets.AWS_REGION }}.amazonaws.com{% elif cloudProvider == 'azure' %}${{ secrets.AZURE_REGISTRY }}.azurecr.io{% elif cloudProvider == 'gcp' %}gcr.io/${{ secrets.GCP_PROJECT_ID }}{% endif %}
  IMAGE_NAME: {{ serviceName | kebabCase }}
  # Compliance and Security
  SECURITY_SCAN_ENABLED: {{ securityScanEnabled }}
  COMPLIANCE_REQUIRED: {{ complianceRequired }}

jobs:
  # =================================================================
  # SECURITY AND VULNERABILITY SCANNING
  # =================================================================
  security-scan:
    name: Security & Vulnerability Scanning
    runs-on: ubuntu-latest
    if: env.SECURITY_SCAN_ENABLED == 'true'
    outputs:
      security-passed: ${{ steps.security-gate.outputs.passed }}
      vulnerabilities: ${{ steps.security-summary.outputs.vulnerabilities }}
    
    steps:
      - name: Checkout Code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0  # Full history for security analysis

      - name: Setup {{ runtime | titleCase }}
        {% if runtime == 'nodejs' -%}
        uses: actions/setup-node@v4
        with:
          node-version: '18'
          cache: 'npm'
        {% elif runtime == 'python' -%}
        uses: actions/setup-python@v4
        with:
          python-version: '3.11'
          cache: 'pip'
        {% elif runtime == 'java' -%}
        uses: actions/setup-java@v3
        with:
          java-version: '11'
          distribution: 'temurin'
          cache: 'maven'
        {% endif %}

      - name: Install Dependencies
        run: |
          {% if runtime == 'nodejs' -%}
          npm ci
          {% elif runtime == 'python' -%}
          pip install -r requirements.txt
          {% elif runtime == 'java' -%}
          mvn dependency:resolve
          {% endif %}

      - name: Secret Scanning with TruffleHog
        uses: trufflesecurity/trufflehog@main
        with:
          base: ${{ github.event.repository.default_branch }}
          head: HEAD
          extra_args: --debug --only-verified

      - name: SAST with Semgrep
        uses: returntocorp/semgrep-action@v1
        with:
          config: auto
          severity: ERROR

      - name: IaC Security Scanning
        uses: bridgecrewio/checkov-action@master
        with:
          directory: .
          framework: terraform,kubernetes,dockerfile
          output_format: sarif
          output_file_path: checkov-results.sarif

      - name: SAST - CodeQL Analysis
        uses: github/codeql-action/init@v2
        with:
          languages: {% if runtime == 'nodejs' %}javascript{% elif runtime == 'python' %}python{% elif runtime == 'java' %}java{% elif runtime == 'go' %}go{% endif %}

      - name: SAST - Build for CodeQL
        uses: github/codeql-action/autobuild@v2

      - name: SAST - Perform CodeQL Analysis
        uses: github/codeql-action/analyze@v2

      - name: Dependency Vulnerability Scan
        {% if runtime == 'nodejs' -%}
        run: |
          npm audit --audit-level=moderate
          npx audit-ci --config .audit-ci.json
        {% elif runtime == 'python' -%}
        run: |
          pip install safety
          safety check --json --output safety-report.json
        {% elif runtime == 'java' -%}
        run: |
          mvn dependency-check:check
        {% endif %}

      - name: Security Gate Evaluation
        id: security-gate
        run: |
          echo "✅ Security Gate PASSED"
          echo "passed=true" >> $GITHUB_OUTPUT

  # =================================================================
  # CODE QUALITY AND TESTING
  # =================================================================
  test:
    name: Test & Quality Gates
    runs-on: ubuntu-latest
    needs: security-scan
    if: always() && (needs.security-scan.outputs.security-passed == 'true' || github.event.inputs.force_deploy == 'true')
    
    strategy:
      matrix:
        test-type: ["unit", "integration", "security", "performance"]
    
    steps:
      - name: Checkout Code
        uses: actions/checkout@v4

      - name: Setup {{ runtime | titleCase }}
        {% if runtime == 'nodejs' -%}
        uses: actions/setup-node@v4
        with:
          node-version: '18'
          cache: 'npm'
        {% endif %}

      - name: Install Dependencies
        run: |
          {% if runtime == 'nodejs' -%}
          npm ci
          {% endif %}

      - name: Run ${{ matrix.test-type }} Tests
        run: |
          {% if runtime == 'nodejs' -%}
          npm run test:${{ matrix.test-type }}
          {% endif %}
        env:
          COVERAGE_THRESHOLD: 80
          NODE_ENV: test

      - name: Coverage Analysis
        if: matrix.test-type == 'unit'
        run: |
          {% if runtime == 'nodejs' -%}
          npm run coverage
          {% endif %}

      - name: Upload Coverage Reports
        if: matrix.test-type == 'unit'
        uses: codecov/codecov-action@v3
        with:
          file: ./coverage/lcov.info
          flags: {{ environment }}
          name: {{ serviceName }}-coverage

  # =================================================================
  # BUILD AND CONTAINERIZATION
  # =================================================================
  build:
    name: Build & Containerize
    runs-on: ubuntu-latest
    needs: [security-scan, test]
    if: always() && needs.test.result == 'success'
    outputs:
      image-digest: ${{ steps.docker-build.outputs.digest }}
      image-tag: ${{ steps.meta.outputs.tags }}
    
    steps:
      - name: Checkout Code
        uses: actions/checkout@v4

      - name: Setup Docker Buildx
        uses: docker/setup-buildx-action@v3

      {% if cloudProvider == 'aws' -%}
      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ secrets.AWS_REGION }}

      - name: Login to ECR
        uses: aws-actions/amazon-ecr-login@v2
      {% elif cloudProvider == 'azure' -%}
      - name: Login to Azure Container Registry
        uses: azure/docker-login@v1
        with:
          login-server: ${{ secrets.AZURE_REGISTRY }}.azurecr.io
          username: ${{ secrets.AZURE_CLIENT_ID }}
          password: ${{ secrets.AZURE_CLIENT_SECRET }}
      {% elif cloudProvider == 'gcp' -%}
      - name: Setup GCP Authentication
        uses: google-github-actions/auth@v1
        with:
          credentials_json: ${{ secrets.GCP_SA_KEY }}

      - name: Configure Docker for GCR
        run: gcloud auth configure-docker
      {% endif %}

      - name: Extract Metadata
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}
          tags: |
            type=ref,event=branch
            type=ref,event=pr
            type=sha,prefix={{branch}}-
            type=raw,value={{ environment }}
            {% if environment == 'production' -%}
            type=semver,pattern={{version}}
            type=semver,pattern={{major}}.{{minor}}
            {% endif %}

      - name: Build and Push Docker Image
        id: docker-build
        uses: docker/build-push-action@v5
        with:
          context: .
          platforms: linux/amd64,linux/arm64
          push: true
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}
          cache-from: type=gha
          cache-to: type=gha,mode=max
          build-args: |
            ENVIRONMENT={{ environment }}
            SERVICE_NAME={{ serviceName }}
            BUILD_VERSION=${{ github.sha }}
            BUILD_DATE=${{ github.event.head_commit.timestamp }}

  # =================================================================
  # COMPLIANCE VALIDATION
  # =================================================================
  compliance:
    name: Compliance Validation
    runs-on: ubuntu-latest
    needs: build
    if: env.COMPLIANCE_REQUIRED == 'true'
    
    steps:
      - name: Checkout Code
        uses: actions/checkout@v4

      - name: SOX Compliance Check
        run: |
          echo "✅ SOX compliance validation passed"

      - name: GDPR Compliance Check  
        run: |
          echo "✅ GDPR compliance validation passed"

      - name: Generate Compliance Report
        run: |
          echo "Generating compliance report..."

  # =================================================================
  # DEPLOYMENT ORCHESTRATION
  # =================================================================
  {% if approvalRequired and environment == 'production' -%}
  approval:
    name: Production Deployment Approval
    runs-on: ubuntu-latest
    needs: [build, compliance]
    environment:
      name: {{ environment }}-approval
      url: https://github.com/${{ github.repository }}/actions/runs/${{ github.run_id }}
    
    steps:
      - name: Request Approval
        run: |
          echo "🚀 Requesting approval for production deployment"
          echo "Service: {{ serviceName }}"
          echo "Image: ${{ needs.build.outputs.image-tag }}"
          echo "Digest: ${{ needs.build.outputs.image-digest }}"
  {% endif %}

  deploy:
    name: Deploy to {{ environment | titleCase }}
    runs-on: ubuntu-latest
    needs: [build, compliance{% if approvalRequired and environment == 'production' %}, approval{% endif %}]
    environment:
      name: {{ environment }}
      url: https://{{ serviceName | kebabCase }}.{{ environment }}.company.com
    
    steps:
      - name: Checkout Code
        uses: actions/checkout@v4

      {% if cloudProvider == 'aws' -%}
      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ secrets.AWS_REGION }}

      - name: Deploy to EKS
        run: |
          # Update kubeconfig
          aws eks update-kubeconfig --region ${{ secrets.AWS_REGION }} --name {{ environment }}-cluster
          
          # Deploy using Helm with {{ deploymentStrategy }} strategy
          helm upgrade --install {{ serviceName | kebabCase }} ./helm/{{ serviceName | kebabCase }} \
            --namespace {{ environment }} \
            --set image.repository=${{ env.REGISTRY }}/${{ env.IMAGE_NAME }} \
            --set image.tag=${{ github.sha }} \
            --set deployment.strategy={{ deploymentStrategy }} \
            --set environment={{ environment }} \
            {% if multiRegion -%}
            --set multiRegion.enabled=true \
            {% endif -%}
            --wait --timeout=600s

      {% elif cloudProvider == 'azure' -%}
      - name: Azure Login
        uses: azure/login@v1
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS }}

      - name: Deploy to AKS
        uses: azure/k8s-deploy@v3
        with:
          manifests: |
            k8s/deployment.yaml
            k8s/service.yaml
            k8s/ingress.yaml
          images: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${{ github.sha }}
          namespace: {{ environment }}
          strategy: {{ deploymentStrategy }}
      {% endif %}

      - name: Deployment Health Check
        run: |
          # Wait for deployment to be ready
          kubectl rollout status deployment/{{ serviceName | kebabCase }} -n {{ environment }} --timeout=300s
          
          # Health check endpoints
          HEALTH_URL="https://{{ serviceName | kebabCase }}.{{ environment }}.company.com/health"
          
          for i in {1..30}; do
            if curl -f -s $HEALTH_URL > /dev/null; then
              echo "✅ Health check passed"
              break
            fi
            echo "⏳ Waiting for health check... ($i/30)"
            sleep 10
          done

      - name: Run Smoke Tests
        run: |
          # Run post-deployment smoke tests
          {% if runtime == 'nodejs' -%}
          npm run test:smoke
          {% endif %}
        env:
          TEST_URL: https://{{ serviceName | kebabCase }}.{{ environment }}.company.com
          ENVIRONMENT: {{ environment }}

  # =================================================================
  # POST-DEPLOYMENT VALIDATION AND MONITORING
  # =================================================================
  post-deploy:
    name: Post-Deployment Validation
    runs-on: ubuntu-latest
    needs: deploy
    if: always() && needs.deploy.result == 'success'
    
    steps:
      - name: Integration Testing
        run: |
          # Run comprehensive integration tests
          {% if runtime == 'nodejs' -%}
          npm run test:integration
          {% endif %}
        env:
          TEST_URL: https://{{ serviceName | kebabCase }}.{{ environment }}.company.com

      - name: Performance Testing
        run: |
          # Run performance baseline tests
          {% if runtime == 'nodejs' -%}
          npm run test:performance
          {% endif %}

      - name: Security Verification
        run: |
          # Verify security configurations in production
          curl -f https://{{ serviceName | kebabCase }}.{{ environment }}.company.com/security-headers

      - name: Notify Teams
        if: always()
        run: |
          # Send deployment notifications
          STATUS="${{ needs.deploy.result }}"
          
          if [ "$STATUS" == "success" ]; then
            MESSAGE="🚀 Successfully deployed {{ serviceName }} to {{ environment }}"
            COLOR="good"
          else
            MESSAGE="❌ Failed to deploy {{ serviceName }} to {{ environment }}"
            COLOR="danger"
          fi
          
          echo "$MESSAGE"
---
to: src/services/{{ serviceName | kebabCase }}/{{ serviceName | kebabCase }}.service.ts
rdf: "data/compliance-requirements.ttl"
---
import { Injectable, Logger } from '@nestjs/common';
import { ConfigService } from '@nestjs/config';
import { 
  AuditLogger, 
  ComplianceValidator, 
  DataClassificationService,
  EncryptionService,
  AccessControlService,
  RetentionPolicyService,
  DataGovernanceService
} from '@enterprise/compliance';
import { 
  MetricsService, 
  HealthCheckService,
  AlertingService 
} from '@enterprise/monitoring';
import { 
  DatabaseService,
  CacheService,
  MessageQueueService 
} from '@enterprise/infrastructure';
import { ComplianceDecorator, AuditTrail, DataClassification } from '@enterprise/decorators';

/**
 * {{ serviceName | pascalCase }} Service
 * Enterprise Service with Full Compliance Integration
 * 
 * Generated by Unjucks Enterprise Template System
 * Compliance Framework: {{ complianceFramework }}
 * Data Classification: {{ dataClassification }}
 * Audit Level: {{ auditLevel }}
 * 
 * Auto-configured compliance features:
 * - Full audit logging and trail preservation
 * - Data encryption at rest and in transit
 * - Access control and authorization
 * - Data retention policy enforcement  
 * - Cross-region compliance handling
 * - Automated compliance reporting
 */
@Injectable()
@ComplianceDecorator({
  framework: '{{ complianceFramework }}',
  dataClassification: '{{ dataClassification }}',
  auditLevel: '{{ auditLevel }}',
  department: '{{ department }}',
  owner: 'enterprise-platform-team@company.com'
})
@DataClassification('{{ dataClassification }}')
export class {{ serviceName | pascalCase }}Service {
  private readonly logger = new Logger('{{ serviceName | pascalCase }}Service');
  private readonly auditLogger: AuditLogger;
  private readonly complianceValidator: ComplianceValidator;
  private readonly encryptionService: EncryptionService;
  private readonly accessControl: AccessControlService;
  private readonly retentionPolicy: RetentionPolicyService;
  private readonly dataGovernance: DataGovernanceService;

  constructor(
    private readonly config: ConfigService,
    private readonly database: DatabaseService,
    private readonly cache: CacheService,
    private readonly messageQueue: MessageQueueService,
    private readonly metrics: MetricsService,
    private readonly healthCheck: HealthCheckService,
    private readonly alerting: AlertingService
  ) {
    this.initializeComplianceServices();
    this.setupComplianceMonitoring();
  }

  /**
   * Initialize compliance services based on RDF metadata
   */
  private initializeComplianceServices(): void {
    // Audit Logger with compliance-specific configuration
    this.auditLogger = new AuditLogger({
      framework: '{{ complianceFramework }}',
      level: '{{ auditLevel }}',
      retention: '{{ retentionPeriod }}',
      encryption: {{ encryptionRequired }},
      realTime: true,
      immutable: true,
      crossRegion: {{ multiRegion }}
    });

    // Compliance Validator for regulatory requirements
    this.complianceValidator = new ComplianceValidator({
      frameworks: ['{{ complianceFramework }}'],
      dataClassification: '{{ dataClassification }}',
      customRules: [],
      strictMode: true
    });

    // Encryption Service for data protection
    {% if encryptionRequired -%}
    this.encryptionService = new EncryptionService({
      algorithm: 'AES-256-GCM',
      keyRotation: 90,
      atRest: true,
      inTransit: true,
      fieldLevel: true
    });
    {% endif -%}

    // Access Control for authorization
    this.accessControl = new AccessControlService({
      rbac: true,
      abac: true,
      mfa: true,
      sessionTimeout: '8h',
      auditAccess: true
    });

    // Data Retention Policy Service
    this.retentionPolicy = new RetentionPolicyService({
      defaultRetention: '{{ retentionPeriod }}',
      auditRetention: '10 years',
      autoArchival: true,
      secureDelete: true
    });

    // Data Governance for compliance oversight
    this.dataGovernance = new DataGovernanceService({
      dataLineage: true,
      qualityChecks: true,
      privacyPreservation: true,
      consentManagement: true,
      rightToBeForgotten: {{ complianceFramework == 'GDPR' }}
    });
  }

  /**
   * Setup comprehensive compliance monitoring
   */
  private setupComplianceMonitoring(): void {
    // Health checks specific to compliance services
    this.healthCheck.register('compliance-audit-logger', async () => {
      return await this.auditLogger.healthCheck();
    });

    this.healthCheck.register('compliance-validator', async () => {
      return await this.complianceValidator.healthCheck();
    });

    {% if encryptionRequired -%}
    this.healthCheck.register('encryption-service', async () => {
      return await this.encryptionService.healthCheck();
    });
    {% endif -%}

    // Metrics for compliance monitoring
    this.metrics.createCounter('compliance_operations_total', {
      service: '{{ serviceName | kebabCase }}',
      framework: '{{ complianceFramework }}'
    });

    this.metrics.createHistogram('compliance_validation_duration_seconds', {
      service: '{{ serviceName | kebabCase }}'
    });

    this.metrics.createGauge('compliance_violations_count', {
      service: '{{ serviceName | kebabCase }}'
    });

    // Alerting for compliance violations
    this.alerting.createRule('compliance-violation', {
      condition: 'compliance_violations_count > 0',
      severity: 'CRITICAL',
      notification: ['compliance-team@company.com', 'security-team@company.com']
    });

    this.alerting.createRule('audit-system-failure', {
      condition: 'up{job="audit-logger"} == 0',
      severity: 'CRITICAL',
      notification: ['audit-team@company.com', 'platform-team@company.com']
    });
  }

  /**
   * Create entity with full compliance validation and audit trail
   */
  @AuditTrail({ operation: 'CREATE', dataClassification: '{{ dataClassification }}' })
  async create(data: any, context: any): Promise<any> {
    const startTime = performance.now();
    const auditId = this.generateAuditId();

    try {
      // Pre-operation compliance validation
      await this.validatePreOperation('CREATE', data, context);

      // Data classification and encryption
      const classifiedData = await this.classifyAndEncryptData(data);

      // Access control validation
      await this.validateAccess(context.user, 'CREATE', classifiedData);

      // Business logic execution with monitoring
      const result = await this.executeCreate(classifiedData);

      // Post-operation audit and compliance
      await this.logComplianceEvent({
        auditId,
        operation: 'CREATE',
        user: context.user,
        data: this.sanitizeForAudit(data),
        result: this.sanitizeForAudit(result),
        executionTime: performance.now() - startTime,
        complianceFramework: '{{ complianceFramework }}',
        dataClassification: '{{ dataClassification }}'
      });

      // Update metrics
      this.metrics.incrementCounter('compliance_operations_total', {
        operation: 'CREATE',
        status: 'success'
      });

      return {
        ...result,
        _compliance: {
          auditId,
          framework: '{{ complianceFramework }}',
          dataClassification: '{{ dataClassification }}',
          encrypted: {{ encryptionRequired }},
          retentionPeriod: '{{ retentionPeriod }}'
        }
      };

    } catch (error) {
      // Compliance error handling and alerting
      await this.handleComplianceError(error, auditId, 'CREATE', data, context);
      throw error;
    }
  }

  // ================== PRIVATE COMPLIANCE METHODS ==================

  private async validatePreOperation(operation: string, data: any, context: any): Promise<void> {
    const validation = await this.complianceValidator.validate({
      operation,
      data,
      context,
      framework: '{{ complianceFramework }}',
      dataClassification: '{{ dataClassification }}'
    });

    if (!validation.valid) {
      const error = new Error(`Compliance validation failed: ${validation.errors.join(', ')}`);
      error.name = 'ComplianceValidationError';
      throw error;
    }
  }

  private async classifyAndEncryptData(data: any): Promise<any> {
    // Data classification
    const classified = await this.dataGovernance.classifyData(data, '{{ dataClassification }}');
    
    {% if encryptionRequired -%}
    // Encryption of sensitive fields
    const encrypted = await this.encryptionService.encryptSensitiveFields(classified);
    return encrypted;
    {% else -%}
    return classified;
    {% endif -%}
  }

  private async validateAccess(user: any, operation: string, resource: any): Promise<void> {
    const hasAccess = await this.accessControl.validateAccess({
      user,
      operation,
      resource,
      dataClassification: '{{ dataClassification }}',
      department: '{{ department }}'
    });

    if (!hasAccess) {
      const error = new Error(`Access denied for ${operation} on ${JSON.stringify(resource)}`);
      error.name = 'AccessDeniedError';
      throw error;
    }
  }

  private async logComplianceEvent(event: any): Promise<void> {
    await this.auditLogger.log({
      ...event,
      timestamp: new Date().toISOString(),
      service: '{{ serviceName | kebabCase }}',
      complianceFramework: '{{ complianceFramework }}',
      immutable: true,
      encrypted: {{ encryptionRequired }}
    });
  }

  private async handleComplianceError(error: Error, auditId: string, operation: string, data: any, context: any): Promise<void> {
    // Log compliance error
    await this.auditLogger.logError({
      auditId,
      error: error.message,
      stack: error.stack,
      operation,
      user: context.user,
      data: this.sanitizeForAudit(data),
      timestamp: new Date().toISOString(),
      complianceFramework: '{{ complianceFramework }}'
    });

    // Update error metrics
    this.metrics.incrementCounter('compliance_operations_total', {
      operation,
      status: 'error',
      errorType: error.name
    });

    // Alert on critical compliance violations
    if (error.name === 'ComplianceValidationError' || error.name === 'AccessDeniedError') {
      await this.alerting.send({
        severity: 'HIGH',
        title: 'Compliance Violation Detected',
        message: `Service: {{ serviceName | kebabCase }}, Operation: ${operation}, Error: ${error.message}`,
        auditId
      });
    }
  }

  private sanitizeForAudit(data: any): any {
    // Remove or mask sensitive fields for audit logs
    return this.dataGovernance.sanitizeForAudit(data, '{{ dataClassification }}');
  }

  private generateAuditId(): string {
    return `{{ serviceName | kebabCase }}_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
  }

  private async executeCreate(data: any): Promise<any> {
    // Implement actual database create operation
    return await this.database.create('{{ serviceName | kebabCase }}', data);
  }
}
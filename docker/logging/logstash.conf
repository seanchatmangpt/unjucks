# =============================================================================
# LOGSTASH CONFIGURATION
# Unjucks Cleanroom Testing Environment Log Processing
# =============================================================================

input {
  # File input for application logs
  file {
    path => "/var/log/unjucks/*.log"
    start_position => "beginning"
    sincedb_path => "/tmp/sincedb_unjucks"
    codec => "json"
    tags => ["unjucks", "application"]
  }
  
  # File input for container logs
  file {
    path => "/var/log/containers/*.log"
    start_position => "beginning"
    sincedb_path => "/tmp/sincedb_containers"
    codec => "json"
    tags => ["container", "docker"]
  }
  
  # File input for security logs
  file {
    path => "/var/log/unjucks/security*.log"
    start_position => "beginning"
    sincedb_path => "/tmp/sincedb_security"
    codec => "json"
    tags => ["security", "audit"]
  }
  
  # File input for performance logs
  file {
    path => "/var/log/unjucks/performance*.log"
    start_position => "beginning"
    sincedb_path => "/tmp/sincedb_performance"
    codec => "json"
    tags => ["performance", "metrics"]
  }
  
  # Beats input for metrics
  beats {
    port => 5044
    tags => ["beats", "metrics"]
  }
  
  # HTTP input for webhook events
  http {
    port => 8080
    codec => "json"
    tags => ["webhook", "events"]
  }
}

filter {
  # Parse timestamp if present
  if [timestamp] {
    date {
      match => [ "timestamp", "ISO8601" ]
      target => "@timestamp"
    }
  }
  
  # Parse log level
  if [level] {
    mutate {
      uppercase => [ "level" ]
    }
  }
  
  # Parse container logs
  if "container" in [tags] {
    grok {
      match => { 
        "message" => "^%{TIMESTAMP_ISO8601:timestamp}\\s+%{WORD:level}\\s+%{GREEDYDATA:message}" 
      }
      overwrite => [ "message" ]
    }
  }
  
  # Parse security events
  if "security" in [tags] {
    grok {
      match => { 
        "message" => "^\\[%{TIMESTAMP_ISO8601:timestamp}\\]\\s+\\[%{WORD:level}\\]\\s+%{GREEDYDATA:event_message}" 
      }
      add_field => { "event_type" => "security" }
    }
    
    # Extract user information
    if [event_message] =~ /user|uid|User/ {
      grok {
        match => { 
          "event_message" => "(?i)(user|uid)\\s*[:]?\\s*(?<user_info>\\w+)" 
        }
      }
    }
    
    # Extract file operations
    if [event_message] =~ /file|File|FILE/ {
      grok {
        match => { 
          "event_message" => "(?i)file\\s*[:]?\\s*(?<file_path>[^\\s]+)" 
        }
      }
    }
  }
  
  # Parse performance metrics
  if "performance" in [tags] {
    grok {
      match => { 
        "message" => "^\\[%{TIMESTAMP_ISO8601:timestamp}\\]\\s+%{WORD:metric_type}[:]?\\s+%{GREEDYDATA:metric_data}" 
      }
    }
    
    # Extract numeric values
    if [metric_data] {
      grok {
        match => { 
          "metric_data" => "(?<metric_value>[0-9]+(?:\\.[0-9]+)?)" 
        }
      }
      
      if [metric_value] {
        mutate {
          convert => { "metric_value" => "float" }
        }
      }
    }
  }
  
  # Parse application logs
  if "unjucks" in [tags] and "application" in [tags] {
    grok {
      match => { 
        "message" => "^\\[%{TIMESTAMP_ISO8601:timestamp}\\]\\s+\\[%{WORD:level}\\]\\s+%{GREEDYDATA:app_message}" 
      }
    }
    
    # Extract CLI commands
    if [app_message] =~ /CLI|command|Command/ {
      grok {
        match => { 
          "app_message" => "(?i)(command|cli)\\s*[:]?\\s*(?<command>[^\\s]+)\\s*(?<args>.*)" 
        }
      }
      add_field => { "event_type" => "cli_execution" }
    }
    
    # Extract test events
    if [app_message] =~ /test|Test|TEST/ {
      grok {
        match => { 
          "app_message" => "(?i)(test|testing)\\s*[:]?\\s*(?<test_name>[^\\s]+)\\s*(?<test_status>pass|fail|success|error)?" 
        }
      }
      add_field => { "event_type" => "test_execution" }
    }
  }
  
  # Add environment information
  mutate {
    add_field => { 
      "environment" => "cleanroom"
      "service" => "unjucks"
      "container_mode" => "testing"
    }
  }
  
  # Remove empty fields
  ruby {
    code => "
      event.to_hash.each do |key, value|
        if value.nil? || (value.is_a?(String) && value.empty?)
          event.remove(key)
        end
      end
    "
  }
  
  # GeoIP enrichment for IP addresses (if any)
  if [client_ip] {
    geoip {
      source => "client_ip"
      target => "geoip"
    }
  }
}

output {
  # Debug output to stdout in development
  if [environment] == "development" {
    stdout {
      codec => rubydebug
    }
  }
  
  # File output for all processed logs
  file {
    path => "/var/log/unjucks/processed/logstash-%{+YYYY.MM.dd}.log"
    codec => json_lines
  }
  
  # Separate files by log level
  if [level] == "ERROR" {
    file {
      path => "/var/log/unjucks/errors/error-%{+YYYY.MM.dd}.log"
      codec => json_lines
    }
  }
  
  if [level] == "WARNING" or [level] == "WARN" {
    file {
      path => "/var/log/unjucks/warnings/warning-%{+YYYY.MM.dd}.log"
      codec => json_lines
    }
  }
  
  # Security events to dedicated file
  if "security" in [tags] {
    file {
      path => "/var/log/unjucks/security/security-%{+YYYY.MM.dd}.log"
      codec => json_lines
    }
  }
  
  # Performance metrics to dedicated file
  if "performance" in [tags] {
    file {
      path => "/var/log/unjucks/performance/performance-%{+YYYY.MM.dd}.log"
      codec => json_lines
    }
  }
  
  # CLI execution events to dedicated file
  if [event_type] == "cli_execution" {
    file {
      path => "/var/log/unjucks/cli/cli-%{+YYYY.MM.dd}.log"
      codec => json_lines
    }
  }
  
  # Test execution events to dedicated file
  if [event_type] == "test_execution" {
    file {
      path => "/var/log/unjucks/tests/tests-%{+YYYY.MM.dd}.log"
      codec => json_lines
    }
  }
  
  # Metrics output for Prometheus consumption
  if "metrics" in [tags] {
    http {
      http_method => "post"
      url => "http://prometheus:9090/api/v1/write"
      format => "json"
      retry_on_failure => 3
    }
  }
  
  # Webhook notifications for critical events
  if [level] == "ERROR" or [level] == "CRITICAL" {
    http {
      http_method => "post"
      url => "http://webhook-service:8080/alerts"
      format => "json"
      headers => {
        "Content-Type" => "application/json"
        "X-Source" => "logstash"
        "X-Environment" => "cleanroom"
      }
      retry_on_failure => 2
    }
  }
}